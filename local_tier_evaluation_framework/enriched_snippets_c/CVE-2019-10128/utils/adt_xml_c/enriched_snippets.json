[
  {
    "function_name": "XmlTableDestroyOpaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4716-4756",
    "snippet": "static void\nXmlTableDestroyOpaque(TableFuncScanState *state)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableDestroyOpaque\");\n\n\t/* Propagate context related error context to libxml2 */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\tif (xtCxt->xpathscomp != NULL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < xtCxt->natts; i++)\n\t\t\tif (xtCxt->xpathscomp[i] != NULL)\n\t\t\t\txmlXPathFreeCompExpr(xtCxt->xpathscomp[i]);\n\t}\n\n\tif (xtCxt->xpathobj != NULL)\n\t\txmlXPathFreeObject(xtCxt->xpathobj);\n\tif (xtCxt->xpathcomp != NULL)\n\t\txmlXPathFreeCompExpr(xtCxt->xpathcomp);\n\tif (xtCxt->xpathcxt != NULL)\n\t\txmlXPathFreeContext(xtCxt->xpathcxt);\n\tif (xtCxt->doc != NULL)\n\t\txmlFreeDoc(xtCxt->doc);\n\tif (xtCxt->ctxt != NULL)\n\t\txmlFreeParserCtxt(xtCxt->ctxt);\n\n\tpg_xml_done(xtCxt->xmlerrcxt, true);\n\n\t/* not valid anymore */\n\txtCxt->magic = 0;\n\tstate->opaque = NULL;\n\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xtCxt->xmlerrcxt",
            "true"
          ],
          "line": 4747
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "xtCxt->ctxt"
          ],
          "line": 4745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xtCxt->doc"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xtCxt->xpathcxt"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeCompExpr",
          "args": [
            "xtCxt->xpathcomp"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeObject",
          "args": [
            "xtCxt->xpathobj"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeCompExpr",
          "args": [
            "xtCxt->xpathscomp[i]"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSetStructuredErrorFunc",
          "args": [
            "(void *) xtCxt->xmlerrcxt",
            "xml_errorHandler"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableDestroyOpaque\""
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableDestroyOpaque(TableFuncScanState *state)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableDestroyOpaque\");\n\n\t/* Propagate context related error context to libxml2 */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\tif (xtCxt->xpathscomp != NULL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < xtCxt->natts; i++)\n\t\t\tif (xtCxt->xpathscomp[i] != NULL)\n\t\t\t\txmlXPathFreeCompExpr(xtCxt->xpathscomp[i]);\n\t}\n\n\tif (xtCxt->xpathobj != NULL)\n\t\txmlXPathFreeObject(xtCxt->xpathobj);\n\tif (xtCxt->xpathcomp != NULL)\n\t\txmlXPathFreeCompExpr(xtCxt->xpathcomp);\n\tif (xtCxt->xpathcxt != NULL)\n\t\txmlXPathFreeContext(xtCxt->xpathcxt);\n\tif (xtCxt->doc != NULL)\n\t\txmlFreeDoc(xtCxt->doc);\n\tif (xtCxt->ctxt != NULL)\n\t\txmlFreeParserCtxt(xtCxt->ctxt);\n\n\tpg_xml_done(xtCxt->xmlerrcxt, true);\n\n\t/* not valid anymore */\n\txtCxt->magic = 0;\n\tstate->opaque = NULL;\n\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableGetValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4546-4710",
    "snippet": "static Datum\nXmlTableGetValue(TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\tDatum\t\tresult = (Datum) 0;\n\txmlNodePtr\tcur;\n\tchar\t   *cstr = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableGetValue\");\n\n\tAssert(xtCxt->xpathobj &&\n\t\t   xtCxt->xpathobj->type == XPATH_NODESET &&\n\t\t   xtCxt->xpathobj->nodesetval != NULL);\n\n\t/* Propagate context related error context to libxml2 */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\t*isnull = false;\n\n\tcur = xtCxt->xpathobj->nodesetval->nodeTab[xtCxt->row_count - 1];\n\n\tAssert(xtCxt->xpathscomp[colnum] != NULL);\n\n\tPG_TRY();\n\t{\n\t\t/* Set current node as entry point for XPath evaluation */\n\t\txtCxt->xpathcxt->node = cur;\n\n\t\t/* Evaluate column path */\n\t\txpathobj = xmlXPathCompiledEval(xtCxt->xpathscomp[colnum], xtCxt->xpathcxt);\n\t\tif (xpathobj == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * There are four possible cases, depending on the number of nodes\n\t\t * returned by the XPath expression and the type of the target column:\n\t\t * a) XPath returns no nodes.  b) One node is returned, and column is\n\t\t * of type XML.  c) One node, column type other than XML.  d) Multiple\n\t\t * nodes are returned.\n\t\t */\n\t\tif (xpathobj->type == XPATH_NODESET)\n\t\t{\n\t\t\tint\t\t\tcount = 0;\n\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t\tcount = xpathobj->nodesetval->nodeNr;\n\n\t\t\tif (xpathobj->nodesetval == NULL || count == 0)\n\t\t\t{\n\t\t\t\t*isnull = true;\n\t\t\t}\n\t\t\telse if (count == 1 && typid == XMLOID)\n\t\t\t{\n\t\t\t\ttext\t   *textstr;\n\n\t\t\t\t/* simple case, result is one value */\n\t\t\t\ttextstr = xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[0],\n\t\t\t\t\t\t\t\t\t\t\t   xtCxt->xmlerrcxt);\n\t\t\t\tcstr = text_to_cstring(textstr);\n\t\t\t}\n\t\t\telse if (count == 1)\n\t\t\t{\n\t\t\t\txmlChar    *str;\n\t\t\t\txmlNodePtr\tnode;\n\n\t\t\t\t/*\n\t\t\t\t * Most nodes (elements and even attributes) store their data\n\t\t\t\t * in children nodes. If they don't have children nodes, it\n\t\t\t\t * means that they are empty (e.g. <element/>). Text nodes and\n\t\t\t\t * CDATA sections are an exception: they don't have children\n\t\t\t\t * but have content in the Text/CDATA node itself.\n\t\t\t\t */\n\t\t\t\tnode = xpathobj->nodesetval->nodeTab[0];\n\t\t\t\tif (node->type != XML_CDATA_SECTION_NODE &&\n\t\t\t\t\tnode->type != XML_TEXT_NODE)\n\t\t\t\t\tnode = node->xmlChildrenNode;\n\n\t\t\t\tstr = xmlNodeListGetString(xtCxt->doc, node, 1);\n\t\t\t\tif (str != NULL)\n\t\t\t\t{\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr = pstrdup((char *) str);\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\txmlFree(str);\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\t\t\t\t\txmlFree(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Ensure mapping of empty tags to PostgreSQL values. */\n\t\t\t\t\tcstr = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringInfoData str;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tAssert(count > 1);\n\n\t\t\t\t/*\n\t\t\t\t * When evaluating the XPath expression returns multiple\n\t\t\t\t * nodes, the result is the concatenation of them all. The\n\t\t\t\t * target type must be XML.\n\t\t\t\t */\n\t\t\t\tif (typid != XMLOID)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CARDINALITY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"more than one value returned by column XPath expression\")));\n\n\t\t\t\t/* Concatenate serialized values */\n\t\t\t\tinitStringInfo(&str);\n\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t{\n\t\t\t\t\tappendStringInfoText(&str,\n\t\t\t\t\t\t\t\t\t\t xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  xtCxt->xmlerrcxt));\n\t\t\t\t}\n\t\t\t\tcstr = str.data;\n\t\t\t}\n\t\t}\n\t\telse if (xpathobj->type == XPATH_STRING)\n\t\t{\n\t\t\tcstr = (char *) xpathobj->stringval;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected XPath object type %u\", xpathobj->type);\n\n\t\t/*\n\t\t * By here, either cstr contains the result value, or the isnull flag\n\t\t * has been set.\n\t\t */\n\t\tAssert(cstr || *isnull);\n\n\t\tif (!*isnull)\n\t\t\tresult = InputFunctionCall(&state->in_functions[colnum],\n\t\t\t\t\t\t\t\t\t   cstr,\n\t\t\t\t\t\t\t\t\t   state->typioparams[colnum],\n\t\t\t\t\t\t\t\t\t   typmod);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj != NULL)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
      "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);",
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);",
      "static void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);",
      "static void XmlTableSetColumnFilter(struct TableFuncScanState *state,\n\t\t\t\t\t\tconst char *path, int colnum);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeObject",
          "args": [
            "xpathobj"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 4699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeObject",
          "args": [
            "xpathobj"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&state->in_functions[colnum]",
            "cstr",
            "state->typioparams[colnum]",
            "typmod"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cstr || *isnull"
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected XPath object type %u\"",
            "xpathobj->type"
          ],
          "line": 4681
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoText",
          "args": [
            "&str",
            "xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  xtCxt->xmlerrcxt)"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "437-441",
          "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_xmlnodetoxmltype",
          "args": [
            "xpathobj->nodesetval->nodeTab[i]",
            "xtCxt->xmlerrcxt"
          ],
          "line": 4670
        },
        "resolved": true,
        "details": {
          "function_name": "xml_xmlnodetoxmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3788-3849",
          "snippet": "static text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_CARDINALITY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"more than one value returned by column XPath expression\"))"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"more than one value returned by column XPath expression\""
          ],
          "line": 4663
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CARDINALITY_VIOLATION"
          ],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "count > 1"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFree",
          "args": [
            "str"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFree",
          "args": [
            "str"
          ],
          "line": 4636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "(char *) str"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeListGetString",
          "args": [
            "xtCxt->doc",
            "node",
            "1"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "textstr"
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_INTERNAL_ERROR",
            "\"could not create XPath object\""
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathCompiledEval",
          "args": [
            "xtCxt->xpathscomp[colnum]",
            "xtCxt->xpathcxt"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "xtCxt->xpathscomp[colnum] != NULL"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSetStructuredErrorFunc",
          "args": [
            "(void *) xtCxt->xmlerrcxt",
            "xml_errorHandler"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "xtCxt->xpathobj &&\n\t\t   xtCxt->xpathobj->type == XPATH_NODESET &&\n\t\t   xtCxt->xpathobj->nodesetval != NULL"
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableGetValue\""
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\nstatic void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);\nstatic void XmlTableSetColumnFilter(struct TableFuncScanState *state,\n\t\t\t\t\t\tconst char *path, int colnum);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic Datum\nXmlTableGetValue(TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\tDatum\t\tresult = (Datum) 0;\n\txmlNodePtr\tcur;\n\tchar\t   *cstr = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableGetValue\");\n\n\tAssert(xtCxt->xpathobj &&\n\t\t   xtCxt->xpathobj->type == XPATH_NODESET &&\n\t\t   xtCxt->xpathobj->nodesetval != NULL);\n\n\t/* Propagate context related error context to libxml2 */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\t*isnull = false;\n\n\tcur = xtCxt->xpathobj->nodesetval->nodeTab[xtCxt->row_count - 1];\n\n\tAssert(xtCxt->xpathscomp[colnum] != NULL);\n\n\tPG_TRY();\n\t{\n\t\t/* Set current node as entry point for XPath evaluation */\n\t\txtCxt->xpathcxt->node = cur;\n\n\t\t/* Evaluate column path */\n\t\txpathobj = xmlXPathCompiledEval(xtCxt->xpathscomp[colnum], xtCxt->xpathcxt);\n\t\tif (xpathobj == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * There are four possible cases, depending on the number of nodes\n\t\t * returned by the XPath expression and the type of the target column:\n\t\t * a) XPath returns no nodes.  b) One node is returned, and column is\n\t\t * of type XML.  c) One node, column type other than XML.  d) Multiple\n\t\t * nodes are returned.\n\t\t */\n\t\tif (xpathobj->type == XPATH_NODESET)\n\t\t{\n\t\t\tint\t\t\tcount = 0;\n\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t\tcount = xpathobj->nodesetval->nodeNr;\n\n\t\t\tif (xpathobj->nodesetval == NULL || count == 0)\n\t\t\t{\n\t\t\t\t*isnull = true;\n\t\t\t}\n\t\t\telse if (count == 1 && typid == XMLOID)\n\t\t\t{\n\t\t\t\ttext\t   *textstr;\n\n\t\t\t\t/* simple case, result is one value */\n\t\t\t\ttextstr = xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[0],\n\t\t\t\t\t\t\t\t\t\t\t   xtCxt->xmlerrcxt);\n\t\t\t\tcstr = text_to_cstring(textstr);\n\t\t\t}\n\t\t\telse if (count == 1)\n\t\t\t{\n\t\t\t\txmlChar    *str;\n\t\t\t\txmlNodePtr\tnode;\n\n\t\t\t\t/*\n\t\t\t\t * Most nodes (elements and even attributes) store their data\n\t\t\t\t * in children nodes. If they don't have children nodes, it\n\t\t\t\t * means that they are empty (e.g. <element/>). Text nodes and\n\t\t\t\t * CDATA sections are an exception: they don't have children\n\t\t\t\t * but have content in the Text/CDATA node itself.\n\t\t\t\t */\n\t\t\t\tnode = xpathobj->nodesetval->nodeTab[0];\n\t\t\t\tif (node->type != XML_CDATA_SECTION_NODE &&\n\t\t\t\t\tnode->type != XML_TEXT_NODE)\n\t\t\t\t\tnode = node->xmlChildrenNode;\n\n\t\t\t\tstr = xmlNodeListGetString(xtCxt->doc, node, 1);\n\t\t\t\tif (str != NULL)\n\t\t\t\t{\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr = pstrdup((char *) str);\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\txmlFree(str);\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\t\t\t\t\txmlFree(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Ensure mapping of empty tags to PostgreSQL values. */\n\t\t\t\t\tcstr = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringInfoData str;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\tAssert(count > 1);\n\n\t\t\t\t/*\n\t\t\t\t * When evaluating the XPath expression returns multiple\n\t\t\t\t * nodes, the result is the concatenation of them all. The\n\t\t\t\t * target type must be XML.\n\t\t\t\t */\n\t\t\t\tif (typid != XMLOID)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CARDINALITY_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"more than one value returned by column XPath expression\")));\n\n\t\t\t\t/* Concatenate serialized values */\n\t\t\t\tinitStringInfo(&str);\n\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t{\n\t\t\t\t\tappendStringInfoText(&str,\n\t\t\t\t\t\t\t\t\t\t xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  xtCxt->xmlerrcxt));\n\t\t\t\t}\n\t\t\t\tcstr = str.data;\n\t\t\t}\n\t\t}\n\t\telse if (xpathobj->type == XPATH_STRING)\n\t\t{\n\t\t\tcstr = (char *) xpathobj->stringval;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected XPath object type %u\", xpathobj->type);\n\n\t\t/*\n\t\t * By here, either cstr contains the result value, or the isnull flag\n\t\t * has been set.\n\t\t */\n\t\tAssert(cstr || *isnull);\n\n\t\tif (!*isnull)\n\t\t\tresult = InputFunctionCall(&state->in_functions[colnum],\n\t\t\t\t\t\t\t\t\t   cstr,\n\t\t\t\t\t\t\t\t\t   state->typioparams[colnum],\n\t\t\t\t\t\t\t\t\t   typmod);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj != NULL)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableFetchRow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4495-4536",
    "snippet": "static bool\nXmlTableFetchRow(TableFuncScanState *state)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableFetchRow\");\n\n\t/*\n\t * XmlTable returns table - set of composite values. The error context, is\n\t * used for producement more values, between two calls, there can be\n\t * created and used another libxml2 error context. It is libxml2 global\n\t * value, so it should be refreshed any time before any libxml2 usage,\n\t * that is finished by returning some value.\n\t */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\tif (xtCxt->xpathobj == NULL)\n\t{\n\t\txtCxt->xpathobj = xmlXPathCompiledEval(xtCxt->xpathcomp, xtCxt->xpathcxt);\n\t\tif (xtCxt->xpathobj == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\txtCxt->row_count = 0;\n\t}\n\n\tif (xtCxt->xpathobj->type == XPATH_NODESET)\n\t{\n\t\tif (xtCxt->xpathobj->nodesetval != NULL)\n\t\t{\n\t\t\tif (xtCxt->row_count++ < xtCxt->xpathobj->nodesetval->nodeNr)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n#else\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_INTERNAL_ERROR",
            "\"could not create XPath object\""
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathCompiledEval",
          "args": [
            "xtCxt->xpathcomp",
            "xtCxt->xpathcxt"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSetStructuredErrorFunc",
          "args": [
            "(void *) xtCxt->xmlerrcxt",
            "xml_errorHandler"
          ],
          "line": 4510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableFetchRow\""
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic bool\nXmlTableFetchRow(TableFuncScanState *state)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableFetchRow\");\n\n\t/*\n\t * XmlTable returns table - set of composite values. The error context, is\n\t * used for producement more values, between two calls, there can be\n\t * created and used another libxml2 error context. It is libxml2 global\n\t * value, so it should be refreshed any time before any libxml2 usage,\n\t * that is finished by returning some value.\n\t */\n\txmlSetStructuredErrorFunc((void *) xtCxt->xmlerrcxt, xml_errorHandler);\n\n\tif (xtCxt->xpathobj == NULL)\n\t{\n\t\txtCxt->xpathobj = xmlXPathCompiledEval(xtCxt->xpathcomp, xtCxt->xpathcxt);\n\t\tif (xtCxt->xpathobj == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\txtCxt->row_count = 0;\n\t}\n\n\tif (xtCxt->xpathobj->type == XPATH_NODESET)\n\t{\n\t\tif (xtCxt->xpathobj->nodesetval != NULL)\n\t\t{\n\t\t\tif (xtCxt->row_count++ < xtCxt->xpathobj->nodesetval->nodeNr)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n#else\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableSetColumnFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4463-4488",
    "snippet": "static void\nXmlTableSetColumnFilter(TableFuncScanState *state, const char *path, int colnum)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmlChar    *xstr;\n\n\tAssertArg(PointerIsValid(path));\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetColumnFilter\");\n\n\tif (*path == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"column path filter must not be empty string\")));\n\n\txstr = pg_xmlCharStrndup(path, strlen(path));\n\n\txtCxt->xpathscomp[colnum] = xmlXPathCompile(xstr);\n\tif (xtCxt->xpathscomp[colnum] == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,\n\t\t\t\t\t\"invalid XPath expression\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);",
      "static void XmlTableSetColumnFilter(struct TableFuncScanState *state,\n\t\t\t\t\t\tconst char *path, int colnum);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_DATA_EXCEPTION",
            "\"invalid XPath expression\""
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathCompile",
          "args": [
            "xstr"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xmlCharStrndup",
          "args": [
            "path",
            "strlen(path)"
          ],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xmlCharStrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1167-1177",
          "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"column path filter must not be empty string\"))"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"column path filter must not be empty string\""
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 4476
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableSetColumnFilter\""
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "PointerIsValid(path)"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "path"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);\nstatic void XmlTableSetColumnFilter(struct TableFuncScanState *state,\n\t\t\t\t\t\tconst char *path, int colnum);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableSetColumnFilter(TableFuncScanState *state, const char *path, int colnum)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmlChar    *xstr;\n\n\tAssertArg(PointerIsValid(path));\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetColumnFilter\");\n\n\tif (*path == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"column path filter must not be empty string\")));\n\n\txstr = pg_xmlCharStrndup(path, strlen(path));\n\n\txtCxt->xpathscomp[colnum] = xmlXPathCompile(xstr);\n\tif (xtCxt->xpathscomp[colnum] == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,\n\t\t\t\t\t\"invalid XPath expression\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableSetRowFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4434-4457",
    "snippet": "static void\nXmlTableSetRowFilter(TableFuncScanState *state, const char *path)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmlChar    *xstr;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetRowFilter\");\n\n\tif (*path == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"row path filter must not be empty string\")));\n\n\txstr = pg_xmlCharStrndup(path, strlen(path));\n\n\txtCxt->xpathcomp = xmlXPathCompile(xstr);\n\tif (xtCxt->xpathcomp == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_SYNTAX_ERROR,\n\t\t\t\t\t\"invalid XPath expression\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_SYNTAX_ERROR",
            "\"invalid XPath expression\""
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathCompile",
          "args": [
            "xstr"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xmlCharStrndup",
          "args": [
            "path",
            "strlen(path)"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xmlCharStrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1167-1177",
          "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"row path filter must not be empty string\"))"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"row path filter must not be empty string\""
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableSetRowFilter\""
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetRowFilter(struct TableFuncScanState *state, const char *path);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableSetRowFilter(TableFuncScanState *state, const char *path)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmlChar    *xstr;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetRowFilter\");\n\n\tif (*path == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"row path filter must not be empty string\")));\n\n\txstr = pg_xmlCharStrndup(path, strlen(path));\n\n\txtCxt->xpathcomp = xmlXPathCompile(xstr);\n\tif (xtCxt->xpathcomp == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_SYNTAX_ERROR,\n\t\t\t\t\t\"invalid XPath expression\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableSetNamespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4408-4428",
    "snippet": "static void\nXmlTableSetNamespace(TableFuncScanState *state, const char *name, const char *uri)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\tif (name == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"DEFAULT namespace is not supported\")));\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetNamespace\");\n\n\tif (xmlXPathRegisterNs(xtCxt->xpathcxt,\n\t\t\t\t\t\t   pg_xmlCharStrndup(name, strlen(name)),\n\t\t\t\t\t\t   pg_xmlCharStrndup(uri, strlen(uri))))\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,\n\t\t\t\t\t\"could not set XML namespace\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetNamespace(struct TableFuncScanState *state, const char *name,\n\t\t\t\t\t const char *uri);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_DATA_EXCEPTION",
            "\"could not set XML namespace\""
          ],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathRegisterNs",
          "args": [
            "xtCxt->xpathcxt",
            "pg_xmlCharStrndup(name, strlen(name))",
            "pg_xmlCharStrndup(uri, strlen(uri))"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xmlCharStrndup",
          "args": [
            "uri",
            "strlen(uri)"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xmlCharStrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1167-1177",
          "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "uri"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableSetNamespace\""
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"DEFAULT namespace is not supported\"))"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"DEFAULT namespace is not supported\""
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetNamespace(struct TableFuncScanState *state, const char *name,\n\t\t\t\t\t const char *uri);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableSetNamespace(TableFuncScanState *state, const char *name, const char *uri)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\n\tif (name == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"DEFAULT namespace is not supported\")));\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetNamespace\");\n\n\tif (xmlXPathRegisterNs(xtCxt->xpathcxt,\n\t\t\t\t\t\t   pg_xmlCharStrndup(name, strlen(name)),\n\t\t\t\t\t\t   pg_xmlCharStrndup(uri, strlen(uri))))\n\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_DATA_EXCEPTION,\n\t\t\t\t\t\"could not set XML namespace\");\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableSetDocument",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4351-4402",
    "snippet": "static void\nXmlTableSetDocument(TableFuncScanState *state, Datum value)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmltype    *xmlval = DatumGetXmlP(value);\n\tchar\t   *str;\n\txmlChar    *xstr;\n\tint\t\t\tlength;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathcxt = NULL;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetDocument\");\n\n\t/*\n\t * Use out function for casting to string (remove encoding property). See\n\t * comment in xml_out.\n\t */\n\tstr = xml_out_internal(xmlval, 0);\n\n\tlength = strlen(str);\n\txstr = pg_xmlCharStrndup(str, length);\n\n\tPG_TRY();\n\t{\n\t\tdoc = xmlCtxtReadMemory(xtCxt->ctxt, (char *) xstr, length, NULL, NULL, 0);\n\t\tif (doc == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathcxt = xmlXPathNewContext(doc);\n\t\tif (xpathcxt == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathcxt->node = (xmlNodePtr) doc;\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathcxt != NULL)\n\t\t\txmlXPathFreeContext(xpathcxt);\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txtCxt->doc = doc;\n\txtCxt->xpathcxt = xpathcxt;\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xpathcxt"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xtCxt->xmlerrcxt",
            "ERROR",
            "ERRCODE_OUT_OF_MEMORY",
            "\"could not allocate XPath context\""
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathNewContext",
          "args": [
            "doc"
          ],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlCtxtReadMemory",
          "args": [
            "xtCxt->ctxt",
            "(char *) xstr",
            "length",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xmlCharStrndup",
          "args": [
            "str",
            "length"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xmlCharStrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1167-1177",
          "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_out_internal",
          "args": [
            "xmlval",
            "0"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "xml_out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "291-331",
          "snippet": "static char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetXmlTableBuilderPrivateData",
          "args": [
            "state",
            "\"XmlTableSetDocument\""
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "GetXmlTableBuilderPrivateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4277-4289",
          "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetXmlP",
          "args": [
            "value"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableSetDocument(TableFuncScanState *state, Datum value)\n{\n#ifdef USE_LIBXML\n\tXmlTableBuilderData *xtCxt;\n\txmltype    *xmlval = DatumGetXmlP(value);\n\tchar\t   *str;\n\txmlChar    *xstr;\n\tint\t\t\tlength;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathcxt = NULL;\n\n\txtCxt = GetXmlTableBuilderPrivateData(state, \"XmlTableSetDocument\");\n\n\t/*\n\t * Use out function for casting to string (remove encoding property). See\n\t * comment in xml_out.\n\t */\n\tstr = xml_out_internal(xmlval, 0);\n\n\tlength = strlen(str);\n\txstr = pg_xmlCharStrndup(str, length);\n\n\tPG_TRY();\n\t{\n\t\tdoc = xmlCtxtReadMemory(xtCxt->ctxt, (char *) xstr, length, NULL, NULL, 0);\n\t\tif (doc == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathcxt = xmlXPathNewContext(doc);\n\t\tif (xpathcxt == NULL || xtCxt->xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xtCxt->xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathcxt->node = (xmlNodePtr) doc;\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathcxt != NULL)\n\t\t\txmlXPathFreeContext(xpathcxt);\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txtCxt->doc = doc;\n\txtCxt->xpathcxt = xpathcxt;\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "XmlTableInitOpaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4303-4345",
    "snippet": "static void\nXmlTableInitOpaque(TableFuncScanState *state, int natts)\n{\n#ifdef USE_LIBXML\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tXmlTableBuilderData *xtCxt;\n\tPgXmlErrorContext *xmlerrcxt;\n\n\txtCxt = palloc0(sizeof(XmlTableBuilderData));\n\txtCxt->magic = XMLTABLE_CONTEXT_MAGIC;\n\txtCxt->natts = natts;\n\txtCxt->xpathscomp = palloc0(sizeof(xmlXPathCompExprPtr) * natts);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txtCxt->xmlerrcxt = xmlerrcxt;\n\txtCxt->ctxt = ctxt;\n\n\tstate->opaque = xtCxt;\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
    ],
    "globals_used": [
      "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);",
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xmlerrcxt",
            "true"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "ctxt"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_OUT_OF_MEMORY",
            "\"could not allocate parser context\""
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewParserCtxt",
          "args": [],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlInitParser",
          "args": [],
          "line": 4320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init",
          "args": [
            "PG_XML_STRICTNESS_ALL"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "991-1060",
          "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(xmlXPathCompExprPtr) * natts"
          ],
          "line": 4314
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nXmlTableInitOpaque(TableFuncScanState *state, int natts)\n{\n#ifdef USE_LIBXML\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tXmlTableBuilderData *xtCxt;\n\tPgXmlErrorContext *xmlerrcxt;\n\n\txtCxt = palloc0(sizeof(XmlTableBuilderData));\n\txtCxt->magic = XMLTABLE_CONTEXT_MAGIC;\n\txtCxt->natts = natts;\n\txtCxt->xpathscomp = palloc0(sizeof(xmlXPathCompExprPtr) * natts);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txtCxt->xmlerrcxt = xmlerrcxt;\n\txtCxt->ctxt = ctxt;\n\n\tstate->opaque = xtCxt;\n#else\n\tNO_XML_SUPPORT();\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "GetXmlTableBuilderPrivateData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4277-4289",
    "snippet": "static inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define XMLTABLE_CONTEXT_MAGIC\t46922182"
    ],
    "globals_used": [
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"%s called with invalid TableFuncScanState\"",
            "fname"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "state",
            "TableFuncScanState"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XMLTABLE_CONTEXT_MAGIC\t46922182\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic inline XmlTableBuilderData *\nGetXmlTableBuilderPrivateData(TableFuncScanState *state, const char *fname)\n{\n\tXmlTableBuilderData *result;\n\n\tif (!IsA(state, TableFuncScanState))\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\tresult = (XmlTableBuilderData *) state->opaque;\n\tif (result->magic != XMLTABLE_CONTEXT_MAGIC)\n\t\telog(ERROR, \"%s called with invalid TableFuncScanState\", fname);\n\n\treturn result;\n}"
  },
  {
    "function_name": "xml_is_well_formed_content",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4254-4265",
    "snippet": "Datum\nxml_is_well_formed_content(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, XMLOPTION_CONTENT));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "wellformed_xml(data, XMLOPTION_CONTENT)"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wellformed_xml",
          "args": [
            "data",
            "XMLOPTION_CONTENT"
          ],
          "line": 4260
        },
        "resolved": true,
        "details": {
          "function_name": "wellformed_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4202-4225",
          "snippet": "static bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxml_is_well_formed_content(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, XMLOPTION_CONTENT));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "xml_is_well_formed_document",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4241-4252",
    "snippet": "Datum\nxml_is_well_formed_document(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, XMLOPTION_DOCUMENT));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "wellformed_xml(data, XMLOPTION_DOCUMENT)"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wellformed_xml",
          "args": [
            "data",
            "XMLOPTION_DOCUMENT"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "wellformed_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4202-4225",
          "snippet": "static bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxml_is_well_formed_document(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, XMLOPTION_DOCUMENT));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "xml_is_well_formed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4228-4239",
    "snippet": "Datum\nxml_is_well_formed(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, xmloption));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmloption;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "wellformed_xml(data, xmloption)"
          ],
          "line": 4234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wellformed_xml",
          "args": [
            "data",
            "xmloption"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "wellformed_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "4202-4225",
          "snippet": "static bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmloption;\n\nDatum\nxml_is_well_formed(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_BOOL(wellformed_xml(data, xmloption));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "wellformed_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4202-4225",
    "snippet": "static bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FlushErrorState",
          "args": [],
          "line": 4216
        },
        "resolved": true,
        "details": {
          "function_name": "FlushErrorState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1584-1597",
          "snippet": "void\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\n\nvoid\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parse",
          "args": [
            "data",
            "xmloption_arg",
            "true",
            "GetDatabaseEncoding()"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "xml_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1483-1600",
          "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nwellformed_xml(text *data, XmlOptionType xmloption_arg)\n{\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\n\t/* We want to catch any exceptions and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse(data, xmloption_arg, true, GetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tFlushErrorState();\n\t\tresult = false;\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n}"
  },
  {
    "function_name": "xpath_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4178-4195",
    "snippet": "Datum\nxpath_exists(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tArrayType  *namespaces = PG_GETARG_ARRAYTYPE_P(2);\n\tint\t\t\tres_nitems;\n\n\txpath_internal(xpath_expr_text, data, namespaces,\n\t\t\t\t   &res_nitems, NULL);\n\n\tPG_RETURN_BOOL(res_nitems > 0);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res_nitems > 0"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpath_internal",
          "args": [
            "xpath_expr_text",
            "data",
            "namespaces",
            "&res_nitems",
            "NULL"
          ],
          "line": 4187
        },
        "resolved": true,
        "details": {
          "function_name": "xpath_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3941-4122",
          "snippet": "static void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "2"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "1"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxpath_exists(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tArrayType  *namespaces = PG_GETARG_ARRAYTYPE_P(2);\n\tint\t\t\tres_nitems;\n\n\txpath_internal(xpath_expr_text, data, namespaces,\n\t\t\t\t   &res_nitems, NULL);\n\n\tPG_RETURN_BOOL(res_nitems > 0);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xmlexists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4155-4171",
    "snippet": "Datum\nxmlexists(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tint\t\t\tres_nitems;\n\n\txpath_internal(xpath_expr_text, data, NULL,\n\t\t\t\t   &res_nitems, NULL);\n\n\tPG_RETURN_BOOL(res_nitems > 0);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res_nitems > 0"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpath_internal",
          "args": [
            "xpath_expr_text",
            "data",
            "NULL",
            "&res_nitems",
            "NULL"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "xpath_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3941-4122",
          "snippet": "static void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "1"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxmlexists(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tint\t\t\tres_nitems;\n\n\txpath_internal(xpath_expr_text, data, NULL,\n\t\t\t\t   &res_nitems, NULL);\n\n\tPG_RETURN_BOOL(res_nitems > 0);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "4132-4149",
    "snippet": "Datum\nxpath(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tArrayType  *namespaces = PG_GETARG_ARRAYTYPE_P(2);\n\tArrayBuildState *astate;\n\n\tastate = initArrayResult(XMLOID, CurrentMemoryContext, true);\n\txpath_internal(xpath_expr_text, data, namespaces,\n\t\t\t\t   NULL, astate);\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate, CurrentMemoryContext));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "makeArrayResult(astate, CurrentMemoryContext)"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResult",
          "args": [
            "astate",
            "CurrentMemoryContext"
          ],
          "line": 4144
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5117-5132",
          "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xpath_internal",
          "args": [
            "xpath_expr_text",
            "data",
            "namespaces",
            "NULL",
            "astate"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "xpath_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3941-4122",
          "snippet": "static void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "XMLOID",
            "CurrentMemoryContext",
            "true"
          ],
          "line": 4141
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "2"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "1"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxpath(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *xpath_expr_text = PG_GETARG_TEXT_PP(0);\n\txmltype    *data = PG_GETARG_XML_P(1);\n\tArrayType  *namespaces = PG_GETARG_ARRAYTYPE_P(2);\n\tArrayBuildState *astate;\n\n\tastate = initArrayResult(XMLOID, CurrentMemoryContext, true);\n\txpath_internal(xpath_expr_text, data, namespaces,\n\t\t\t\t   NULL, astate);\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate, CurrentMemoryContext));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xpath_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3941-4122",
    "snippet": "static void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xmlerrcxt",
            "false"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "ctxt"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xpathctx"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeCompExpr",
          "args": [
            "xpathcomp"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeObject",
          "args": [
            "xpathobj"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "ctxt"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xpathctx"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeCompExpr",
          "args": [
            "xpathcomp"
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeObject",
          "args": [
            "xpathobj"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_xpathobjtoxmlarray",
          "args": [
            "xpathobj",
            "astate",
            "xmlerrcxt"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "xml_xpathobjtoxmlarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3863-3927",
          "snippet": "static int\nxml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,\n\t\t\t\t\t   ArrayBuildState *astate,\n\t\t\t\t\t   PgXmlErrorContext *xmlerrcxt)\n{\n\tint\t\t\tresult = 0;\n\tDatum\t\tdatum;\n\tOid\t\t\tdatumtype;\n\tchar\t   *result_str;\n\n\tswitch (xpathobj->type)\n\t{\n\t\tcase XPATH_NODESET:\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t{\n\t\t\t\tresult = xpathobj->nodesetval->nodeNr;\n\t\t\t\tif (astate != NULL)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ti;\n\n\t\t\t\t\tfor (i = 0; i < result; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdatum = PointerGetDatum(xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlerrcxt));\n\t\t\t\t\t\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\tcase XPATH_BOOLEAN:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = BoolGetDatum(xpathobj->boolval);\n\t\t\tdatumtype = BOOLOID;\n\t\t\tbreak;\n\n\t\tcase XPATH_NUMBER:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = Float8GetDatum(xpathobj->floatval);\n\t\t\tdatumtype = FLOAT8OID;\n\t\t\tbreak;\n\n\t\tcase XPATH_STRING:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = CStringGetDatum((char *) xpathobj->stringval);\n\t\t\tdatumtype = CSTRINGOID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"xpath expression result type %d is unsupported\",\n\t\t\t\t xpathobj->type);\n\t\t\treturn 0;\t\t\t/* keep compiler quiet */\n\t}\n\n\t/* Common code for scalar-value cases */\n\tresult_str = map_sql_value_to_xml_value(datum, datumtype, true);\n\tdatum = PointerGetDatum(cstring_to_xmltype(result_str));\n\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\treturn 1;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nxml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,\n\t\t\t\t\t   ArrayBuildState *astate,\n\t\t\t\t\t   PgXmlErrorContext *xmlerrcxt)\n{\n\tint\t\t\tresult = 0;\n\tDatum\t\tdatum;\n\tOid\t\t\tdatumtype;\n\tchar\t   *result_str;\n\n\tswitch (xpathobj->type)\n\t{\n\t\tcase XPATH_NODESET:\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t{\n\t\t\t\tresult = xpathobj->nodesetval->nodeNr;\n\t\t\t\tif (astate != NULL)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ti;\n\n\t\t\t\t\tfor (i = 0; i < result; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdatum = PointerGetDatum(xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlerrcxt));\n\t\t\t\t\t\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\tcase XPATH_BOOLEAN:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = BoolGetDatum(xpathobj->boolval);\n\t\t\tdatumtype = BOOLOID;\n\t\t\tbreak;\n\n\t\tcase XPATH_NUMBER:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = Float8GetDatum(xpathobj->floatval);\n\t\t\tdatumtype = FLOAT8OID;\n\t\t\tbreak;\n\n\t\tcase XPATH_STRING:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = CStringGetDatum((char *) xpathobj->stringval);\n\t\t\tdatumtype = CSTRINGOID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"xpath expression result type %d is unsupported\",\n\t\t\t\t xpathobj->type);\n\t\t\treturn 0;\t\t\t/* keep compiler quiet */\n\t}\n\n\t/* Common code for scalar-value cases */\n\tresult_str = map_sql_value_to_xml_value(datum, datumtype, true);\n\tdatum = PointerGetDatum(cstring_to_xmltype(result_str));\n\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_INTERNAL_ERROR",
            "\"could not create XPath object\""
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathCompiledEval",
          "args": [
            "xpathcomp",
            "xpathctx"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathCompile",
          "args": [
            "xpath_expr"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "/* is this an internal error??? */(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri))"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\"",
            "ns_name",
            "ns_uri"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathRegisterNs",
          "args": [
            "xpathctx",
            "(xmlChar *) ns_name",
            "(xmlChar *) ns_uri"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "ns_names_uris[i * 2 + 1]"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "ns_names_uris[i * 2]"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\"))"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlXPathNewContext",
          "args": [
            "doc"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlCtxtReadMemory",
          "args": [
            "ctxt",
            "(char *) string + xmldecl_len",
            "len - xmldecl_len",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewParserCtxt",
          "args": [],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlInitParser",
          "args": [],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init",
          "args": [
            "PG_XML_STRICTNESS_ALL"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "991-1060",
          "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "string",
            "&xmldecl_len",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_xmlCharStrndup",
          "args": [
            "VARDATA_ANY(xpath_expr_text)",
            "xpath_len"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xmlCharStrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1167-1177",
          "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "xpath_expr_text"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\"))"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "xpath_expr_text"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "data"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "data"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(ns_count % 2) == 0"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "namespaces",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&ns_names_uris",
            "&ns_names_uris_nulls",
            "&ns_count"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ARR_ELEMTYPE(namespaces) == TEXTOID"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "namespaces"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\"))"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The array must be two-dimensional with length of the second axis equal to 2.\""
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "namespaces"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "namespaces"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxpath_internal(text *xpath_expr_text, xmltype *data, ArrayType *namespaces,\n\t\t\t   int *res_nitems, ArrayBuildState *astate)\n{\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\tvolatile xmlXPathContextPtr xpathctx = NULL;\n\tvolatile xmlXPathCompExprPtr xpathcomp = NULL;\n\tvolatile xmlXPathObjectPtr xpathobj = NULL;\n\tchar\t   *datastr;\n\tint32\t\tlen;\n\tint32\t\txpath_len;\n\txmlChar    *string;\n\txmlChar    *xpath_expr;\n\tsize_t\t\txmldecl_len = 0;\n\tint\t\t\ti;\n\tint\t\t\tndim;\n\tDatum\t   *ns_names_uris;\n\tbool\t   *ns_names_uris_nulls;\n\tint\t\t\tns_count;\n\n\t/*\n\t * Namespace mappings are passed as text[].  If an empty array is passed\n\t * (ndim = 0, \"0-dimensional\"), then there are no namespace mappings.\n\t * Else, a 2-dimensional array with length of the second axis being equal\n\t * to 2 should be passed, i.e., every subarray contains 2 elements, the\n\t * first element defining the name, the second one the URI.  Example:\n\t * ARRAY[ARRAY['myns', 'http://example.com'], ARRAY['myns2',\n\t * 'http://example2.com']].\n\t */\n\tndim = namespaces ? ARR_NDIM(namespaces) : 0;\n\tif (ndim != 0)\n\t{\n\t\tint\t\t   *dims;\n\n\t\tdims = ARR_DIMS(namespaces);\n\n\t\tif (ndim != 2 || dims[1] != 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"invalid array for XML namespace mapping\"),\n\t\t\t\t\t errdetail(\"The array must be two-dimensional with length of the second axis equal to 2.\")));\n\n\t\tAssert(ARR_ELEMTYPE(namespaces) == TEXTOID);\n\n\t\tdeconstruct_array(namespaces, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &ns_names_uris, &ns_names_uris_nulls,\n\t\t\t\t\t\t  &ns_count);\n\n\t\tAssert((ns_count % 2) == 0);\t/* checked above */\n\t\tns_count /= 2;\t\t\t/* count pairs only */\n\t}\n\telse\n\t{\n\t\tns_names_uris = NULL;\n\t\tns_names_uris_nulls = NULL;\n\t\tns_count = 0;\n\t}\n\n\tdatastr = VARDATA(data);\n\tlen = VARSIZE(data) - VARHDRSZ;\n\txpath_len = VARSIZE_ANY_EXHDR(xpath_expr_text);\n\tif (xpath_len == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"empty XPath expression\")));\n\n\tstring = pg_xmlCharStrndup(datastr, len);\n\txpath_expr = pg_xmlCharStrndup(VARDATA_ANY(xpath_expr_text), xpath_len);\n\n\t/*\n\t * In a UTF8 database, skip any xml declaration, which might assert\n\t * another encoding.  Ignore parse_xml_decl() failure, letting\n\t * xmlCtxtReadMemory() report parse errors.  Documentation disclaims\n\t * xpath() support for non-ASCII data in non-UTF8 databases, so leave\n\t * those scenarios bug-compatible with historical behavior.\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\tparse_xml_decl(string, &xmldecl_len, NULL, NULL, NULL);\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\txmlInitParser();\n\n\t\t/*\n\t\t * redundant XML parsing (two parsings for the same value during one\n\t\t * command execution are possible)\n\t\t */\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\t\tdoc = xmlCtxtReadMemory(ctxt, (char *) string + xmldecl_len,\n\t\t\t\t\t\t\t\tlen - xmldecl_len, NULL, NULL, 0);\n\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\"could not parse XML document\");\n\t\txpathctx = xmlXPathNewContext(doc);\n\t\tif (xpathctx == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate XPath context\");\n\t\txpathctx->node = (xmlNodePtr) doc;\n\n\t\t/* register namespaces, if any */\n\t\tif (ns_count > 0)\n\t\t{\n\t\t\tfor (i = 0; i < ns_count; i++)\n\t\t\t{\n\t\t\t\tchar\t   *ns_name;\n\t\t\t\tchar\t   *ns_uri;\n\n\t\t\t\tif (ns_names_uris_nulls[i * 2] ||\n\t\t\t\t\tns_names_uris_nulls[i * 2 + 1])\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t\t errmsg(\"neither namespace name nor URI may be null\")));\n\t\t\t\tns_name = TextDatumGetCString(ns_names_uris[i * 2]);\n\t\t\t\tns_uri = TextDatumGetCString(ns_names_uris[i * 2 + 1]);\n\t\t\t\tif (xmlXPathRegisterNs(xpathctx,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_name,\n\t\t\t\t\t\t\t\t\t   (xmlChar *) ns_uri) != 0)\n\t\t\t\t\tereport(ERROR,\t/* is this an internal error??? */\n\t\t\t\t\t\t\t(errmsg(\"could not register XML namespace with name \\\"%s\\\" and URI \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tns_name, ns_uri)));\n\t\t\t}\n\t\t}\n\n\t\txpathcomp = xmlXPathCompile(xpath_expr);\n\t\tif (xpathcomp == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"invalid XPath expression\");\n\n\t\t/*\n\t\t * Version 2.6.27 introduces a function named\n\t\t * xmlXPathCompiledEvalToBoolean, which would be enough for xmlexists,\n\t\t * but we can derive the existence by whether any nodes are returned,\n\t\t * thereby preventing a library version upgrade and keeping the code\n\t\t * the same.\n\t\t */\n\t\txpathobj = xmlXPathCompiledEval(xpathcomp, xpathctx);\n\t\tif (xpathobj == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not create XPath object\");\n\n\t\t/*\n\t\t * Extract the results as requested.\n\t\t */\n\t\tif (res_nitems != NULL)\n\t\t\t*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t\telse\n\t\t\t(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (xpathobj)\n\t\t\txmlXPathFreeObject(xpathobj);\n\t\tif (xpathcomp)\n\t\t\txmlXPathFreeCompExpr(xpathcomp);\n\t\tif (xpathctx)\n\t\t\txmlXPathFreeContext(xpathctx);\n\t\tif (doc)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlXPathFreeObject(xpathobj);\n\txmlXPathFreeCompExpr(xpathcomp);\n\txmlXPathFreeContext(xpathctx);\n\txmlFreeDoc(doc);\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n}"
  },
  {
    "function_name": "xml_xpathobjtoxmlarray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3863-3927",
    "snippet": "static int\nxml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,\n\t\t\t\t\t   ArrayBuildState *astate,\n\t\t\t\t\t   PgXmlErrorContext *xmlerrcxt)\n{\n\tint\t\t\tresult = 0;\n\tDatum\t\tdatum;\n\tOid\t\t\tdatumtype;\n\tchar\t   *result_str;\n\n\tswitch (xpathobj->type)\n\t{\n\t\tcase XPATH_NODESET:\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t{\n\t\t\t\tresult = xpathobj->nodesetval->nodeNr;\n\t\t\t\tif (astate != NULL)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ti;\n\n\t\t\t\t\tfor (i = 0; i < result; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdatum = PointerGetDatum(xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlerrcxt));\n\t\t\t\t\t\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\tcase XPATH_BOOLEAN:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = BoolGetDatum(xpathobj->boolval);\n\t\t\tdatumtype = BOOLOID;\n\t\t\tbreak;\n\n\t\tcase XPATH_NUMBER:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = Float8GetDatum(xpathobj->floatval);\n\t\t\tdatumtype = FLOAT8OID;\n\t\t\tbreak;\n\n\t\tcase XPATH_STRING:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = CStringGetDatum((char *) xpathobj->stringval);\n\t\t\tdatumtype = CSTRINGOID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"xpath expression result type %d is unsupported\",\n\t\t\t\t xpathobj->type);\n\t\t\treturn 0;\t\t\t/* keep compiler quiet */\n\t}\n\n\t/* Common code for scalar-value cases */\n\tresult_str = map_sql_value_to_xml_value(datum, datumtype, true);\n\tdatum = PointerGetDatum(cstring_to_xmltype(result_str));\n\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\treturn 1;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate",
            "datum",
            "false",
            "XMLOID",
            "CurrentMemoryContext"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_xmltype(result_str)"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_xmltype",
          "args": [
            "result_str"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "452-456",
          "snippet": "static xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_value_to_xml_value",
          "args": [
            "datum",
            "datumtype",
            "true"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_value_to_xml_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2120-2329",
          "snippet": "char *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\txmlbinary;",
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nchar *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"xpath expression result type %d is unsupported\"",
            "xpathobj->type"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "(char *) xpathobj->stringval"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatum",
          "args": [
            "xpathobj->floatval"
          ],
          "line": 3904
        },
        "resolved": true,
        "details": {
          "function_name": "Float8GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1900-1907",
          "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "xpathobj->boolval"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlerrcxt)"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_xmlnodetoxmltype",
          "args": [
            "xpathobj->nodesetval->nodeTab[i]",
            "xmlerrcxt"
          ],
          "line": 3885
        },
        "resolved": true,
        "details": {
          "function_name": "xml_xmlnodetoxmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3788-3849",
          "snippet": "static text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nxml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,\n\t\t\t\t\t   ArrayBuildState *astate,\n\t\t\t\t\t   PgXmlErrorContext *xmlerrcxt)\n{\n\tint\t\t\tresult = 0;\n\tDatum\t\tdatum;\n\tOid\t\t\tdatumtype;\n\tchar\t   *result_str;\n\n\tswitch (xpathobj->type)\n\t{\n\t\tcase XPATH_NODESET:\n\t\t\tif (xpathobj->nodesetval != NULL)\n\t\t\t{\n\t\t\t\tresult = xpathobj->nodesetval->nodeNr;\n\t\t\t\tif (astate != NULL)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ti;\n\n\t\t\t\t\tfor (i = 0; i < result; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdatum = PointerGetDatum(xml_xmlnodetoxmltype(xpathobj->nodesetval->nodeTab[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlerrcxt));\n\t\t\t\t\t\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\n\t\tcase XPATH_BOOLEAN:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = BoolGetDatum(xpathobj->boolval);\n\t\t\tdatumtype = BOOLOID;\n\t\t\tbreak;\n\n\t\tcase XPATH_NUMBER:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = Float8GetDatum(xpathobj->floatval);\n\t\t\tdatumtype = FLOAT8OID;\n\t\t\tbreak;\n\n\t\tcase XPATH_STRING:\n\t\t\tif (astate == NULL)\n\t\t\t\treturn 1;\n\t\t\tdatum = CStringGetDatum((char *) xpathobj->stringval);\n\t\t\tdatumtype = CSTRINGOID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"xpath expression result type %d is unsupported\",\n\t\t\t\t xpathobj->type);\n\t\t\treturn 0;\t\t\t/* keep compiler quiet */\n\t}\n\n\t/* Common code for scalar-value cases */\n\tresult_str = map_sql_value_to_xml_value(datum, datumtype, true);\n\tdatum = PointerGetDatum(cstring_to_xmltype(result_str));\n\t(void) accumArrayResult(astate, datum, false,\n\t\t\t\t\t\t\tXMLOID, CurrentMemoryContext);\n\treturn 1;\n}"
  },
  {
    "function_name": "xml_xmlnodetoxmltype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3788-3849",
    "snippet": "static text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFree",
          "args": [
            "str"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFree",
          "args": [
            "str"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "escaped"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "escaped"
          ],
          "line": 3836
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "escape_xml",
          "args": [
            "(char *) str"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "escape_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2339-2368",
          "snippet": "char *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathCastNodeToString",
          "args": [
            "cur"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "cur_copy"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeNode",
          "args": [
            "cur_copy"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBuffer_to_xmltype",
          "args": [
            "buf"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "xmlBuffer_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "460-465",
          "snippet": "static xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNodeDump",
          "args": [
            "buf",
            "NULL",
            "cur_copy",
            "0",
            "1"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 3811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_OUT_OF_MEMORY",
            "\"could not copy node\""
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlCopyNode",
          "args": [
            "cur",
            "1"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferCreate",
          "args": [],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic text *\nxml_xmlnodetoxmltype(xmlNodePtr cur, PgXmlErrorContext *xmlerrcxt)\n{\n\txmltype    *result;\n\n\tif (cur->type == XML_ELEMENT_NODE)\n\t{\n\t\txmlBufferPtr buf;\n\t\txmlNodePtr\tcur_copy;\n\n\t\tbuf = xmlBufferCreate();\n\n\t\t/*\n\t\t * The result of xmlNodeDump() won't contain namespace definitions\n\t\t * from parent nodes, but xmlCopyNode() duplicates a node along with\n\t\t * its required namespace definitions.\n\t\t */\n\t\tcur_copy = xmlCopyNode(cur, 1);\n\n\t\tif (cur_copy == NULL)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not copy node\");\n\n\t\tPG_TRY();\n\t\t{\n\t\t\txmlNodeDump(buf, NULL, cur_copy, 0, 1);\n\t\t\tresult = xmlBuffer_to_xmltype(buf);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFreeNode(cur_copy);\n\t\t\txmlBufferFree(buf);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFreeNode(cur_copy);\n\t\txmlBufferFree(buf);\n\t}\n\telse\n\t{\n\t\txmlChar    *str;\n\n\t\tstr = xmlXPathCastNodeToString(cur);\n\t\tPG_TRY();\n\t\t{\n\t\t\t/* Here we rely on XML having the same representation as TEXT */\n\t\t\tchar\t   *escaped = escape_xml((char *) str);\n\n\t\t\tresult = (xmltype *) cstring_to_text(escaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t\tPG_CATCH();\n\t\t{\n\t\t\txmlFree(str);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t\tPG_END_TRY();\n\t\txmlFree(str);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "SPI_sql_row_to_xmlelement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3720-3775",
    "snippet": "static void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
      "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);",
      "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);",
      "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"</row>\\n\\n\""
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_end",
          "args": [
            "result",
            "xmltn"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2632-2636",
          "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"  <%s>%s</%s>\\n\"",
            "colname",
            "map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true)",
            "colname"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_value_to_xml_value",
          "args": [
            "colval",
            "SPI_gettypeid(SPI_tuptable->tupdesc, i)",
            "true"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_value_to_xml_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2120-2329",
          "snippet": "char *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\txmlbinary;",
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nchar *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "SPI_tuptable->tupdesc",
            "i"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"  <%s xsi:nil=\\\"true\\\"/>\\n\"",
            "colname"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "SPI_tuptable->vals[rownum]",
            "SPI_tuptable->tupdesc",
            "i",
            "&isnull"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "SPI_fname(SPI_tuptable->tupdesc, i)",
            "true",
            "false"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_fname",
          "args": [
            "SPI_tuptable->tupdesc",
            "i"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"<row>\\n\""
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_start",
          "args": [
            "result",
            "xmltn",
            "NULL",
            "targetns",
            "top_level"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2605-2629",
          "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
          ],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}"
  },
  {
    "function_name": "map_sql_type_to_xmlschema_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3545-3713",
    "snippet": "static const char *\nmap_sql_type_to_xmlschema_type(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\tconst char *typename = map_sql_type_to_xml_name(typeoid, typmod);\n\n\tinitStringInfo(&result);\n\n\tif (typeoid == XMLOID)\n\t{\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"<xsd:complexType mixed=\\\"true\\\">\\n\"\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"    <xsd:any name=\\\"element\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\" processContents=\\\"skip\\\"/>\\n\"\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"</xsd:complexType>\\n\");\n\t}\n\telse\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:simpleType name=\\\"%s\\\">\\n\", typename);\n\n\t\tswitch (typeoid)\n\t\t{\n\t\t\tcase BPCHAROID:\n\t\t\tcase VARCHAROID:\n\t\t\tcase TEXTOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:string\\\">\\n\");\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"    <xsd:maxLength value=\\\"%d\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t typmod - VARHDRSZ);\n\t\t\t\tappendStringInfoString(&result, \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BYTEAOID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:%s\\\">\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t xmlbinary == XMLBINARY_BASE64 ? \"base64Binary\" : \"hexBinary\");\n\t\t\t\tbreak;\n\n\t\t\tcase NUMERICOID:\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:decimal\\\">\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:totalDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:fractionDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\t\tbreak;\n\n\t\t\tcase INT2OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:short\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t SHRT_MAX, SHRT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT4OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:int\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t INT_MAX, INT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT8OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:long\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)) - 1,\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)));\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT4OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:float\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT8OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:double\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BOOLOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:boolean\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase TIMEOID:\n\t\t\tcase TIMETZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMETZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMESTAMPTZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase DATEOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:date\\\">\\n\"\n\t\t\t\t\t\t\t\t\t   \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t   \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (get_typtype(typeoid) == TYPTYPE_DOMAIN)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tbase_typeoid;\n\t\t\t\t\tint32\t\tbase_typmod = -1;\n\n\t\t\t\t\tbase_typeoid = getBaseTypeAndTypmod(typeoid, &base_typmod);\n\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t map_sql_type_to_xml_name(base_typeoid, base_typmod));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tappendStringInfoString(&result, \"</xsd:simpleType>\\n\");\n\t}\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmlbinary;",
      "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
      "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);",
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"</xsd:simpleType>\\n\""
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"%s\\\"/>\\n\"",
            "map_sql_type_to_xml_name(base_typeoid, base_typmod)"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_type_to_xml_name",
          "args": [
            "base_typeoid",
            "base_typmod"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_type_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3385-3483",
          "snippet": "static const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
            "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\n\nstatic const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseTypeAndTypmod",
          "args": [
            "typeoid",
            "&base_typmod"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseTypeAndTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2315-2345",
          "snippet": "Oid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typtype",
          "args": [
            "typeoid"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "get_typtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2406-2423",
          "snippet": "char\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:date\\\">\\n\"\n\t\t\t\t\t\t\t\t\t   \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t   \"  </xsd:restriction>\\n\""
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "typmod - VARHDRSZ",
            "tz"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "tz"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "tz"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "typmod - VARHDRSZ",
            "tz"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "tz"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "tz"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:boolean\\\"></xsd:restriction>\\n\""
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:double\\\"></xsd:restriction>\\n\""
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:float\\\"></xsd:restriction>\\n\""
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:long\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "(((uint64) 1) << (sizeof(int64) * 8 - 1)) - 1",
            "(((uint64) 1) << (sizeof(int64) * 8 - 1))"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:int\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "INT_MAX",
            "INT_MIN"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:short\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "SHRT_MAX",
            "SHRT_MIN"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:decimal\\\">\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:totalDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:fractionDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "((typmod - VARHDRSZ) >> 16) & 0xffff",
            "(typmod - VARHDRSZ) & 0xffff"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:%s\\\">\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\"",
            "xmlbinary == XMLBINARY_BASE64 ? \"base64Binary\" : \"hexBinary\""
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  </xsd:restriction>\\n\""
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"    <xsd:maxLength value=\\\"%d\\\"/>\\n\"",
            "typmod - VARHDRSZ"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:restriction base=\\\"xsd:string\\\">\\n\""
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:simpleType name=\\\"%s\\\">\\n\"",
            "typename"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"<xsd:complexType mixed=\\\"true\\\">\\n\"\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"    <xsd:any name=\\\"element\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\" processContents=\\\"skip\\\"/>\\n\"\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"</xsd:complexType>\\n\""
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic const char *\nmap_sql_type_to_xmlschema_type(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\tconst char *typename = map_sql_type_to_xml_name(typeoid, typmod);\n\n\tinitStringInfo(&result);\n\n\tif (typeoid == XMLOID)\n\t{\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"<xsd:complexType mixed=\\\"true\\\">\\n\"\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"    <xsd:any name=\\\"element\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\" processContents=\\\"skip\\\"/>\\n\"\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"</xsd:complexType>\\n\");\n\t}\n\telse\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:simpleType name=\\\"%s\\\">\\n\", typename);\n\n\t\tswitch (typeoid)\n\t\t{\n\t\t\tcase BPCHAROID:\n\t\t\tcase VARCHAROID:\n\t\t\tcase TEXTOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:string\\\">\\n\");\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"    <xsd:maxLength value=\\\"%d\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t typmod - VARHDRSZ);\n\t\t\t\tappendStringInfoString(&result, \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BYTEAOID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:%s\\\">\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t xmlbinary == XMLBINARY_BASE64 ? \"base64Binary\" : \"hexBinary\");\n\t\t\t\tbreak;\n\n\t\t\tcase NUMERICOID:\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:decimal\\\">\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:totalDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:fractionDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\t\tbreak;\n\n\t\t\tcase INT2OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:short\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t SHRT_MAX, SHRT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT4OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:int\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t INT_MAX, INT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT8OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:long\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)) - 1,\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)));\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT4OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:float\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT8OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:double\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BOOLOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:boolean\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase TIMEOID:\n\t\t\tcase TIMETZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMETZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMESTAMPTZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase DATEOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:date\\\">\\n\"\n\t\t\t\t\t\t\t\t\t   \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t   \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (get_typtype(typeoid) == TYPTYPE_DOMAIN)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tbase_typeoid;\n\t\t\t\t\tint32\t\tbase_typmod = -1;\n\n\t\t\t\t\tbase_typeoid = getBaseTypeAndTypmod(typeoid, &base_typmod);\n\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t map_sql_type_to_xml_name(base_typeoid, base_typmod));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tappendStringInfoString(&result, \"</xsd:simpleType>\\n\");\n\t}\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_sql_typecoll_to_xmlschema_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3490-3534",
    "snippet": "static const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);",
      "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"%s\\n\"",
            "map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1)"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_type_to_xmlschema_type",
          "args": [
            "lfirst_oid(cell0)",
            "-1"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_type_to_xmlschema_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3545-3713",
          "snippet": "static const char *\nmap_sql_type_to_xmlschema_type(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\tconst char *typename = map_sql_type_to_xml_name(typeoid, typmod);\n\n\tinitStringInfo(&result);\n\n\tif (typeoid == XMLOID)\n\t{\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"<xsd:complexType mixed=\\\"true\\\">\\n\"\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"    <xsd:any name=\\\"element\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\" processContents=\\\"skip\\\"/>\\n\"\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"</xsd:complexType>\\n\");\n\t}\n\telse\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:simpleType name=\\\"%s\\\">\\n\", typename);\n\n\t\tswitch (typeoid)\n\t\t{\n\t\t\tcase BPCHAROID:\n\t\t\tcase VARCHAROID:\n\t\t\tcase TEXTOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:string\\\">\\n\");\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"    <xsd:maxLength value=\\\"%d\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t typmod - VARHDRSZ);\n\t\t\t\tappendStringInfoString(&result, \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BYTEAOID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:%s\\\">\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t xmlbinary == XMLBINARY_BASE64 ? \"base64Binary\" : \"hexBinary\");\n\t\t\t\tbreak;\n\n\t\t\tcase NUMERICOID:\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:decimal\\\">\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:totalDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:fractionDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\t\tbreak;\n\n\t\t\tcase INT2OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:short\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t SHRT_MAX, SHRT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT4OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:int\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t INT_MAX, INT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT8OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:long\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)) - 1,\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)));\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT4OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:float\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT8OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:double\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BOOLOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:boolean\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase TIMEOID:\n\t\t\tcase TIMETZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMETZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMESTAMPTZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase DATEOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:date\\\">\\n\"\n\t\t\t\t\t\t\t\t\t   \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t   \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (get_typtype(typeoid) == TYPTYPE_DOMAIN)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tbase_typeoid;\n\t\t\t\t\tint32\t\tbase_typmod = -1;\n\n\t\t\t\t\tbase_typeoid = getBaseTypeAndTypmod(typeoid, &base_typmod);\n\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t map_sql_type_to_xml_name(base_typeoid, base_typmod));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tappendStringInfoString(&result, \"</xsd:simpleType>\\n\");\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\txmlbinary;",
            "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
            "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);",
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic const char *\nmap_sql_type_to_xmlschema_type(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\tconst char *typename = map_sql_type_to_xml_name(typeoid, typmod);\n\n\tinitStringInfo(&result);\n\n\tif (typeoid == XMLOID)\n\t{\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"<xsd:complexType mixed=\\\"true\\\">\\n\"\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"    <xsd:any name=\\\"element\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\" processContents=\\\"skip\\\"/>\\n\"\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t\t   \"</xsd:complexType>\\n\");\n\t}\n\telse\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:simpleType name=\\\"%s\\\">\\n\", typename);\n\n\t\tswitch (typeoid)\n\t\t{\n\t\t\tcase BPCHAROID:\n\t\t\tcase VARCHAROID:\n\t\t\tcase TEXTOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:string\\\">\\n\");\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"    <xsd:maxLength value=\\\"%d\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t typmod - VARHDRSZ);\n\t\t\t\tappendStringInfoString(&result, \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BYTEAOID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:%s\\\">\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t xmlbinary == XMLBINARY_BASE64 ? \"base64Binary\" : \"hexBinary\");\n\t\t\t\tbreak;\n\n\t\t\tcase NUMERICOID:\n\t\t\t\tif (typmod != -1)\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:decimal\\\">\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:totalDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"    <xsd:fractionDigits value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\t\tbreak;\n\n\t\t\tcase INT2OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:short\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t SHRT_MAX, SHRT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT4OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:int\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"%d\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t INT_MAX, INT_MIN);\n\t\t\t\tbreak;\n\n\t\t\tcase INT8OID:\n\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:long\\\">\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:maxInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"    <xsd:minInclusive value=\\\"\" INT64_FORMAT \"\\\"/>\\n\"\n\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\",\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)) - 1,\n\t\t\t\t\t\t\t\t (((uint64) 1) << (sizeof(int64) * 8 - 1)));\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT4OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:float\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT8OID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:double\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase BOOLOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:boolean\\\"></xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase TIMEOID:\n\t\t\tcase TIMETZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMETZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:time\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tconst char *tz = (typeoid == TIMESTAMPTZOID ? \"(+|-)\\\\p{Nd}{2}:\\\\p{Nd}{2}\" : \"\");\n\n\t\t\t\t\tif (typmod == -1)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}(.\\\\p{Nd}+)?%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse if (typmod == 0)\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"xsd:dateTime\\\">\\n\"\n\t\t\t\t\t\t\t\t\t\t \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}T\\\\p{Nd}{2}:\\\\p{Nd}{2}:\\\\p{Nd}{2}.\\\\p{Nd}{%d}%s\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t\t \"  </xsd:restriction>\\n\", typmod - VARHDRSZ, tz);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase DATEOID:\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   \"  <xsd:restriction base=\\\"xsd:date\\\">\\n\"\n\t\t\t\t\t\t\t\t\t   \"    <xsd:pattern value=\\\"\\\\p{Nd}{4}-\\\\p{Nd}{2}-\\\\p{Nd}{2}\\\"/>\\n\"\n\t\t\t\t\t\t\t\t\t   \"  </xsd:restriction>\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (get_typtype(typeoid) == TYPTYPE_DOMAIN)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tbase_typeoid;\n\t\t\t\t\tint32\t\tbase_typmod = -1;\n\n\t\t\t\t\tbase_typeoid = getBaseTypeAndTypmod(typeoid, &base_typmod);\n\n\t\t\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t\t\t \"  <xsd:restriction base=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t\t\t map_sql_type_to_xml_name(base_typeoid, base_typmod));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tappendStringInfoString(&result, \"</xsd:simpleType>\\n\");\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell0"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell0",
            "uniquetypes"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_append_unique_oid",
          "args": [
            "uniquetypes",
            "basetypid"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "typid"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell0"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell0",
            "uniquetypes"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_append_unique_oid",
          "args": [
            "uniquetypes",
            "att->atttypid"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "cell0"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell0",
            "tupdesc_list"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_sql_type_to_xml_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3385-3483",
    "snippet": "static const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
      "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname))"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_multipart_sql_identifier_to_xml_name",
          "args": [
            "(typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\"",
            "get_database_name(MyDatabaseId)",
            "get_namespace_name(typtuple->typnamespace)",
            "NameStr(typtuple->typname)"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "map_multipart_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3119-3140",
          "snippet": "static char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typtuple->typname"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "typtuple->typnamespace"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for type %u\"",
            "typeoid"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(typeoid)"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typeoid"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"XML\""
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"DATE\""
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"TIMESTAMP_WTZ_%d\"",
            "typmod"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"TIMESTAMP_WTZ\""
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"TIMESTAMP_%d\"",
            "typmod"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"TIMESTAMP\""
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"TIME_WTZ_%d\"",
            "typmod"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"TIME_WTZ\""
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"TIME_%d\"",
            "typmod"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"TIME\""
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"BOOLEAN\""
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"DOUBLE\""
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"REAL\""
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"BIGINT\""
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"SMALLINT\""
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"INTEGER\""
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"NUMERIC_%d_%d\"",
            "((typmod - VARHDRSZ) >> 16) & 0xffff",
            "(typmod - VARHDRSZ) & 0xffff"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"NUMERIC\""
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"VARCHAR_%d\"",
            "typmod - VARHDRSZ"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"VARCHAR\""
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"CHAR_%d\"",
            "typmod - VARHDRSZ"
          ],
          "line": 3398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"CHAR\""
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\n\nstatic const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_sql_catalog_to_xmlschema_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3328-3379",
    "snippet": "static const char *\nmap_sql_catalog_to_xmlschema_types(List *nspid_list, bool nulls,\n\t\t\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *xmlcn;\n\tchar\t   *catalogtypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\n\tinitStringInfo(&result);\n\n\txmlcn = map_sql_identifier_to_xml_name(dbname, true, false);\n\n\tcatalogtypename = map_multipart_sql_identifier_to_xml_name(\"CatalogType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", catalogtypename);\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tchar\t   *nspname = get_namespace_name(nspid);\n\t\tchar\t   *xmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\t\tchar\t   *schematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t xmlsn, schematypename);\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlcn, catalogtypename);\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\"",
            "xmlcn",
            "catalogtypename"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"</xsd:complexType>\\n\\n\""
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  </xsd:all>\\n\""
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\"",
            "xmlsn",
            "schematypename"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_multipart_sql_identifier_to_xml_name",
          "args": [
            "\"SchemaType\"",
            "dbname",
            "nspname",
            "NULL"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "map_multipart_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3119-3140",
          "snippet": "static char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "nspname",
            "true",
            "false"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "nspid"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "nspid_list"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:all>\\n\""
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:complexType name=\\\"%s\\\">\\n\"",
            "catalogtypename"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic const char *\nmap_sql_catalog_to_xmlschema_types(List *nspid_list, bool nulls,\n\t\t\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *xmlcn;\n\tchar\t   *catalogtypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\n\tinitStringInfo(&result);\n\n\txmlcn = map_sql_identifier_to_xml_name(dbname, true, false);\n\n\tcatalogtypename = map_multipart_sql_identifier_to_xml_name(\"CatalogType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", catalogtypename);\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tchar\t   *nspname = get_namespace_name(nspid);\n\t\tchar\t   *xmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\t\tchar\t   *schematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t xmlsn, schematypename);\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlcn, catalogtypename);\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_sql_schema_to_xmlschema_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3255-3321",
    "snippet": "static const char *\nmap_sql_schema_to_xmlschema_types(Oid nspid, List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *nspname;\n\tchar\t   *xmlsn;\n\tchar\t   *schematypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\tnspname = get_namespace_name(nspid);\n\n\tinitStringInfo(&result);\n\n\txmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\n\tschematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", schematypename);\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\");\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tchar\t   *relname = get_rel_name(relid);\n\t\tchar\t   *xmltn = map_sql_identifier_to_xml_name(relname, true, false);\n\t\tchar\t   *tabletypename = map_multipart_sql_identifier_to_xml_name(tableforest ? \"RowType\" : \"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t relname);\n\n\t\tif (!tableforest)\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t\telse\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlsn, schematypename);\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\"",
            "xmlsn",
            "schematypename"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"</xsd:complexType>\\n\\n\""
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  </xsd:sequence>\\n\""
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  </xsd:all>\\n\""
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"",
            "xmltn",
            "tabletypename"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\"",
            "xmltn",
            "tabletypename"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_multipart_sql_identifier_to_xml_name",
          "args": [
            "tableforest ? \"RowType\" : \"TableType\"",
            "dbname",
            "nspname",
            "relname"
          ],
          "line": 3292
        },
        "resolved": true,
        "details": {
          "function_name": "map_multipart_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3119-3140",
          "snippet": "static char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "relname",
            "true",
            "false"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rel_name",
          "args": [
            "relid"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "get_rel_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1753-1770",
          "snippet": "Oid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "relid_list"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:sequence>\\n\""
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  <xsd:all>\\n\""
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:complexType name=\\\"%s\\\">\\n\"",
            "schematypename"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "nspid"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic const char *\nmap_sql_schema_to_xmlschema_types(Oid nspid, List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *nspname;\n\tchar\t   *xmlsn;\n\tchar\t   *schematypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\tnspname = get_namespace_name(nspid);\n\n\tinitStringInfo(&result);\n\n\txmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\n\tschematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", schematypename);\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\");\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tchar\t   *relname = get_rel_name(relid);\n\t\tchar\t   *xmltn = map_sql_identifier_to_xml_name(relname, true, false);\n\t\tchar\t   *tabletypename = map_multipart_sql_identifier_to_xml_name(tableforest ? \"RowType\" : \"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t relname);\n\n\t\tif (!tableforest)\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t\telse\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlsn, schematypename);\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_sql_table_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3150-3248",
    "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xsd_schema_element_end",
          "args": [
            "&result"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2897-2901",
          "snippet": "static void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\"",
            "xmltn",
            "rowtypename"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\"",
            "xmltn",
            "tabletypename"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\"",
            "tabletypename",
            "rowtypename"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\""
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\"",
            "map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false)",
            "map_sql_type_to_xml_name(att->atttypid, -1)",
            "nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\""
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_type_to_xml_name",
          "args": [
            "att->atttypid",
            "-1"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_type_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3385-3483",
          "snippet": "static const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);",
            "static const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_type_to_xml_name(Oid typeoid, int typmod);\nstatic const char *map_sql_type_to_xmlschema_type(Oid typeoid, int typmod);\n\nstatic const char *\nmap_sql_type_to_xml_name(Oid typeoid, int typmod)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tswitch (typeoid)\n\t{\n\t\tcase BPCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"CHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"CHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase VARCHAROID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"VARCHAR\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"VARCHAR_%d\", typmod - VARHDRSZ);\n\t\t\tbreak;\n\t\tcase NUMERICOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"NUMERIC\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"NUMERIC_%d_%d\",\n\t\t\t\t\t\t\t\t ((typmod - VARHDRSZ) >> 16) & 0xffff,\n\t\t\t\t\t\t\t\t (typmod - VARHDRSZ) & 0xffff);\n\t\t\tbreak;\n\t\tcase INT4OID:\n\t\t\tappendStringInfoString(&result, \"INTEGER\");\n\t\t\tbreak;\n\t\tcase INT2OID:\n\t\t\tappendStringInfoString(&result, \"SMALLINT\");\n\t\t\tbreak;\n\t\tcase INT8OID:\n\t\t\tappendStringInfoString(&result, \"BIGINT\");\n\t\t\tbreak;\n\t\tcase FLOAT4OID:\n\t\t\tappendStringInfoString(&result, \"REAL\");\n\t\t\tbreak;\n\t\tcase FLOAT8OID:\n\t\t\tappendStringInfoString(&result, \"DOUBLE\");\n\t\t\tbreak;\n\t\tcase BOOLOID:\n\t\t\tappendStringInfoString(&result, \"BOOLEAN\");\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIME_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIME_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_%d\", typmod);\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\tif (typmod == -1)\n\t\t\t\tappendStringInfoString(&result, \"TIMESTAMP_WTZ\");\n\t\t\telse\n\t\t\t\tappendStringInfo(&result, \"TIMESTAMP_WTZ_%d\", typmod);\n\t\t\tbreak;\n\t\tcase DATEOID:\n\t\t\tappendStringInfoString(&result, \"DATE\");\n\t\t\tbreak;\n\t\tcase XMLOID:\n\t\t\tappendStringInfoString(&result, \"XML\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tHeapTuple\ttuple;\n\t\t\t\tForm_pg_type typtuple;\n\n\t\t\t\ttuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typeoid));\n\t\t\t\tif (!HeapTupleIsValid(tuple))\n\t\t\t\t\telog(ERROR, \"cache lookup failed for type %u\", typeoid);\n\t\t\t\ttyptuple = (Form_pg_type) GETSTRUCT(tuple);\n\n\t\t\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t\t\t   map_multipart_sql_identifier_to_xml_name((typtuple->typtype == TYPTYPE_DOMAIN) ? \"Domain\" : \"UDT\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_namespace_name(typtuple->typnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(typtuple->typname)));\n\n\t\t\t\tReleaseSysCache(tuple);\n\t\t\t}\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "NameStr(att->attname)",
            "true",
            "false"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\"",
            "rowtypename"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc))"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_typecoll_to_xmlschema_types",
          "args": [
            "list_make1(tupdesc)"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_typecoll_to_xmlschema_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3490-3534",
          "snippet": "static const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "tupdesc"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsd_schema_element_start",
          "args": [
            "&result",
            "targetns"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2880-2894",
          "snippet": "static void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\""
          ],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_multipart_sql_identifier_to_xml_name",
          "args": [
            "\"RowType\"",
            "get_database_name(MyDatabaseId)",
            "get_namespace_name(reltuple->relnamespace)",
            "NameStr(reltuple->relname)"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "map_multipart_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3119-3140",
          "snippet": "static char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "reltuple->relname"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "reltuple->relnamespace"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "reltuple->relname"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "reltuple->relname"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for relation %u\"",
            "relid"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "relid"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "map_multipart_sql_identifier_to_xml_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3119-3140",
    "snippet": "static char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\".%s\"",
            "map_sql_identifier_to_xml_name(d, true, true)"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "d",
            "true",
            "true"
          ],
          "line": 3137
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\".%s\"",
            "map_sql_identifier_to_xml_name(c, true, true)"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&result",
            "\".%s\"",
            "map_sql_identifier_to_xml_name(b, true, true)"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "map_sql_identifier_to_xml_name(a, true, true)"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nmap_multipart_sql_identifier_to_xml_name(const char *a, const char *b, const char *c, const char *d)\n{\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (a)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   map_sql_identifier_to_xml_name(a, true, true));\n\tif (b)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(b, true, true));\n\tif (c)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(c, true, true));\n\tif (d)\n\t\tappendStringInfo(&result, \".%s\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(d, true, true));\n\n\treturn result.data;\n}"
  },
  {
    "function_name": "database_to_xml_and_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3100-3112",
    "snippet": "Datum\ndatabase_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\tStringInfo\txmlschema;\n\n\txmlschema = database_to_xmlschema_internal(nulls, tableforest, targetns);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xml_internal(xmlschema->data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(database_to_xml_internal(xmlschema->data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns))"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "database_to_xml_internal(xmlschema->data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "database_to_xml_internal",
          "args": [
            "xmlschema->data",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "database_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2990-3030",
          "snippet": "static StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "database_to_xmlschema_internal",
          "args": [
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "database_to_xmlschema_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3045-3085",
          "snippet": "static StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "0"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ndatabase_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\tStringInfo\txmlschema;\n\n\txmlschema = database_to_xmlschema_internal(nulls, tableforest, targetns);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xml_internal(xmlschema->data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)));\n}"
  },
  {
    "function_name": "database_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3088-3097",
    "snippet": "Datum\ndatabase_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xmlschema_internal(nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(database_to_xmlschema_internal(nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns))"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "database_to_xmlschema_internal(nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns)"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "database_to_xmlschema_internal",
          "args": [
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "database_to_xmlschema_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3045-3085",
          "snippet": "static StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "0"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ndatabase_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xmlschema_internal(nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns)));\n}"
  },
  {
    "function_name": "database_to_xmlschema_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3045-3085",
    "snippet": "static StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsd_schema_element_end",
          "args": [
            "result"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2897-2901",
          "snippet": "static void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns)"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_catalog_to_xmlschema_types",
          "args": [
            "nspid_list",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_catalog_to_xmlschema_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3328-3379",
          "snippet": "static const char *\nmap_sql_catalog_to_xmlschema_types(List *nspid_list, bool nulls,\n\t\t\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *xmlcn;\n\tchar\t   *catalogtypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\n\tinitStringInfo(&result);\n\n\txmlcn = map_sql_identifier_to_xml_name(dbname, true, false);\n\n\tcatalogtypename = map_multipart_sql_identifier_to_xml_name(\"CatalogType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", catalogtypename);\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tchar\t   *nspname = get_namespace_name(nspid);\n\t\tchar\t   *xmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\t\tchar\t   *schematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t xmlsn, schematypename);\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlcn, catalogtypename);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic const char *\nmap_sql_catalog_to_xmlschema_types(List *nspid_list, bool nulls,\n\t\t\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *xmlcn;\n\tchar\t   *catalogtypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\n\tinitStringInfo(&result);\n\n\txmlcn = map_sql_identifier_to_xml_name(dbname, true, false);\n\n\tcatalogtypename = map_multipart_sql_identifier_to_xml_name(\"CatalogType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", catalogtypename);\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tchar\t   *nspname = get_namespace_name(nspid);\n\t\tchar\t   *xmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\t\tchar\t   *schematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t xmlsn, schematypename);\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlcn, catalogtypename);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "map_sql_typecoll_to_xmlschema_types(tupdesc_list)"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_typecoll_to_xmlschema_types",
          "args": [
            "tupdesc_list"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_typecoll_to_xmlschema_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3490-3534",
          "snippet": "static const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "NoLock"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "tupdesc_list",
            "CreateTupleDescCopy(rel->rd_att)"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "rel->rd_att"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "lfirst_oid(cell)",
            "AccessShareLock"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "relid_list"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "database_get_xml_visible_schemas",
          "args": [],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "database_get_xml_visible_schemas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2480-2484",
          "snippet": "static List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE\n\nstatic List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "database_get_xml_visible_tables",
          "args": [],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "database_get_xml_visible_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2487-2498",
          "snippet": "static List *\ndatabase_get_xml_visible_tables(void)\n{\n\t/* At the moment there is no order required here. */\n\treturn query_to_oid_list(\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN (\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t\t\t \" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')\"\n\t\t\t\t\t\t\t \" AND relnamespace IN (\" XML_VISIBLE_SCHEMAS \");\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE\n\nstatic List *\ndatabase_get_xml_visible_tables(void)\n{\n\t/* At the moment there is no order required here. */\n\treturn query_to_oid_list(\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN (\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t\t\t \" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')\"\n\t\t\t\t\t\t\t \" AND relnamespace IN (\" XML_VISIBLE_SCHEMAS \");\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsd_schema_element_start",
          "args": [
            "result",
            "targetns"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2880-2894",
          "snippet": "static void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\""
          ],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\ndatabase_to_xmlschema_internal(bool nulls, bool tableforest,\n\t\t\t\t\t\t\t   const char *targetns)\n{\n\tList\t   *relid_list;\n\tList\t   *nspid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = database_get_xml_visible_tables();\n\tnspid_list = database_get_xml_visible_schemas();\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_catalog_to_xmlschema_types(nspid_list, nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
  },
  {
    "function_name": "database_to_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "3033-3042",
    "snippet": "Datum\ndatabase_to_xml(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xml_internal(NULL, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(database_to_xml_internal(NULL, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns))"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "database_to_xml_internal(NULL, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns)"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "database_to_xml_internal",
          "args": [
            "NULL",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "database_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2990-3030",
          "snippet": "static StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "0"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ndatabase_to_xml(PG_FUNCTION_ARGS)\n{\n\tbool\t\tnulls = PG_GETARG_BOOL(0);\n\tbool\t\ttableforest = PG_GETARG_BOOL(1);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(database_to_xml_internal(NULL, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns)));\n}"
  },
  {
    "function_name": "database_to_xml_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2990-3030",
    "snippet": "static StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmldata_root_element_end",
          "args": [
            "result",
            "xmlcn"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2632-2636",
          "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "subres->data"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema_to_xml_internal",
          "args": [
            "nspid",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "false"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "schema_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2815-2855",
          "snippet": "static StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "nspid_list"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "database_get_xml_visible_schemas",
          "args": [],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "database_get_xml_visible_schemas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2480-2484",
          "snippet": "static List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE\n\nstatic List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"%s\\n\\n\"",
            "xmlschema"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_start",
          "args": [
            "result",
            "xmlcn",
            "xmlschema",
            "targetns",
            "true"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2605-2629",
          "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
          ],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "get_database_name(MyDatabaseId)",
            "true",
            "false"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "MyDatabaseId"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic StringInfo\ndatabase_to_xml_internal(const char *xmlschema, bool nulls,\n\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tStringInfo\tresult;\n\tList\t   *nspid_list;\n\tListCell   *cell;\n\tchar\t   *xmlcn;\n\n\txmlcn = map_sql_identifier_to_xml_name(get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlcn, xmlschema, targetns, true);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\tnspid_list = database_get_xml_visible_schemas();\n\n\tforeach(cell, nspid_list)\n\t{\n\t\tOid\t\t\tnspid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = schema_to_xml_internal(nspid, NULL, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlcn);\n\n\treturn result;\n}"
  },
  {
    "function_name": "schema_to_xml_and_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2962-2982",
    "snippet": "Datum\nschema_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tchar\t   *schemaname;\n\tOid\t\t\tnspid;\n\tStringInfo\txmlschema;\n\n\tschemaname = NameStr(*name);\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txmlschema = schema_to_xmlschema_internal(schemaname, nulls,\n\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xml_internal(nspid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlschema->data, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(schema_to_xml_internal(nspid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlschema->data, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns, true))"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "schema_to_xml_internal(nspid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlschema->data, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns, true)"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema_to_xml_internal",
          "args": [
            "nspid",
            "xmlschema->data",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "schema_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2815-2855",
          "snippet": "static StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema_to_xmlschema_internal",
          "args": [
            "schemaname",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "schema_to_xmlschema_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2904-2946",
          "snippet": "static StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupExplicitNamespace",
          "args": [
            "schemaname",
            "false"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*name"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nschema_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tchar\t   *schemaname;\n\tOid\t\t\tnspid;\n\tStringInfo\txmlschema;\n\n\tschemaname = NameStr(*name);\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txmlschema = schema_to_xmlschema_internal(schemaname, nulls,\n\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xml_internal(nspid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t xmlschema->data, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t tableforest, targetns, true)));\n}"
  },
  {
    "function_name": "schema_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2949-2959",
    "snippet": "Datum\nschema_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xmlschema_internal(NameStr(*name),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(schema_to_xmlschema_internal(NameStr(*name),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns))"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "schema_to_xmlschema_internal(NameStr(*name),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema_to_xmlschema_internal",
          "args": [
            "NameStr(*name)",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "schema_to_xmlschema_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2904-2946",
          "snippet": "static StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*name"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nschema_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xmlschema_internal(NameStr(*name),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   nulls, tableforest, targetns)));\n}"
  },
  {
    "function_name": "schema_to_xmlschema_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2904-2946",
    "snippet": "static StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsd_schema_element_end",
          "args": [
            "result"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2897-2901",
          "snippet": "static void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns)"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_schema_to_xmlschema_types",
          "args": [
            "nspid",
            "relid_list",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_schema_to_xmlschema_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3255-3321",
          "snippet": "static const char *\nmap_sql_schema_to_xmlschema_types(Oid nspid, List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *nspname;\n\tchar\t   *xmlsn;\n\tchar\t   *schematypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\tnspname = get_namespace_name(nspid);\n\n\tinitStringInfo(&result);\n\n\txmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\n\tschematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", schematypename);\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\");\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tchar\t   *relname = get_rel_name(relid);\n\t\tchar\t   *xmltn = map_sql_identifier_to_xml_name(relname, true, false);\n\t\tchar\t   *tabletypename = map_multipart_sql_identifier_to_xml_name(tableforest ? \"RowType\" : \"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t relname);\n\n\t\tif (!tableforest)\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t\telse\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlsn, schematypename);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic const char *\nmap_sql_schema_to_xmlschema_types(Oid nspid, List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns)\n{\n\tchar\t   *dbname;\n\tchar\t   *nspname;\n\tchar\t   *xmlsn;\n\tchar\t   *schematypename;\n\tStringInfoData result;\n\tListCell   *cell;\n\n\tdbname = get_database_name(MyDatabaseId);\n\tnspname = get_namespace_name(nspid);\n\n\tinitStringInfo(&result);\n\n\txmlsn = map_sql_identifier_to_xml_name(nspname, true, false);\n\n\tschematypename = map_multipart_sql_identifier_to_xml_name(\"SchemaType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\", schematypename);\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  <xsd:sequence>\\n\");\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tchar\t   *relname = get_rel_name(relid);\n\t\tchar\t   *xmltn = map_sql_identifier_to_xml_name(relname, true, false);\n\t\tchar\t   *tabletypename = map_multipart_sql_identifier_to_xml_name(tableforest ? \"RowType\" : \"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t dbname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nspname,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t relname);\n\n\t\tif (!tableforest)\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t\telse\n\t\t\tappendStringInfo(&result,\n\t\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\",\n\t\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\n\tif (!tableforest)\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:all>\\n\");\n\telse\n\t\tappendStringInfoString(&result,\n\t\t\t\t\t\t\t   \"  </xsd:sequence>\\n\");\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t xmlsn, schematypename);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "map_sql_typecoll_to_xmlschema_types(tupdesc_list)"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_typecoll_to_xmlschema_types",
          "args": [
            "tupdesc_list"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_typecoll_to_xmlschema_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3490-3534",
          "snippet": "static const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_typecoll_to_xmlschema_types(List *tupdesc_list)\n{\n\tList\t   *uniquetypes = NIL;\n\tint\t\t\ti;\n\tStringInfoData result;\n\tListCell   *cell0;\n\n\t/* extract all column types used in the set of TupleDescs */\n\tforeach(cell0, tupdesc_list)\n\t{\n\t\tTupleDesc\ttupdesc = (TupleDesc) lfirst(cell0);\n\n\t\tfor (i = 0; i < tupdesc->natts; i++)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\t\tif (att->attisdropped)\n\t\t\t\tcontinue;\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, att->atttypid);\n\t\t}\n\t}\n\n\t/* add base types of domains */\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tOid\t\t\ttypid = lfirst_oid(cell0);\n\t\tOid\t\t\tbasetypid = getBaseType(typid);\n\n\t\tif (basetypid != typid)\n\t\t\tuniquetypes = list_append_unique_oid(uniquetypes, basetypid);\n\t}\n\n\t/* Convert to textual form */\n\tinitStringInfo(&result);\n\n\tforeach(cell0, uniquetypes)\n\t{\n\t\tappendStringInfo(&result, \"%s\\n\",\n\t\t\t\t\t\t map_sql_type_to_xmlschema_type(lfirst_oid(cell0),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t-1));\n\t}\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "NoLock"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "tupdesc_list",
            "CreateTupleDescCopy(rel->rd_att)"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "rel->rd_att"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "lfirst_oid(cell)",
            "AccessShareLock"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "relid_list"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema_get_xml_visible_tables",
          "args": [
            "nspid"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "schema_get_xml_visible_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2453-2468",
          "snippet": "static List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsd_schema_element_start",
          "args": [
            "result",
            "targetns"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "xsd_schema_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2880-2894",
          "snippet": "static void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\""
          ],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupExplicitNamespace",
          "args": [
            "schemaname",
            "false"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic const char *map_sql_typecoll_to_xmlschema_types(List *tupdesc_list);\n\nstatic StringInfo\nschema_to_xmlschema_internal(const char *schemaname, bool nulls,\n\t\t\t\t\t\t\t bool tableforest, const char *targetns)\n{\n\tOid\t\t\tnspid;\n\tList\t   *relid_list;\n\tList\t   *tupdesc_list;\n\tListCell   *cell;\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\txsd_schema_element_start(result, targetns);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\ttupdesc_list = NIL;\n\tforeach(cell, relid_list)\n\t{\n\t\tRelation\trel;\n\n\t\trel = heap_open(lfirst_oid(cell), AccessShareLock);\n\t\ttupdesc_list = lappend(tupdesc_list, CreateTupleDescCopy(rel->rd_att));\n\t\theap_close(rel, NoLock);\n\t}\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(tupdesc_list));\n\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   map_sql_schema_to_xmlschema_types(nspid, relid_list,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns));\n\n\txsd_schema_element_end(result);\n\n\tSPI_finish();\n\n\treturn result;\n}"
  },
  {
    "function_name": "xsd_schema_element_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2897-2901",
    "snippet": "static void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"</xsd:schema>\""
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxsd_schema_element_end(StringInfo result)\n{\n\tappendStringInfoString(result, \"</xsd:schema>\");\n}"
  },
  {
    "function_name": "xsd_schema_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2880-2894",
    "snippet": "static void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\""
    ],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\">\\n\\n\""
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\"",
            "targetns"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "targetns"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\""
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSD \"http://www.w3.org/2001/XMLSchema\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nstatic void\nxsd_schema_element_start(StringInfo result, const char *targetns)\n{\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \"<xsd:schema\\n\"\n\t\t\t\t\t\t   \"    xmlns:xsd=\\\"\" NAMESPACE_XSD \"\\\"\");\n\tif (strlen(targetns) > 0)\n\t\tappendStringInfo(result,\n\t\t\t\t\t\t \"\\n\"\n\t\t\t\t\t\t \"    targetNamespace=\\\"%s\\\"\\n\"\n\t\t\t\t\t\t \"    elementFormDefault=\\\"qualified\\\"\",\n\t\t\t\t\t\t targetns);\n\tappendStringInfoString(result,\n\t\t\t\t\t\t   \">\\n\\n\");\n}"
  },
  {
    "function_name": "schema_to_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2858-2874",
    "snippet": "Datum\nschema_to_xml(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tchar\t   *schemaname;\n\tOid\t\t\tnspid;\n\n\tschemaname = NameStr(*name);\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xml_internal(nspid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(schema_to_xml_internal(nspid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns, true))"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "schema_to_xml_internal(nspid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns, true)"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema_to_xml_internal",
          "args": [
            "nspid",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "schema_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2815-2855",
          "snippet": "static StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupExplicitNamespace",
          "args": [
            "schemaname",
            "false"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*name"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nschema_to_xml(PG_FUNCTION_ARGS)\n{\n\tName\t\tname = PG_GETARG_NAME(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tchar\t   *schemaname;\n\tOid\t\t\tnspid;\n\n\tschemaname = NameStr(*name);\n\tnspid = LookupExplicitNamespace(schemaname, false);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(schema_to_xml_internal(nspid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t nulls, tableforest, targetns, true)));\n}"
  },
  {
    "function_name": "schema_to_xml_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2815-2855",
    "snippet": "static StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
      "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmldata_root_element_end",
          "args": [
            "result",
            "xmlsn"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2632-2636",
          "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "subres->data"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table_to_xml_internal",
          "args": [
            "relid",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "false"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "table_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2506-2520",
          "snippet": "static StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "relid_list"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema_get_xml_visible_tables",
          "args": [
            "nspid"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "schema_get_xml_visible_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2453-2468",
          "snippet": "static List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"%s\\n\\n\"",
            "xmlschema"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_start",
          "args": [
            "result",
            "xmlsn",
            "xmlschema",
            "targetns",
            "top_level"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2605-2629",
          "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
          ],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "get_namespace_name(nspid)",
            "true",
            "false"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "nspid"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nschema_to_xml_internal(Oid nspid, const char *xmlschema, bool nulls,\n\t\t\t\t\t   bool tableforest, const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmlsn;\n\tList\t   *relid_list;\n\tListCell   *cell;\n\n\txmlsn = map_sql_identifier_to_xml_name(get_namespace_name(nspid),\n\t\t\t\t\t\t\t\t\t\t   true, false);\n\tresult = makeStringInfo();\n\n\txmldata_root_element_start(result, xmlsn, xmlschema, targetns, top_level);\n\tappendStringInfoChar(result, '\\n');\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tSPI_connect();\n\n\trelid_list = schema_get_xml_visible_tables(nspid);\n\n\tforeach(cell, relid_list)\n\t{\n\t\tOid\t\t\trelid = lfirst_oid(cell);\n\t\tStringInfo\tsubres;\n\n\t\tsubres = table_to_xml_internal(relid, NULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t   targetns, false);\n\n\t\tappendStringInfoString(result, subres->data);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tSPI_finish();\n\n\txmldata_root_element_end(result, xmlsn);\n\n\treturn result;\n}"
  },
  {
    "function_name": "query_to_xml_and_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2779-2807",
    "snippet": "Datum\nquery_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tconst char *xmlschema;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\txmlschema = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls, tableforest, targetns));\n\tSPI_cursor_close(portal);\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true))"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_to_xml_internal",
          "args": [
            "query",
            "NULL",
            "xmlschema",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2639-2681",
          "snippet": "static StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_close",
          "args": [
            "portal"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_SPI_strdup",
          "args": [
            "map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls, tableforest, targetns)"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "_SPI_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2371-2379",
          "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_table_to_xmlschema",
          "args": [
            "portal->tupDesc",
            "InvalidOid",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_table_to_xmlschema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3150-3248",
          "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_cursor_open(\\\"%s\\\") failed\"",
            "query"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_open",
          "args": [
            "NULL",
            "plan",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "query",
            "0",
            "NULL"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nquery_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tconst char *xmlschema;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\txmlschema = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls, tableforest, targetns));\n\tSPI_cursor_close(portal);\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}"
  },
  {
    "function_name": "table_to_xml_and_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2758-2776",
    "snippet": "Datum\ntable_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tRelation\trel;\n\tconst char *xmlschema;\n\n\trel = heap_open(relid, AccessShareLock);\n\txmlschema = map_sql_table_to_xmlschema(rel->rd_att, relid, nulls,\n\t\t\t\t\t\t\t\t\t\t   tableforest, targetns);\n\theap_close(rel, NoLock);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(table_to_xml_internal(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(table_to_xml_internal(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true))"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "table_to_xml_internal(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_to_xml_internal",
          "args": [
            "relid",
            "xmlschema",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "table_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2506-2520",
          "snippet": "static StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "NoLock"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_table_to_xmlschema",
          "args": [
            "rel->rd_att",
            "relid",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_table_to_xmlschema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3150-3248",
          "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "relid",
            "AccessShareLock"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ntable_to_xml_and_xmlschema(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tRelation\trel;\n\tconst char *xmlschema;\n\n\trel = heap_open(relid, AccessShareLock);\n\txmlschema = map_sql_table_to_xmlschema(rel->rd_att, relid, nulls,\n\t\t\t\t\t\t\t\t\t\t   tableforest, targetns);\n\theap_close(rel, NoLock);\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(table_to_xml_internal(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\txmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}"
  },
  {
    "function_name": "cursor_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2732-2755",
    "snippet": "Datum\ncursor_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *xmlschema;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\tportal = SPI_cursor_find(name);\n\tif (portal == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name)));\n\n\txmlschema = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns));\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(xmlschema));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "cstring_to_xmltype(xmlschema)"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_xmltype",
          "args": [
            "xmlschema"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "452-456",
          "snippet": "static xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_SPI_strdup",
          "args": [
            "map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns)"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "_SPI_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2371-2379",
          "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_table_to_xmlschema",
          "args": [
            "portal->tupDesc",
            "InvalidOid",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_table_to_xmlschema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3150-3248",
          "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name))"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cursor \\\"%s\\\" does not exist\"",
            "name"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_CURSOR"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_find",
          "args": [
            "name"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ncursor_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *xmlschema;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\tportal = SPI_cursor_find(name);\n\tif (portal == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name)));\n\n\txmlschema = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   InvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   tableforest, targetns));\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(xmlschema));\n}"
  },
  {
    "function_name": "query_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2703-2729",
    "snippet": "Datum\nquery_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *result;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tresult = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\tInvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttableforest, targetns));\n\tSPI_cursor_close(portal);\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(result));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "cstring_to_xmltype(result)"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_xmltype",
          "args": [
            "result"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "452-456",
          "snippet": "static xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_close",
          "args": [
            "portal"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_SPI_strdup",
          "args": [
            "map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\tInvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttableforest, targetns)"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "_SPI_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2371-2379",
          "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_sql_table_to_xmlschema",
          "args": [
            "portal->tupDesc",
            "InvalidOid",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_table_to_xmlschema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3150-3248",
          "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_cursor_open(\\\"%s\\\") failed\"",
            "query"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_open",
          "args": [
            "NULL",
            "plan",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "query",
            "0",
            "NULL"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nquery_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *result;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tresult = _SPI_strdup(map_sql_table_to_xmlschema(portal->tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\tInvalidOid, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttableforest, targetns));\n\tSPI_cursor_close(portal);\n\tSPI_finish();\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(result));\n}"
  },
  {
    "function_name": "table_to_xmlschema",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2684-2700",
    "snippet": "Datum\ntable_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *result;\n\tRelation\trel;\n\n\trel = heap_open(relid, AccessShareLock);\n\tresult = map_sql_table_to_xmlschema(rel->rd_att, relid, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns);\n\theap_close(rel, NoLock);\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(result));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "cstring_to_xmltype(result)"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_xmltype",
          "args": [
            "result"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "452-456",
          "snippet": "static xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "NoLock"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_table_to_xmlschema",
          "args": [
            "rel->rd_att",
            "relid",
            "nulls",
            "tableforest",
            "targetns"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_table_to_xmlschema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3150-3248",
          "snippet": "static const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\n\nstatic const char *\nmap_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls,\n\t\t\t\t\t\t   bool tableforest, const char *targetns)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\tchar\t   *tabletypename;\n\tchar\t   *rowtypename;\n\tStringInfoData result;\n\n\tinitStringInfo(&result);\n\n\tif (OidIsValid(relid))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_class reltuple;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\t\treltuple = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\txmltn = map_sql_identifier_to_xml_name(NameStr(reltuple->relname),\n\t\t\t\t\t\t\t\t\t\t\t   true, false);\n\n\t\ttabletypename = map_multipart_sql_identifier_to_xml_name(\"TableType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NameStr(reltuple->relname));\n\n\t\trowtypename = map_multipart_sql_identifier_to_xml_name(\"RowType\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_database_name(MyDatabaseId),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   get_namespace_name(reltuple->relnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NameStr(reltuple->relname));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\n\t\ttabletypename = \"TableType\";\n\t\trowtypename = \"RowType\";\n\t}\n\n\txsd_schema_element_start(&result, targetns);\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   map_sql_typecoll_to_xmlschema_types(list_make1(tupdesc)));\n\n\tappendStringInfo(&result,\n\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t \"  <xsd:sequence>\\n\",\n\t\t\t\t\t rowtypename);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"    <xsd:element name=\\\"%s\\\" type=\\\"%s\\\"%s></xsd:element>\\n\",\n\t\t\t\t\t\t map_sql_identifier_to_xml_name(NameStr(att->attname),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue, false),\n\t\t\t\t\t\t map_sql_type_to_xml_name(att->atttypid, -1),\n\t\t\t\t\t\t nulls ? \" nillable=\\\"true\\\"\" : \" minOccurs=\\\"0\\\"\");\n\t}\n\n\tappendStringInfoString(&result,\n\t\t\t\t\t\t   \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t   \"</xsd:complexType>\\n\\n\");\n\n\tif (!tableforest)\n\t{\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:complexType name=\\\"%s\\\">\\n\"\n\t\t\t\t\t\t \"  <xsd:sequence>\\n\"\n\t\t\t\t\t\t \"    <xsd:element name=\\\"row\\\" type=\\\"%s\\\" minOccurs=\\\"0\\\" maxOccurs=\\\"unbounded\\\"/>\\n\"\n\t\t\t\t\t\t \"  </xsd:sequence>\\n\"\n\t\t\t\t\t\t \"</xsd:complexType>\\n\\n\",\n\t\t\t\t\t\t tabletypename, rowtypename);\n\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, tabletypename);\n\t}\n\telse\n\t\tappendStringInfo(&result,\n\t\t\t\t\t\t \"<xsd:element name=\\\"%s\\\" type=\\\"%s\\\"/>\\n\\n\",\n\t\t\t\t\t\t xmltn, rowtypename);\n\n\txsd_schema_element_end(&result);\n\n\treturn result.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "relid",
            "AccessShareLock"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ntable_to_xmlschema(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\tconst char *result;\n\tRelation\trel;\n\n\trel = heap_open(relid, AccessShareLock);\n\tresult = map_sql_table_to_xmlschema(rel->rd_att, relid, nulls,\n\t\t\t\t\t\t\t\t\t\ttableforest, targetns);\n\theap_close(rel, NoLock);\n\n\tPG_RETURN_XML_P(cstring_to_xmltype(result));\n}"
  },
  {
    "function_name": "query_to_xml_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2639-2681",
    "snippet": "static StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
      "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_end",
          "args": [
            "result",
            "xmltn"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2632-2636",
          "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_sql_row_to_xmlelement",
          "args": [
            "i",
            "result",
            "tablename",
            "nulls",
            "tableforest",
            "targetns",
            "top_level"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "SPI_sql_row_to_xmlelement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3720-3775",
          "snippet": "static void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);",
            "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"%s\\n\\n\"",
            "xmlschema"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'\\n'"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_start",
          "args": [
            "result",
            "xmltn",
            "xmlschema",
            "targetns",
            "top_level"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2605-2629",
          "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
          ],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\"))"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid query\""
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_execute",
          "args": [
            "query",
            "true",
            "0"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_identifier_to_xml_name",
          "args": [
            "tablename",
            "true",
            "false"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_identifier_to_xml_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2004-2054",
          "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}"
  },
  {
    "function_name": "xmldata_root_element_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2632-2636",
    "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"</%s>\\n\"",
            "eltname"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
  },
  {
    "function_name": "xmldata_root_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2605-2629",
    "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
    ],
    "globals_used": [
      "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
      "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
      "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\">\\n\""
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\" xsi:noNamespaceSchemaLocation=\\\"#\\\"\""
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\" xsi:schemaLocation=\\\"%s #\\\"\"",
            "targetns"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "targetns"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\" xmlns=\\\"%s\\\"\"",
            "targetns"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\""
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"<%s\"",
            "eltname"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "top_level || !xmlschema"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
  },
  {
    "function_name": "cursor_to_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2551-2590",
    "snippet": "Datum\ncursor_to_xml(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tint32\t\tcount = PG_GETARG_INT32(1);\n\tbool\t\tnulls = PG_GETARG_BOOL(2);\n\tbool\t\ttableforest = PG_GETARG_BOOL(3);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(4));\n\n\tStringInfoData result;\n\tPortal\t\tportal;\n\tuint64\t\ti;\n\n\tinitStringInfo(&result);\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(&result, \"table\", NULL, targetns, true);\n\t\tappendStringInfoChar(&result, '\\n');\n\t}\n\n\tSPI_connect();\n\tportal = SPI_cursor_find(name);\n\tif (portal == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name)));\n\n\tSPI_cursor_fetch(portal, true, count);\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, &result, NULL, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, true);\n\n\tSPI_finish();\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(&result, \"table\");\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(&result));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(&result)"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "&result"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_end",
          "args": [
            "&result",
            "\"table\""
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2632-2636",
          "snippet": "static void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\n\nstatic void\nxmldata_root_element_end(StringInfo result, const char *eltname)\n{\n\tappendStringInfo(result, \"</%s>\\n\", eltname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_sql_row_to_xmlelement",
          "args": [
            "i",
            "&result",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "SPI_sql_row_to_xmlelement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "3720-3775",
          "snippet": "static void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);",
            "static void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);",
            "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\nstatic void XmlTableInitOpaque(struct TableFuncScanState *state, int natts);\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic void\nSPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result, char *tablename,\n\t\t\t\t\t\t  bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tint\t\t\ti;\n\tchar\t   *xmltn;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t{\n\t\tif (tableforest)\n\t\t\txmltn = \"row\";\n\t\telse\n\t\t\txmltn = \"table\";\n\t}\n\n\tif (tableforest)\n\t\txmldata_root_element_start(result, xmltn, NULL, targetns, top_level);\n\telse\n\t\tappendStringInfoString(result, \"<row>\\n\");\n\n\tfor (i = 1; i <= SPI_tuptable->tupdesc->natts; i++)\n\t{\n\t\tchar\t   *colname;\n\t\tDatum\t\tcolval;\n\t\tbool\t\tisnull;\n\n\t\tcolname = map_sql_identifier_to_xml_name(SPI_fname(SPI_tuptable->tupdesc, i),\n\t\t\t\t\t\t\t\t\t\t\t\t true, false);\n\t\tcolval = SPI_getbinval(SPI_tuptable->vals[rownum],\n\t\t\t\t\t\t\t   SPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t   i,\n\t\t\t\t\t\t\t   &isnull);\n\t\tif (isnull)\n\t\t{\n\t\t\tif (nulls)\n\t\t\t\tappendStringInfo(result, \"  <%s xsi:nil=\\\"true\\\"/>\\n\", colname);\n\t\t}\n\t\telse\n\t\t\tappendStringInfo(result, \"  <%s>%s</%s>\\n\",\n\t\t\t\t\t\t\t colname,\n\t\t\t\t\t\t\t map_sql_value_to_xml_value(colval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSPI_gettypeid(SPI_tuptable->tupdesc, i), true),\n\t\t\t\t\t\t\t colname);\n\t}\n\n\tif (tableforest)\n\t{\n\t\txmldata_root_element_end(result, xmltn);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\telse\n\t\tappendStringInfoString(result, \"</row>\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_fetch",
          "args": [
            "portal",
            "true",
            "count"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name))"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cursor \\\"%s\\\" does not exist\"",
            "name"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_CURSOR"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_find",
          "args": [
            "name"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&result",
            "'\\n'"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmldata_root_element_start",
          "args": [
            "&result",
            "\"table\"",
            "NULL",
            "targetns",
            "true"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "xmldata_root_element_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2605-2629",
          "snippet": "static void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\""
          ],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static void xmldata_root_element_end(StringInfo result, const char *eltname);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define NAMESPACE_XSI \"http://www.w3.org/2001/XMLSchema-instance\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic void xmldata_root_element_end(StringInfo result, const char *eltname);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic void\nxmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level)\n{\n\t/* This isn't really wrong but currently makes no sense. */\n\tAssert(top_level || !xmlschema);\n\n\tappendStringInfo(result, \"<%s\", eltname);\n\tif (top_level)\n\t{\n\t\tappendStringInfoString(result, \" xmlns:xsi=\\\"\" NAMESPACE_XSI \"\\\"\");\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xmlns=\\\"%s\\\"\", targetns);\n\t}\n\tif (xmlschema)\n\t{\n\t\t/* FIXME: better targets */\n\t\tif (strlen(targetns) > 0)\n\t\t\tappendStringInfo(result, \" xsi:schemaLocation=\\\"%s #\\\"\", targetns);\n\t\telse\n\t\t\tappendStringInfoString(result, \" xsi:noNamespaceSchemaLocation=\\\"#\\\"\");\n\t}\n\tappendStringInfoString(result, \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(4)"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "4"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ncursor_to_xml(PG_FUNCTION_ARGS)\n{\n\tchar\t   *name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tint32\t\tcount = PG_GETARG_INT32(1);\n\tbool\t\tnulls = PG_GETARG_BOOL(2);\n\tbool\t\ttableforest = PG_GETARG_BOOL(3);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(4));\n\n\tStringInfoData result;\n\tPortal\t\tportal;\n\tuint64\t\ti;\n\n\tinitStringInfo(&result);\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(&result, \"table\", NULL, targetns, true);\n\t\tappendStringInfoChar(&result, '\\n');\n\t}\n\n\tSPI_connect();\n\tportal = SPI_cursor_find(name);\n\tif (portal == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_CURSOR),\n\t\t\t\t errmsg(\"cursor \\\"%s\\\" does not exist\", name)));\n\n\tSPI_cursor_fetch(portal, true, count);\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, &result, NULL, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, true);\n\n\tSPI_finish();\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(&result, \"table\");\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(&result));\n}"
  },
  {
    "function_name": "query_to_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2537-2548",
    "snippet": "Datum\nquery_to_xml(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true))"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_to_xml_internal",
          "args": [
            "query",
            "NULL",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2639-2681",
          "snippet": "static StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\nquery_to_xml(PG_FUNCTION_ARGS)\n{\n\tchar\t   *query = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(query_to_xml_internal(query, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNULL, nulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}"
  },
  {
    "function_name": "table_to_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2523-2534",
    "snippet": "Datum\ntable_to_xml(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(table_to_xml_internal(relid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(table_to_xml_internal(relid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true))"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "table_to_xml_internal(relid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_to_xml_internal",
          "args": [
            "relid",
            "NULL",
            "nulls",
            "tableforest",
            "targetns",
            "true"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "table_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2506-2520",
          "snippet": "static StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(3)"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\n\nDatum\ntable_to_xml(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tbool\t\tnulls = PG_GETARG_BOOL(1);\n\tbool\t\ttableforest = PG_GETARG_BOOL(2);\n\tconst char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(3));\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(table_to_xml_internal(relid, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnulls, tableforest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetns, true)));\n}"
  },
  {
    "function_name": "table_to_xml_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2506-2520",
    "snippet": "static StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
      "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
      "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
      "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
      "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
      "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_to_xml_internal",
          "args": [
            "query.data",
            "get_rel_name(relid)",
            "xmlschema",
            "nulls",
            "tableforest",
            "targetns",
            "top_level"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_xml_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2639-2681",
          "snippet": "static StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);",
            "static StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);",
            "static const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);",
            "static const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);",
            "static const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);",
            "static void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\nquery_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfo\tresult;\n\tchar\t   *xmltn;\n\tuint64\t\ti;\n\n\tif (tablename)\n\t\txmltn = map_sql_identifier_to_xml_name(tablename, true, false);\n\telse\n\t\txmltn = \"table\";\n\n\tresult = makeStringInfo();\n\n\tSPI_connect();\n\tif (SPI_execute(query, true, 0) != SPI_OK_SELECT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"invalid query\")));\n\n\tif (!tableforest)\n\t{\n\t\txmldata_root_element_start(result, xmltn, xmlschema,\n\t\t\t\t\t\t\t\t   targetns, top_level);\n\t\tappendStringInfoChar(result, '\\n');\n\t}\n\n\tif (xmlschema)\n\t\tappendStringInfo(result, \"%s\\n\\n\", xmlschema);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t\tSPI_sql_row_to_xmlelement(i, result, tablename, nulls,\n\t\t\t\t\t\t\t\t  tableforest, targetns, top_level);\n\n\tif (!tableforest)\n\t\txmldata_root_element_end(result, xmltn);\n\n\tSPI_finish();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rel_name",
          "args": [
            "relid"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "get_rel_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1753-1770",
          "snippet": "Oid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&query",
            "\"SELECT * FROM %s\"",
            "DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid)))"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "regclassout",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&query"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void xmldata_root_element_start(StringInfo result, const char *eltname,\n\t\t\t\t\t\t   const char *xmlschema, const char *targetns,\n\t\t\t\t\t\t   bool top_level);\nstatic StringInfo query_to_xml_internal(const char *query, char *tablename,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level);\nstatic const char *map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid,\n\t\t\t\t\t\t   bool nulls, bool tableforest, const char *targetns);\nstatic const char *map_sql_schema_to_xmlschema_types(Oid nspid,\n\t\t\t\t\t\t\t\t  List *relid_list, bool nulls,\n\t\t\t\t\t\t\t\t  bool tableforest, const char *targetns);\nstatic const char *map_sql_catalog_to_xmlschema_types(List *nspid_list,\n\t\t\t\t\t\t\t\t   bool nulls, bool tableforest,\n\t\t\t\t\t\t\t\t   const char *targetns);\nstatic void SPI_sql_row_to_xmlelement(uint64 rownum, StringInfo result,\n\t\t\t\t\t\t  char *tablename, bool nulls, bool tableforest,\n\t\t\t\t\t\t  const char *targetns, bool top_level);\n\nstatic StringInfo\ntable_to_xml_internal(Oid relid,\n\t\t\t\t\t  const char *xmlschema, bool nulls, bool tableforest,\n\t\t\t\t\t  const char *targetns, bool top_level)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT * FROM %s\",\n\t\t\t\t\t DatumGetCString(DirectFunctionCall1(regclassout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid))));\n\treturn query_to_xml_internal(query.data, get_rel_name(relid),\n\t\t\t\t\t\t\t\t xmlschema, nulls, tableforest,\n\t\t\t\t\t\t\t\t targetns, top_level);\n}"
  },
  {
    "function_name": "database_get_xml_visible_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2487-2498",
    "snippet": "static List *\ndatabase_get_xml_visible_tables(void)\n{\n\t/* At the moment there is no order required here. */\n\treturn query_to_oid_list(\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN (\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t\t\t \" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')\"\n\t\t\t\t\t\t\t \" AND relnamespace IN (\" XML_VISIBLE_SCHEMAS \");\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_to_oid_list",
          "args": [
            "\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN (\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_VIEW)\")\"\n\t\t\t\t\t\t\t \" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')\"\n\t\t\t\t\t\t\t \" AND relnamespace IN (\" XML_VISIBLE_SCHEMAS \");\""
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_oid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2428-2450",
          "snippet": "static List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\",\"\n\t\t\t\t\t\t\t CppAsString2",
          "args": [
            "RELKIND_VIEW"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\",\"\n\t\t\t\t\t\t\t CppAsString2",
          "args": [
            "RELKIND_MATVIEW"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN",
          "args": [
            "RELKIND_RELATION"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE\n\nstatic List *\ndatabase_get_xml_visible_tables(void)\n{\n\t/* At the moment there is no order required here. */\n\treturn query_to_oid_list(\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t\t\t \" WHERE relkind IN (\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t\t\t \" AND pg_catalog.has_table_privilege(pg_class.oid, 'SELECT')\"\n\t\t\t\t\t\t\t \" AND relnamespace IN (\" XML_VISIBLE_SCHEMAS \");\");\n}"
  },
  {
    "function_name": "database_get_xml_visible_schemas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2480-2484",
    "snippet": "static List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_to_oid_list",
          "args": [
            "XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\""
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_oid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2428-2450",
          "snippet": "static List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define XML_VISIBLE_SCHEMAS \"SELECT oid FROM pg_catalog.pg_namespace WHERE pg_catalog.has_schema_privilege (oid, 'USAGE') AND NOT \" XML_VISIBLE_SCHEMAS_EXCLUDE\n\nstatic List *\ndatabase_get_xml_visible_schemas(void)\n{\n\treturn query_to_oid_list(XML_VISIBLE_SCHEMAS \" ORDER BY nspname;\");\n}"
  },
  {
    "function_name": "schema_get_xml_visible_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2453-2468",
    "snippet": "static List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_to_oid_list",
          "args": [
            "query.data"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "query_to_oid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2428-2450",
          "snippet": "static List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&query",
            "\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW)\")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\"",
            "nspid"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\",\"\n\t\t\t\t\t CppAsString2",
          "args": [
            "RELKIND_VIEW"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\",\"\n\t\t\t\t\t CppAsString2",
          "args": [
            "RELKIND_MATVIEW"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN",
          "args": [
            "RELKIND_RELATION"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&query"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic List *\nschema_get_xml_visible_tables(Oid nspid)\n{\n\tStringInfoData query;\n\n\tinitStringInfo(&query);\n\tappendStringInfo(&query, \"SELECT oid FROM pg_catalog.pg_class\"\n\t\t\t\t\t \" WHERE relnamespace = %u AND relkind IN (\"\n\t\t\t\t\t CppAsString2(RELKIND_RELATION) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_MATVIEW) \",\"\n\t\t\t\t\t CppAsString2(RELKIND_VIEW) \")\"\n\t\t\t\t\t \" AND pg_catalog.has_table_privilege (oid, 'SELECT')\"\n\t\t\t\t\t \" ORDER BY relname;\", nspid);\n\n\treturn query_to_oid_list(query.data);\n}"
  },
  {
    "function_name": "query_to_oid_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2428-2450",
    "snippet": "static List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend_oid",
          "args": [
            "list",
            "DatumGetObjectId(oid)"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "oid"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "SPI_tuptable->vals[i]",
            "SPI_tuptable->tupdesc",
            "1",
            "&isnull"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_execute",
          "args": [
            "query",
            "true",
            "0"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic Datum XmlTableGetValue(struct TableFuncScanState *state, int colnum,\n\t\t\t\t Oid typid, int32 typmod, bool *isnull);\n\nstatic List *\nquery_to_oid_list(const char *query)\n{\n\tuint64\t\ti;\n\tList\t   *list = NIL;\n\n\tSPI_execute(query, true, 0);\n\n\tfor (i = 0; i < SPI_processed; i++)\n\t{\n\t\tDatum\t\toid;\n\t\tbool\t\tisnull;\n\n\t\toid = SPI_getbinval(SPI_tuptable->vals[i],\n\t\t\t\t\t\t\tSPI_tuptable->tupdesc,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t\tlist = lappend_oid(list, DatumGetObjectId(oid));\n\t}\n\n\treturn list;\n}"
  },
  {
    "function_name": "_SPI_strdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2371-2379",
    "snippet": "static char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "s",
            "len"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_palloc",
          "args": [
            "len"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\n_SPI_strdup(const char *s)\n{\n\tsize_t\t\tlen = strlen(s) + 1;\n\tchar\t   *ret = SPI_palloc(len);\n\n\tmemcpy(ret, s, len);\n\treturn ret;\n}"
  },
  {
    "function_name": "escape_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2339-2368",
    "snippet": "char *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "*p"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"&#x0d;\""
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"&gt;\""
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"&lt;\""
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"&amp;\""
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}"
  },
  {
    "function_name": "map_sql_value_to_xml_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2120-2329",
    "snippet": "char *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmlbinary;",
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "escape_xml",
          "args": [
            "str"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "escape_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2339-2368",
          "snippet": "char *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nescape_xml(const char *str)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '&':\n\t\t\t\tappendStringInfoString(&buf, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tappendStringInfoString(&buf, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tappendStringInfoString(&buf, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(&buf, \"&#x0d;\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappendStringInfoCharMacro(&buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidOutputFunctionCall",
          "args": [
            "typeOut",
            "value"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "type",
            "&typeOut",
            "&isvarlena"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xmlerrcxt",
            "false"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeTextWriter",
          "args": [
            "writer"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "(const char *) xmlBufferContent(buf)"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferContent",
          "args": [
            "buf"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeTextWriter",
          "args": [
            "writer"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterWriteBinHex",
          "args": [
            "writer",
            "VARDATA_ANY(bstr)",
            "0",
            "VARSIZE_ANY_EXHDR(bstr)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "bstr"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "bstr"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterWriteBase64",
          "args": [
            "writer",
            "VARDATA_ANY(bstr)",
            "0",
            "VARSIZE_ANY_EXHDR(bstr)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "bstr"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "bstr"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_OUT_OF_MEMORY",
            "\"could not allocate xmlTextWriter\""
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewTextWriterMemory",
          "args": [
            "buf",
            "0"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferCreate",
          "args": [],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init",
          "args": [
            "PG_XML_STRICTNESS_ALL"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "991-1060",
          "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "value"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "&tm",
            "fsec",
            "true",
            "tz",
            "tzn",
            "USE_XSD_DATES",
            "buf"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "&tm",
            "&fsec",
            "&tzn",
            "NULL"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\"))"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"XML does not support infinite timestamp values.\""
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "value"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\"))"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "value"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeDateOnly",
          "args": [
            "&tm",
            "USE_XSD_DATES",
            "buf"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3872-3946",
          "snippet": "void\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "date + POSTGRES_EPOCH_JDATE",
            "&(tm.tm_year)",
            "&(tm.tm_mon)",
            "&(tm.tm_mday)"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\"))"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "date"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetDateADT",
          "args": [
            "value"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "value"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "type"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elem_nulls"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"</element>\""
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true)"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_value_to_xml_value",
          "args": [
            "elem_values[i]",
            "elmtype",
            "true"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_value_to_xml_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2120-2329",
          "snippet": "char *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"<element>\""
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "array",
            "elmtype",
            "elmlen",
            "elmbyval",
            "elmalign",
            "&elem_values",
            "&elem_nulls",
            "&num_elems"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "elmtype",
            "&elmlen",
            "&elmbyval",
            "&elmalign"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "value"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_is_array_domain",
          "args": [
            "type"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nchar *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}"
  },
  {
    "function_name": "map_xml_name_to_sql_identifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2080-2108",
    "snippet": "char *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&buf",
            "p",
            "pg_mblen(p)"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "unicode_to_sqlchar(u)"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unicode_to_sqlchar",
          "args": [
            "u"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_to_sqlchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2060-2074",
          "snippet": "static char *\nunicode_to_sqlchar(pg_wchar c)\n{\n\tchar\t\tutf8string[8];\t/* need room for trailing zero */\n\tchar\t   *result;\n\n\tmemset(utf8string, 0, sizeof(utf8string));\n\tunicode_to_utf8(c, (unsigned char *) utf8string);\n\n\tresult = pg_any_to_server(utf8string, strlen(utf8string), PG_UTF8);\n\t/* if pg_any_to_server didn't strdup, we must */\n\tif (result == utf8string)\n\t\tresult = pstrdup(result);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nunicode_to_sqlchar(pg_wchar c)\n{\n\tchar\t\tutf8string[8];\t/* need room for trailing zero */\n\tchar\t   *result;\n\n\tmemset(utf8string, 0, sizeof(utf8string));\n\tunicode_to_utf8(c, (unsigned char *) utf8string);\n\n\tresult = pg_any_to_server(utf8string, strlen(utf8string), PG_UTF8);\n\t/* if pg_any_to_server didn't strdup, we must */\n\tif (result == utf8string)\n\t\tresult = pstrdup(result);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p + 2",
            "\"%X\"",
            "&u"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) *(p + 5)"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) *(p + 4)"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) *(p + 3)"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(unsigned char) *(p + 2)"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}"
  },
  {
    "function_name": "unicode_to_sqlchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2060-2074",
    "snippet": "static char *\nunicode_to_sqlchar(pg_wchar c)\n{\n\tchar\t\tutf8string[8];\t/* need room for trailing zero */\n\tchar\t   *result;\n\n\tmemset(utf8string, 0, sizeof(utf8string));\n\tunicode_to_utf8(c, (unsigned char *) utf8string);\n\n\tresult = pg_any_to_server(utf8string, strlen(utf8string), PG_UTF8);\n\t/* if pg_any_to_server didn't strdup, we must */\n\tif (result == utf8string)\n\t\tresult = pstrdup(result);\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "result"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_any_to_server",
          "args": [
            "utf8string",
            "strlen(utf8string)",
            "PG_UTF8"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "pg_any_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "560-615",
          "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "utf8string"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_to_utf8",
          "args": [
            "c",
            "(unsigned char *) utf8string"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "474-501",
          "snippet": "unsigned char *\nunicode_to_utf8(pg_wchar c, unsigned char *utf8string)\n{\n\tif (c <= 0x7F)\n\t{\n\t\tutf8string[0] = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tutf8string[0] = 0xC0 | ((c >> 6) & 0x1F);\n\t\tutf8string[1] = 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tutf8string[0] = 0xE0 | ((c >> 12) & 0x0F);\n\t\tutf8string[1] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[2] = 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tutf8string[0] = 0xF0 | ((c >> 18) & 0x07);\n\t\tutf8string[1] = 0x80 | ((c >> 12) & 0x3F);\n\t\tutf8string[2] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[3] = 0x80 | (c & 0x3F);\n\t}\n\n\treturn utf8string;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nunsigned char *\nunicode_to_utf8(pg_wchar c, unsigned char *utf8string)\n{\n\tif (c <= 0x7F)\n\t{\n\t\tutf8string[0] = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tutf8string[0] = 0xC0 | ((c >> 6) & 0x1F);\n\t\tutf8string[1] = 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tutf8string[0] = 0xE0 | ((c >> 12) & 0x0F);\n\t\tutf8string[1] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[2] = 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tutf8string[0] = 0xF0 | ((c >> 18) & 0x07);\n\t\tutf8string[1] = 0x80 | ((c >> 12) & 0x3F);\n\t\tutf8string[2] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[3] = 0x80 | (c & 0x3F);\n\t}\n\n\treturn utf8string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utf8string",
            "0",
            "sizeof(utf8string)"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nunicode_to_sqlchar(pg_wchar c)\n{\n\tchar\t\tutf8string[8];\t/* need room for trailing zero */\n\tchar\t   *result;\n\n\tmemset(utf8string, 0, sizeof(utf8string));\n\tunicode_to_utf8(c, (unsigned char *) utf8string);\n\n\tresult = pg_any_to_server(utf8string, strlen(utf8string), PG_UTF8);\n\t/* if pg_any_to_server didn't strdup, we must */\n\tif (result == utf8string)\n\t\tresult = pstrdup(result);\n\treturn result;\n}"
  },
  {
    "function_name": "map_sql_identifier_to_xml_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "2004-2054",
    "snippet": "char *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&buf",
            "p",
            "pg_mblen(p)"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"_x%04X_\"",
            "(unsigned int) u"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_xml_namechar",
          "args": [
            "u"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_xml_namechar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1988-1997",
          "snippet": "static bool\nis_valid_xml_namechar(pg_wchar c)\n{\n\t/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| xmlIsDigitQ(c)\n\t\t\t|| c == '.' || c == '-' || c == '_' || c == ':'\n\t\t\t|| xmlIsCombiningQ(c)\n\t\t\t|| xmlIsExtenderQ(c));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nis_valid_xml_namechar(pg_wchar c)\n{\n\t/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| xmlIsDigitQ(c)\n\t\t\t|| c == '.' || c == '-' || c == '_' || c == ':'\n\t\t\t|| xmlIsCombiningQ(c)\n\t\t\t|| xmlIsExtenderQ(c));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_valid_xml_namefirst",
          "args": [
            "u"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_xml_namefirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1979-1985",
          "snippet": "static bool\nis_valid_xml_namefirst(pg_wchar c)\n{\n\t/* (Letter | '_' | ':') */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| c == '_' || c == ':');\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nis_valid_xml_namefirst(pg_wchar c)\n{\n\t/* (Letter | '_' | ':') */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| c == '_' || c == ':');\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlchar_to_unicode",
          "args": [
            "p"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "sqlchar_to_unicode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1960-1976",
          "snippet": "static pg_wchar\nsqlchar_to_unicode(const char *s)\n{\n\tchar\t   *utf8string;\n\tpg_wchar\tret[2];\t\t\t/* need space for trailing zero */\n\n\t/* note we're not assuming s is null-terminated */\n\tutf8string = pg_server_to_any(s, pg_mblen(s), PG_UTF8);\n\n\tpg_encoding_mb2wchar_with_len(PG_UTF8, utf8string, ret,\n\t\t\t\t\t\t\t\t  pg_encoding_mblen(PG_UTF8, utf8string));\n\n\tif (utf8string != s)\n\t\tpfree(utf8string);\n\n\treturn ret[0];\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic pg_wchar\nsqlchar_to_unicode(const char *s)\n{\n\tchar\t   *utf8string;\n\tpg_wchar\tret[2];\t\t\t/* need space for trailing zero */\n\n\t/* note we're not assuming s is null-terminated */\n\tutf8string = pg_server_to_any(s, pg_mblen(s), PG_UTF8);\n\n\tpg_encoding_mb2wchar_with_len(PG_UTF8, utf8string, ret,\n\t\t\t\t\t\t\t\t  pg_encoding_mblen(PG_UTF8, utf8string));\n\n\tif (utf8string != s)\n\t\tpfree(utf8string);\n\n\treturn ret[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"_x002E_\""
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"_x0058_\""
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"_x0078_\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "p",
            "\"xml\"",
            "3"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"_x005F_\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"_x003A_\""
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fully_escaped || !escape_period"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_sql_identifier_to_xml_name(const char *ident, bool fully_escaped,\n\t\t\t\t\t\t\t   bool escape_period)\n{\n#ifdef USE_LIBXML\n\tStringInfoData buf;\n\tconst char *p;\n\n\t/*\n\t * SQL/XML doesn't make use of this case anywhere, so it's probably a\n\t * mistake.\n\t */\n\tAssert(fully_escaped || !escape_period);\n\n\tinitStringInfo(&buf);\n\n\tfor (p = ident; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == ':' && (p == ident || fully_escaped))\n\t\t\tappendStringInfoString(&buf, \"_x003A_\");\n\t\telse if (*p == '_' && *(p + 1) == 'x')\n\t\t\tappendStringInfoString(&buf, \"_x005F_\");\n\t\telse if (fully_escaped && p == ident &&\n\t\t\t\t pg_strncasecmp(p, \"xml\", 3) == 0)\n\t\t{\n\t\t\tif (*p == 'x')\n\t\t\t\tappendStringInfoString(&buf, \"_x0078_\");\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, \"_x0058_\");\n\t\t}\n\t\telse if (escape_period && *p == '.')\n\t\t\tappendStringInfoString(&buf, \"_x002E_\");\n\t\telse\n\t\t{\n\t\t\tpg_wchar\tu = sqlchar_to_unicode(p);\n\n\t\t\tif ((p == ident)\n\t\t\t\t? !is_valid_xml_namefirst(u)\n\t\t\t\t: !is_valid_xml_namechar(u))\n\t\t\t\tappendStringInfo(&buf, \"_x%04X_\", (unsigned int) u);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t\t}\n\t}\n\n\treturn buf.data;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "is_valid_xml_namechar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1988-1997",
    "snippet": "static bool\nis_valid_xml_namechar(pg_wchar c)\n{\n\t/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| xmlIsDigitQ(c)\n\t\t\t|| c == '.' || c == '-' || c == '_' || c == ':'\n\t\t\t|| xmlIsCombiningQ(c)\n\t\t\t|| xmlIsExtenderQ(c));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlIsExtenderQ",
          "args": [
            "c"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlIsCombiningQ",
          "args": [
            "c"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlIsDigitQ",
          "args": [
            "c"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlIsIdeographicQ",
          "args": [
            "c"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlIsBaseCharQ",
          "args": [
            "c"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nis_valid_xml_namechar(pg_wchar c)\n{\n\t/* Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| xmlIsDigitQ(c)\n\t\t\t|| c == '.' || c == '-' || c == '_' || c == ':'\n\t\t\t|| xmlIsCombiningQ(c)\n\t\t\t|| xmlIsExtenderQ(c));\n}"
  },
  {
    "function_name": "is_valid_xml_namefirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1979-1985",
    "snippet": "static bool\nis_valid_xml_namefirst(pg_wchar c)\n{\n\t/* (Letter | '_' | ':') */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| c == '_' || c == ':');\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlIsIdeographicQ",
          "args": [
            "c"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlIsBaseCharQ",
          "args": [
            "c"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nis_valid_xml_namefirst(pg_wchar c)\n{\n\t/* (Letter | '_' | ':') */\n\treturn (xmlIsBaseCharQ(c) || xmlIsIdeographicQ(c)\n\t\t\t|| c == '_' || c == ':');\n}"
  },
  {
    "function_name": "sqlchar_to_unicode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1960-1976",
    "snippet": "static pg_wchar\nsqlchar_to_unicode(const char *s)\n{\n\tchar\t   *utf8string;\n\tpg_wchar\tret[2];\t\t\t/* need space for trailing zero */\n\n\t/* note we're not assuming s is null-terminated */\n\tutf8string = pg_server_to_any(s, pg_mblen(s), PG_UTF8);\n\n\tpg_encoding_mb2wchar_with_len(PG_UTF8, utf8string, ret,\n\t\t\t\t\t\t\t\t  pg_encoding_mblen(PG_UTF8, utf8string));\n\n\tif (utf8string != s)\n\t\tpfree(utf8string);\n\n\treturn ret[0];\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "utf8string"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_mb2wchar_with_len",
          "args": [
            "PG_UTF8",
            "utf8string",
            "ret",
            "pg_encoding_mblen(PG_UTF8, utf8string)"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "729-734",
          "snippet": "int\npg_encoding_mb2wchar_with_len(int encoding,\n\t\t\t\t\t\t\t  const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_encoding_mb2wchar_with_len(int encoding,\n\t\t\t\t\t\t\t  const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_mblen",
          "args": [
            "PG_UTF8",
            "utf8string"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1784-1790",
          "snippet": "int\npg_encoding_mblen(int encoding, const char *mbstr)\n{\n\treturn (PG_VALID_ENCODING(encoding) ?\n\t\t\tpg_wchar_table[encoding].mblen((const unsigned char *) mbstr) :\n\t\t\tpg_wchar_table[PG_SQL_ASCII].mblen((const unsigned char *) mbstr));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_encoding_mblen(int encoding, const char *mbstr)\n{\n\treturn (PG_VALID_ENCODING(encoding) ?\n\t\t\tpg_wchar_table[encoding].mblen((const unsigned char *) mbstr) :\n\t\t\tpg_wchar_table[PG_SQL_ASCII].mblen((const unsigned char *) mbstr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_server_to_any",
          "args": [
            "s",
            "pg_mblen(s)",
            "PG_UTF8"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "pg_server_to_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "633-659",
          "snippet": "char *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "s"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic pg_wchar\nsqlchar_to_unicode(const char *s)\n{\n\tchar\t   *utf8string;\n\tpg_wchar\tret[2];\t\t\t/* need space for trailing zero */\n\n\t/* note we're not assuming s is null-terminated */\n\tutf8string = pg_server_to_any(s, pg_mblen(s), PG_UTF8);\n\n\tpg_encoding_mb2wchar_with_len(PG_UTF8, utf8string, ret,\n\t\t\t\t\t\t\t\t  pg_encoding_mblen(PG_UTF8, utf8string));\n\n\tif (utf8string != s)\n\t\tpfree(utf8string);\n\n\treturn ret[0];\n}"
  },
  {
    "function_name": "appendStringInfoLineSeparator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1948-1954",
    "snippet": "static void\nappendStringInfoLineSeparator(StringInfo str)\n{\n\tchopStringInfoNewlines(str);\n\tif (str->len > 0)\n\t\tappendStringInfoChar(str, '\\n');\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "str",
            "'\\n'"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chopStringInfoNewlines",
          "args": [
            "str"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "chopStringInfoNewlines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1937-1942",
          "snippet": "static void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nappendStringInfoLineSeparator(StringInfo str)\n{\n\tchopStringInfoNewlines(str);\n\tif (str->len > 0)\n\t\tappendStringInfoChar(str, '\\n');\n}"
  },
  {
    "function_name": "chopStringInfoNewlines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1937-1942",
    "snippet": "static void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}"
  },
  {
    "function_name": "xml_ereport_by_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1896-1931",
    "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "level",
            "(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code))"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "det",
            "code"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "sqlcode"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Unrecognized libxml error code: %d.\""
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Parsing XML declaration: '?>' expected.\""
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Missing encoding in text declaration.\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Malformed declaration: missing version.\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"standalone accepts only 'yes' or 'no'.\""
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Space required.\""
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"Invalid character value.\""
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
  },
  {
    "function_name": "xml_errorHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1723-1886",
    "snippet": "static void\nxml_errorHandler(void *data, xmlErrorPtr error)\n{\n\tPgXmlErrorContext *xmlerrcxt = (PgXmlErrorContext *) data;\n\txmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) error->ctxt;\n\txmlParserInputPtr input = (ctxt != NULL) ? ctxt->input : NULL;\n\txmlNodePtr\tnode = error->node;\n\tconst xmlChar *name = (node != NULL &&\n\t\t\t\t\t\t   node->type == XML_ELEMENT_NODE) ? node->name : NULL;\n\tint\t\t\tdomain = error->domain;\n\tint\t\t\tlevel = error->level;\n\tStringInfo\terrorBuf;\n\n\t/*\n\t * Defend against someone passing us a bogus context struct.\n\t *\n\t * We force a backend exit if this check fails because longjmp'ing out of\n\t * libxml would likely render it unsafe to use further.\n\t */\n\tif (xmlerrcxt->magic != ERRCXT_MAGIC)\n\t\telog(FATAL, \"xml_errorHandler called with invalid PgXmlErrorContext\");\n\n\t/*----------\n\t * Older libxml versions report some errors differently.\n\t * First, some errors were previously reported as coming from the parser\n\t * domain but are now reported as coming from the namespace domain.\n\t * Second, some warnings were upgraded to errors.\n\t * We attempt to compensate for that here.\n\t *----------\n\t */\n\tswitch (error->code)\n\t{\n\t\tcase XML_WAR_NS_URI:\n\t\t\tlevel = XML_ERR_ERROR;\n\t\t\tdomain = XML_FROM_NAMESPACE;\n\t\t\tbreak;\n\n\t\tcase XML_ERR_NS_DECL_ERROR:\n\t\tcase XML_WAR_NS_URI_RELATIVE:\n\t\tcase XML_WAR_NS_COLUMN:\n\t\tcase XML_NS_ERR_XML_NAMESPACE:\n\t\tcase XML_NS_ERR_UNDEFINED_NAMESPACE:\n\t\tcase XML_NS_ERR_QNAME:\n\t\tcase XML_NS_ERR_ATTRIBUTE_REDEFINED:\n\t\tcase XML_NS_ERR_EMPTY:\n\t\t\tdomain = XML_FROM_NAMESPACE;\n\t\t\tbreak;\n\t}\n\n\t/* Decide whether to act on the error or not */\n\tswitch (domain)\n\t{\n\t\tcase XML_FROM_PARSER:\n\t\tcase XML_FROM_NONE:\n\t\tcase XML_FROM_MEMORY:\n\t\tcase XML_FROM_IO:\n\n\t\t\t/*\n\t\t\t * Suppress warnings about undeclared entities.  We need to do\n\t\t\t * this to avoid problems due to not loading DTD definitions.\n\t\t\t */\n\t\t\tif (error->code == XML_WAR_UNDECLARED_ENTITY)\n\t\t\t\treturn;\n\n\t\t\t/* Otherwise, accept error regardless of the parsing purpose */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Ignore error if only doing well-formedness check */\n\t\t\tif (xmlerrcxt->strictness == PG_XML_STRICTNESS_WELLFORMED)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t}\n\n\t/* Prepare error message in errorBuf */\n\terrorBuf = makeStringInfo();\n\n\tif (error->line > 0)\n\t\tappendStringInfo(errorBuf, \"line %d: \", error->line);\n\tif (name != NULL)\n\t\tappendStringInfo(errorBuf, \"element %s: \", name);\n\tif (error->message != NULL)\n\t\tappendStringInfoString(errorBuf, error->message);\n\telse\n\t\tappendStringInfoString(errorBuf, \"(no message provided)\");\n\n\t/*\n\t * Append context information to errorBuf.\n\t *\n\t * xmlParserPrintFileContext() uses libxml's \"generic\" error handler to\n\t * write the context.  Since we don't want to duplicate libxml\n\t * functionality here, we set up a generic error handler temporarily.\n\t *\n\t * We use appendStringInfo() directly as libxml's generic error handler.\n\t * This should work because it has essentially the same signature as\n\t * libxml expects, namely (void *ptr, const char *msg, ...).\n\t */\n\tif (input != NULL)\n\t{\n\t\txmlGenericErrorFunc errFuncSaved = xmlGenericError;\n\t\tvoid\t   *errCtxSaved = xmlGenericErrorContext;\n\n\t\txmlSetGenericErrorFunc((void *) errorBuf,\n\t\t\t\t\t\t\t   (xmlGenericErrorFunc) appendStringInfo);\n\n\t\t/* Add context information to errorBuf */\n\t\tappendStringInfoLineSeparator(errorBuf);\n\n\t\txmlParserPrintFileContext(input);\n\n\t\t/* Restore generic error func */\n\t\txmlSetGenericErrorFunc(errCtxSaved, errFuncSaved);\n\t}\n\n\t/* Get rid of any trailing newlines in errorBuf */\n\tchopStringInfoNewlines(errorBuf);\n\n\t/*\n\t * Legacy error handling mode.  err_occurred is never set, we just add the\n\t * message to err_buf.  This mode exists because the xml2 contrib module\n\t * uses our error-handling infrastructure, but we don't want to change its\n\t * behaviour since it's deprecated anyway.  This is also why we don't\n\t * distinguish between notices, warnings and errors here --- the old-style\n\t * generic error handler wouldn't have done that either.\n\t */\n\tif (xmlerrcxt->strictness == PG_XML_STRICTNESS_LEGACY)\n\t{\n\t\tappendStringInfoLineSeparator(&xmlerrcxt->err_buf);\n\t\tappendStringInfoString(&xmlerrcxt->err_buf, errorBuf->data);\n\n\t\tpfree(errorBuf->data);\n\t\tpfree(errorBuf);\n\t\treturn;\n\t}\n\n\t/*\n\t * We don't want to ereport() here because that'd probably leave libxml in\n\t * an inconsistent state.  Instead, we remember the error and ereport()\n\t * from xml_ereport().\n\t *\n\t * Warnings and notices can be reported immediately since they won't cause\n\t * a longjmp() out of libxml.\n\t */\n\tif (level >= XML_ERR_ERROR)\n\t{\n\t\tappendStringInfoLineSeparator(&xmlerrcxt->err_buf);\n\t\tappendStringInfoString(&xmlerrcxt->err_buf, errorBuf->data);\n\n\t\txmlerrcxt->err_occurred = true;\n\t}\n\telse if (level >= XML_ERR_WARNING)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg_internal(\"%s\", errorBuf->data)));\n\t}\n\telse\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg_internal(\"%s\", errorBuf->data)));\n\t}\n\n\tpfree(errorBuf->data);\n\tpfree(errorBuf);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRCXT_MAGIC\t68275028"
    ],
    "globals_used": [
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "errorBuf"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "NOTICE",
            "(errmsg_internal(\"%s\", errorBuf->data))"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"%s\"",
            "errorBuf->data"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errmsg_internal(\"%s\", errorBuf->data))"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&xmlerrcxt->err_buf",
            "errorBuf->data"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoLineSeparator",
          "args": [
            "&xmlerrcxt->err_buf"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoLineSeparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1948-1954",
          "snippet": "static void\nappendStringInfoLineSeparator(StringInfo str)\n{\n\tchopStringInfoNewlines(str);\n\tif (str->len > 0)\n\t\tappendStringInfoChar(str, '\\n');\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nappendStringInfoLineSeparator(StringInfo str)\n{\n\tchopStringInfoNewlines(str);\n\tif (str->len > 0)\n\t\tappendStringInfoChar(str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&xmlerrcxt->err_buf",
            "errorBuf->data"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chopStringInfoNewlines",
          "args": [
            "errorBuf"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "chopStringInfoNewlines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1937-1942",
          "snippet": "static void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nchopStringInfoNewlines(StringInfo str)\n{\n\twhile (str->len > 0 && str->data[str->len - 1] == '\\n')\n\t\tstr->data[--str->len] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlSetGenericErrorFunc",
          "args": [
            "errCtxSaved",
            "errFuncSaved"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlParserPrintFileContext",
          "args": [
            "input"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSetGenericErrorFunc",
          "args": [
            "(void *) errorBuf",
            "(xmlGenericErrorFunc) appendStringInfo"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "errorBuf",
            "\"(no message provided)\""
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "errorBuf",
            "error->message"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "errorBuf",
            "\"element %s: \"",
            "name"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "errorBuf",
            "\"line %d: \"",
            "error->line"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"xml_errorHandler called with invalid PgXmlErrorContext\""
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nstatic void\nxml_errorHandler(void *data, xmlErrorPtr error)\n{\n\tPgXmlErrorContext *xmlerrcxt = (PgXmlErrorContext *) data;\n\txmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) error->ctxt;\n\txmlParserInputPtr input = (ctxt != NULL) ? ctxt->input : NULL;\n\txmlNodePtr\tnode = error->node;\n\tconst xmlChar *name = (node != NULL &&\n\t\t\t\t\t\t   node->type == XML_ELEMENT_NODE) ? node->name : NULL;\n\tint\t\t\tdomain = error->domain;\n\tint\t\t\tlevel = error->level;\n\tStringInfo\terrorBuf;\n\n\t/*\n\t * Defend against someone passing us a bogus context struct.\n\t *\n\t * We force a backend exit if this check fails because longjmp'ing out of\n\t * libxml would likely render it unsafe to use further.\n\t */\n\tif (xmlerrcxt->magic != ERRCXT_MAGIC)\n\t\telog(FATAL, \"xml_errorHandler called with invalid PgXmlErrorContext\");\n\n\t/*----------\n\t * Older libxml versions report some errors differently.\n\t * First, some errors were previously reported as coming from the parser\n\t * domain but are now reported as coming from the namespace domain.\n\t * Second, some warnings were upgraded to errors.\n\t * We attempt to compensate for that here.\n\t *----------\n\t */\n\tswitch (error->code)\n\t{\n\t\tcase XML_WAR_NS_URI:\n\t\t\tlevel = XML_ERR_ERROR;\n\t\t\tdomain = XML_FROM_NAMESPACE;\n\t\t\tbreak;\n\n\t\tcase XML_ERR_NS_DECL_ERROR:\n\t\tcase XML_WAR_NS_URI_RELATIVE:\n\t\tcase XML_WAR_NS_COLUMN:\n\t\tcase XML_NS_ERR_XML_NAMESPACE:\n\t\tcase XML_NS_ERR_UNDEFINED_NAMESPACE:\n\t\tcase XML_NS_ERR_QNAME:\n\t\tcase XML_NS_ERR_ATTRIBUTE_REDEFINED:\n\t\tcase XML_NS_ERR_EMPTY:\n\t\t\tdomain = XML_FROM_NAMESPACE;\n\t\t\tbreak;\n\t}\n\n\t/* Decide whether to act on the error or not */\n\tswitch (domain)\n\t{\n\t\tcase XML_FROM_PARSER:\n\t\tcase XML_FROM_NONE:\n\t\tcase XML_FROM_MEMORY:\n\t\tcase XML_FROM_IO:\n\n\t\t\t/*\n\t\t\t * Suppress warnings about undeclared entities.  We need to do\n\t\t\t * this to avoid problems due to not loading DTD definitions.\n\t\t\t */\n\t\t\tif (error->code == XML_WAR_UNDECLARED_ENTITY)\n\t\t\t\treturn;\n\n\t\t\t/* Otherwise, accept error regardless of the parsing purpose */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Ignore error if only doing well-formedness check */\n\t\t\tif (xmlerrcxt->strictness == PG_XML_STRICTNESS_WELLFORMED)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t}\n\n\t/* Prepare error message in errorBuf */\n\terrorBuf = makeStringInfo();\n\n\tif (error->line > 0)\n\t\tappendStringInfo(errorBuf, \"line %d: \", error->line);\n\tif (name != NULL)\n\t\tappendStringInfo(errorBuf, \"element %s: \", name);\n\tif (error->message != NULL)\n\t\tappendStringInfoString(errorBuf, error->message);\n\telse\n\t\tappendStringInfoString(errorBuf, \"(no message provided)\");\n\n\t/*\n\t * Append context information to errorBuf.\n\t *\n\t * xmlParserPrintFileContext() uses libxml's \"generic\" error handler to\n\t * write the context.  Since we don't want to duplicate libxml\n\t * functionality here, we set up a generic error handler temporarily.\n\t *\n\t * We use appendStringInfo() directly as libxml's generic error handler.\n\t * This should work because it has essentially the same signature as\n\t * libxml expects, namely (void *ptr, const char *msg, ...).\n\t */\n\tif (input != NULL)\n\t{\n\t\txmlGenericErrorFunc errFuncSaved = xmlGenericError;\n\t\tvoid\t   *errCtxSaved = xmlGenericErrorContext;\n\n\t\txmlSetGenericErrorFunc((void *) errorBuf,\n\t\t\t\t\t\t\t   (xmlGenericErrorFunc) appendStringInfo);\n\n\t\t/* Add context information to errorBuf */\n\t\tappendStringInfoLineSeparator(errorBuf);\n\n\t\txmlParserPrintFileContext(input);\n\n\t\t/* Restore generic error func */\n\t\txmlSetGenericErrorFunc(errCtxSaved, errFuncSaved);\n\t}\n\n\t/* Get rid of any trailing newlines in errorBuf */\n\tchopStringInfoNewlines(errorBuf);\n\n\t/*\n\t * Legacy error handling mode.  err_occurred is never set, we just add the\n\t * message to err_buf.  This mode exists because the xml2 contrib module\n\t * uses our error-handling infrastructure, but we don't want to change its\n\t * behaviour since it's deprecated anyway.  This is also why we don't\n\t * distinguish between notices, warnings and errors here --- the old-style\n\t * generic error handler wouldn't have done that either.\n\t */\n\tif (xmlerrcxt->strictness == PG_XML_STRICTNESS_LEGACY)\n\t{\n\t\tappendStringInfoLineSeparator(&xmlerrcxt->err_buf);\n\t\tappendStringInfoString(&xmlerrcxt->err_buf, errorBuf->data);\n\n\t\tpfree(errorBuf->data);\n\t\tpfree(errorBuf);\n\t\treturn;\n\t}\n\n\t/*\n\t * We don't want to ereport() here because that'd probably leave libxml in\n\t * an inconsistent state.  Instead, we remember the error and ereport()\n\t * from xml_ereport().\n\t *\n\t * Warnings and notices can be reported immediately since they won't cause\n\t * a longjmp() out of libxml.\n\t */\n\tif (level >= XML_ERR_ERROR)\n\t{\n\t\tappendStringInfoLineSeparator(&xmlerrcxt->err_buf);\n\t\tappendStringInfoString(&xmlerrcxt->err_buf, errorBuf->data);\n\n\t\txmlerrcxt->err_occurred = true;\n\t}\n\telse if (level >= XML_ERR_WARNING)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errmsg_internal(\"%s\", errorBuf->data)));\n\t}\n\telse\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg_internal(\"%s\", errorBuf->data)));\n\t}\n\n\tpfree(errorBuf->data);\n\tpfree(errorBuf);\n}"
  },
  {
    "function_name": "xml_ereport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1695-1717",
    "snippet": "void\nxml_ereport(PgXmlErrorContext *errcxt, int level, int sqlcode, const char *msg)\n{\n\tchar\t   *detail;\n\n\t/* Defend against someone passing us a bogus context struct */\n\tif (errcxt->magic != ERRCXT_MAGIC)\n\t\telog(ERROR, \"xml_ereport called with invalid PgXmlErrorContext\");\n\n\t/* Flag that the current libxml error has been reported */\n\terrcxt->err_occurred = false;\n\n\t/* Include detail only if we have some text from libxml */\n\tif (errcxt->err_buf.len > 0)\n\t\tdetail = errcxt->err_buf.data;\n\telse\n\t\tdetail = NULL;\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t detail ? errdetail_internal(\"%s\", detail) : 0));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRCXT_MAGIC\t68275028"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "level",
            "(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t detail ? errdetail_internal(\"%s\", detail) : 0)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail_internal",
          "args": [
            "\"%s\"",
            "detail"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "897-912",
          "snippet": "int\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "sqlcode"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"xml_ereport called with invalid PgXmlErrorContext\""
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n\nvoid\nxml_ereport(PgXmlErrorContext *errcxt, int level, int sqlcode, const char *msg)\n{\n\tchar\t   *detail;\n\n\t/* Defend against someone passing us a bogus context struct */\n\tif (errcxt->magic != ERRCXT_MAGIC)\n\t\telog(ERROR, \"xml_ereport called with invalid PgXmlErrorContext\");\n\n\t/* Flag that the current libxml error has been reported */\n\terrcxt->err_occurred = false;\n\n\t/* Include detail only if we have some text from libxml */\n\tif (errcxt->err_buf.len > 0)\n\t\tdetail = errcxt->err_buf.data;\n\telse\n\t\tdetail = NULL;\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t detail ? errdetail_internal(\"%s\", detail) : 0));\n}"
  },
  {
    "function_name": "xmlPgEntityLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1677-1682",
    "snippet": "static xmlParserInputPtr\nxmlPgEntityLoader(const char *URL, const char *ID,\n\t\t\t\t  xmlParserCtxtPtr ctxt)\n{\n\treturn xmlNewStringInputStream(ctxt, (const xmlChar *) \"\");\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlNewStringInputStream",
          "args": [
            "ctxt",
            "(const xmlChar *) \"\""
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlParserInputPtr\nxmlPgEntityLoader(const char *URL, const char *ID,\n\t\t\t\t  xmlParserCtxtPtr ctxt)\n{\n\treturn xmlNewStringInputStream(ctxt, (const xmlChar *) \"\");\n}"
  },
  {
    "function_name": "xml_pstrdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1658-1662",
    "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "LibxmlContext",
            "string"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
  },
  {
    "function_name": "xml_pfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1649-1655",
    "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ptr"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
  },
  {
    "function_name": "xml_repalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1642-1646",
    "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "ptr",
            "size"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
  },
  {
    "function_name": "xml_palloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1635-1639",
    "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "LibxmlContext",
            "size"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
  },
  {
    "function_name": "xml_memory_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1619-1630",
    "snippet": "static void\nxml_memory_init(void)\n{\n\t/* Create memory context if not there already */\n\tif (LibxmlContext == NULL)\n\t\tLibxmlContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Libxml context\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/* Re-establish the callbacks even if already set */\n\txmlMemSetup(xml_pfree, xml_palloc, xml_repalloc, xml_pstrdup);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlMemSetup",
          "args": [
            "xml_pfree",
            "xml_palloc",
            "xml_repalloc",
            "xml_pstrdup"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopMemoryContext",
            "\"Libxml context\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_memory_init(void)\n{\n\t/* Create memory context if not there already */\n\tif (LibxmlContext == NULL)\n\t\tLibxmlContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Libxml context\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/* Re-establish the callbacks even if already set */\n\txmlMemSetup(xml_pfree, xml_palloc, xml_repalloc, xml_pstrdup);\n}"
  },
  {
    "function_name": "xml_text2xmlChar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1606-1610",
    "snippet": "static xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "in"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}"
  },
  {
    "function_name": "xml_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1483-1600",
    "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xmlerrcxt",
            "false"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "ctxt"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeParserCtxt",
          "args": [
            "ctxt"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_INVALID_XML_CONTENT",
            "\"invalid XML content\""
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlParseBalancedChunkMemory",
          "args": [
            "doc",
            "NULL",
            "NULL",
            "0",
            "utf8string + count",
            "NULL"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrdup",
          "args": [
            "(const xmlChar *) \"UTF-8\""
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "doc->encoding == NULL"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNewDoc",
          "args": [
            "version"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlCtxtReadDoc",
          "args": [
            "ctxt",
            "utf8string",
            "NULL",
            "\"UTF-8\"",
            "XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_doctype_in_content",
          "args": [
            "utf8string + count"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "xml_doctype_in_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1424-1471",
          "snippet": "static bool\nxml_doctype_in_content(const xmlChar *str)\n{\n\tconst xmlChar *p = str;\n\n\tfor (;;)\n\t{\n\t\tconst xmlChar *e;\n\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '<')\n\t\t\treturn false;\n\t\tp++;\n\n\t\tif (*p == '!')\n\t\t{\n\t\t\tp++;\n\n\t\t\t/* if we see <!DOCTYPE, we can return true */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"DOCTYPE\", 7) == 0)\n\t\t\t\treturn true;\n\n\t\t\t/* otherwise, if it's not a comment, fail */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"--\", 2) != 0)\n\t\t\t\treturn false;\n\t\t\t/* find end of comment: find -- and a > must follow */\n\t\t\tp = xmlStrstr(p + 2, (xmlChar *) \"--\");\n\t\t\tif (!p || p[2] != '>')\n\t\t\t\treturn false;\n\t\t\t/* advance over comment, and keep scanning */\n\t\t\tp += 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, if it's not a PI <?target something?>, fail */\n\t\tif (*p != '?')\n\t\t\treturn false;\n\t\tp++;\n\n\t\t/* find end of PI (the string ?> is forbidden within a PI) */\n\t\te = xmlStrstr(p, (xmlChar *) \"?>\");\n\t\tif (!e)\n\t\t\treturn false;\n\n\t\t/* advance over PI, keep scanning */\n\t\tp = e + 2;\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nxml_doctype_in_content(const xmlChar *str)\n{\n\tconst xmlChar *p = str;\n\n\tfor (;;)\n\t{\n\t\tconst xmlChar *e;\n\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '<')\n\t\t\treturn false;\n\t\tp++;\n\n\t\tif (*p == '!')\n\t\t{\n\t\t\tp++;\n\n\t\t\t/* if we see <!DOCTYPE, we can return true */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"DOCTYPE\", 7) == 0)\n\t\t\t\treturn true;\n\n\t\t\t/* otherwise, if it's not a comment, fail */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"--\", 2) != 0)\n\t\t\t\treturn false;\n\t\t\t/* find end of comment: find -- and a > must follow */\n\t\t\tp = xmlStrstr(p + 2, (xmlChar *) \"--\");\n\t\t\tif (!p || p[2] != '>')\n\t\t\t\treturn false;\n\t\t\t/* advance over comment, and keep scanning */\n\t\t\tp += 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, if it's not a PI <?target something?>, fail */\n\t\tif (*p != '?')\n\t\t\treturn false;\n\t\tp++;\n\n\t\t/* find end of PI (the string ?> is forbidden within a PI) */\n\t\te = xmlStrstr(p, (xmlChar *) \"?>\");\n\t\tif (!e)\n\t\t\treturn false;\n\n\t\t/* advance over PI, keep scanning */\n\t\tp = e + 2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "utf8string",
            "&count",
            "&version",
            "NULL",
            "&standalone"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewParserCtxt",
          "args": [],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlInitParser",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init",
          "args": [
            "PG_XML_STRICTNESS_WELLFORMED"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "991-1060",
          "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_do_encoding_conversion",
          "args": [
            "string",
            "len",
            "encoding",
            "PG_UTF8"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "pg_do_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "325-378",
          "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_text2xmlChar",
          "args": [
            "data"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "xml_text2xmlChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1606-1610",
          "snippet": "static xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "data"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
  },
  {
    "function_name": "xml_doctype_in_content",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1424-1471",
    "snippet": "static bool\nxml_doctype_in_content(const xmlChar *str)\n{\n\tconst xmlChar *p = str;\n\n\tfor (;;)\n\t{\n\t\tconst xmlChar *e;\n\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '<')\n\t\t\treturn false;\n\t\tp++;\n\n\t\tif (*p == '!')\n\t\t{\n\t\t\tp++;\n\n\t\t\t/* if we see <!DOCTYPE, we can return true */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"DOCTYPE\", 7) == 0)\n\t\t\t\treturn true;\n\n\t\t\t/* otherwise, if it's not a comment, fail */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"--\", 2) != 0)\n\t\t\t\treturn false;\n\t\t\t/* find end of comment: find -- and a > must follow */\n\t\t\tp = xmlStrstr(p + 2, (xmlChar *) \"--\");\n\t\t\tif (!p || p[2] != '>')\n\t\t\t\treturn false;\n\t\t\t/* advance over comment, and keep scanning */\n\t\t\tp += 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, if it's not a PI <?target something?>, fail */\n\t\tif (*p != '?')\n\t\t\treturn false;\n\t\tp++;\n\n\t\t/* find end of PI (the string ?> is forbidden within a PI) */\n\t\te = xmlStrstr(p, (xmlChar *) \"?>\");\n\t\tif (!e)\n\t\t\treturn false;\n\n\t\t/* advance over PI, keep scanning */\n\t\tp = e + 2;\n\t}\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlStrstr",
          "args": [
            "p",
            "(xmlChar *) \"?>\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrstr",
          "args": [
            "p + 2",
            "(xmlChar *) \"--\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"--\"",
            "2"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"DOCTYPE\"",
            "7"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic bool\nxml_doctype_in_content(const xmlChar *str)\n{\n\tconst xmlChar *p = str;\n\n\tfor (;;)\n\t{\n\t\tconst xmlChar *e;\n\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '<')\n\t\t\treturn false;\n\t\tp++;\n\n\t\tif (*p == '!')\n\t\t{\n\t\t\tp++;\n\n\t\t\t/* if we see <!DOCTYPE, we can return true */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"DOCTYPE\", 7) == 0)\n\t\t\t\treturn true;\n\n\t\t\t/* otherwise, if it's not a comment, fail */\n\t\t\tif (xmlStrncmp(p, (xmlChar *) \"--\", 2) != 0)\n\t\t\t\treturn false;\n\t\t\t/* find end of comment: find -- and a > must follow */\n\t\t\tp = xmlStrstr(p + 2, (xmlChar *) \"--\");\n\t\t\tif (!p || p[2] != '>')\n\t\t\t\treturn false;\n\t\t\t/* advance over comment, and keep scanning */\n\t\t\tp += 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, if it's not a PI <?target something?>, fail */\n\t\tif (*p != '?')\n\t\t\treturn false;\n\t\tp++;\n\n\t\t/* find end of PI (the string ?> is forbidden within a PI) */\n\t\te = xmlStrstr(p, (xmlChar *) \"?>\");\n\t\tif (!e)\n\t\t\treturn false;\n\n\t\t/* advance over PI, keep scanning */\n\t\tp = e + 2;\n\t}\n}"
  },
  {
    "function_name": "print_xml_decl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1358-1393",
    "snippet": "static bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PG_XML_DEFAULT_VERSION \"1.0\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"?>\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\" standalone=\\\"no\\\"\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\" standalone=\\\"yes\\\"\""
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" encoding=\\\"%s\\\"\"",
            "pg_encoding_to_char(encoding)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_encoding_to_char",
          "args": [
            "encoding"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_to_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "606-617",
          "snippet": "const char *\npg_encoding_to_char(int encoding)\n{\n\tif (PG_VALID_ENCODING(encoding))\n\t{\n\t\tconst pg_enc2name *p = &pg_enc2name_tbl[encoding];\n\n\t\tAssert(encoding == p->encoding);\n\t\treturn p->name;\n\t}\n\treturn \"\";\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_enc2name pg_enc2name_tbl[] =\n{\n\tDEF_ENC2NAME(SQL_ASCII, 0),\n\tDEF_ENC2NAME(EUC_JP, 20932),\n\tDEF_ENC2NAME(EUC_CN, 20936),\n\tDEF_ENC2NAME(EUC_KR, 51949),\n\tDEF_ENC2NAME(EUC_TW, 0),\n\tDEF_ENC2NAME(EUC_JIS_2004, 20932),\n\tDEF_ENC2NAME(UTF8, 65001),\n\tDEF_ENC2NAME(MULE_INTERNAL, 0),\n\tDEF_ENC2NAME(LATIN1, 28591),\n\tDEF_ENC2NAME(LATIN2, 28592),\n\tDEF_ENC2NAME(LATIN3, 28593),\n\tDEF_ENC2NAME(LATIN4, 28594),\n\tDEF_ENC2NAME(LATIN5, 28599),\n\tDEF_ENC2NAME(LATIN6, 0),\n\tDEF_ENC2NAME(LATIN7, 0),\n\tDEF_ENC2NAME(LATIN8, 0),\n\tDEF_ENC2NAME(LATIN9, 28605),\n\tDEF_ENC2NAME(LATIN10, 0),\n\tDEF_ENC2NAME(WIN1256, 1256),\n\tDEF_ENC2NAME(WIN1258, 1258),\n\tDEF_ENC2NAME(WIN866, 866),\n\tDEF_ENC2NAME(WIN874, 874),\n\tDEF_ENC2NAME(KOI8R, 20866),\n\tDEF_ENC2NAME(WIN1251, 1251),\n\tDEF_ENC2NAME(WIN1252, 1252),\n\tDEF_ENC2NAME(ISO_8859_5, 28595),\n\tDEF_ENC2NAME(ISO_8859_6, 28596),\n\tDEF_ENC2NAME(ISO_8859_7, 28597),\n\tDEF_ENC2NAME(ISO_8859_8, 28598),\n\tDEF_ENC2NAME(WIN1250, 1250),\n\tDEF_ENC2NAME(WIN1253, 1253),\n\tDEF_ENC2NAME(WIN1254, 1254),\n\tDEF_ENC2NAME(WIN1255, 1255),\n\tDEF_ENC2NAME(WIN1257, 1257),\n\tDEF_ENC2NAME(KOI8U, 21866),\n\tDEF_ENC2NAME(SJIS, 932),\n\tDEF_ENC2NAME(BIG5, 950),\n\tDEF_ENC2NAME(GBK, 936),\n\tDEF_ENC2NAME(UHC, 949),\n\tDEF_ENC2NAME(GB18030, 54936),\n\tDEF_ENC2NAME(JOHAB, 0),\n\tDEF_ENC2NAME(SHIFT_JIS_2004, 932)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_enc2name pg_enc2name_tbl[] =\n{\n\tDEF_ENC2NAME(SQL_ASCII, 0),\n\tDEF_ENC2NAME(EUC_JP, 20932),\n\tDEF_ENC2NAME(EUC_CN, 20936),\n\tDEF_ENC2NAME(EUC_KR, 51949),\n\tDEF_ENC2NAME(EUC_TW, 0),\n\tDEF_ENC2NAME(EUC_JIS_2004, 20932),\n\tDEF_ENC2NAME(UTF8, 65001),\n\tDEF_ENC2NAME(MULE_INTERNAL, 0),\n\tDEF_ENC2NAME(LATIN1, 28591),\n\tDEF_ENC2NAME(LATIN2, 28592),\n\tDEF_ENC2NAME(LATIN3, 28593),\n\tDEF_ENC2NAME(LATIN4, 28594),\n\tDEF_ENC2NAME(LATIN5, 28599),\n\tDEF_ENC2NAME(LATIN6, 0),\n\tDEF_ENC2NAME(LATIN7, 0),\n\tDEF_ENC2NAME(LATIN8, 0),\n\tDEF_ENC2NAME(LATIN9, 28605),\n\tDEF_ENC2NAME(LATIN10, 0),\n\tDEF_ENC2NAME(WIN1256, 1256),\n\tDEF_ENC2NAME(WIN1258, 1258),\n\tDEF_ENC2NAME(WIN866, 866),\n\tDEF_ENC2NAME(WIN874, 874),\n\tDEF_ENC2NAME(KOI8R, 20866),\n\tDEF_ENC2NAME(WIN1251, 1251),\n\tDEF_ENC2NAME(WIN1252, 1252),\n\tDEF_ENC2NAME(ISO_8859_5, 28595),\n\tDEF_ENC2NAME(ISO_8859_6, 28596),\n\tDEF_ENC2NAME(ISO_8859_7, 28597),\n\tDEF_ENC2NAME(ISO_8859_8, 28598),\n\tDEF_ENC2NAME(WIN1250, 1250),\n\tDEF_ENC2NAME(WIN1253, 1253),\n\tDEF_ENC2NAME(WIN1254, 1254),\n\tDEF_ENC2NAME(WIN1255, 1255),\n\tDEF_ENC2NAME(WIN1257, 1257),\n\tDEF_ENC2NAME(KOI8U, 21866),\n\tDEF_ENC2NAME(SJIS, 932),\n\tDEF_ENC2NAME(BIG5, 950),\n\tDEF_ENC2NAME(GBK, 936),\n\tDEF_ENC2NAME(UHC, 949),\n\tDEF_ENC2NAME(GB18030, 54936),\n\tDEF_ENC2NAME(JOHAB, 0),\n\tDEF_ENC2NAME(SHIFT_JIS_2004, 932)\n};\n\nconst char *\npg_encoding_to_char(int encoding)\n{\n\tif (PG_VALID_ENCODING(encoding))\n\t{\n\t\tconst pg_enc2name *p = &pg_enc2name_tbl[encoding];\n\n\t\tAssert(encoding == p->encoding);\n\t\treturn p->name;\n\t}\n\treturn \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" version=\\\"%s\\\"\"",
            "PG_XML_DEFAULT_VERSION"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" version=\\\"%s\\\"\"",
            "version"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"<?xml\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "(const char *) version",
            "PG_XML_DEFAULT_VERSION"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define PG_XML_DEFAULT_VERSION \"1.0\"\n\nstatic bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}"
  },
  {
    "function_name": "parse_xml_decl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1185-1341",
    "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"?>\"",
            "2"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"\\\"no\\\"\"",
            "4"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"'no'\"",
            "4"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"\\\"yes\\\"\"",
            "5"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"'yes'\"",
            "5"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_XML_SPACE",
          "args": [
            "save_p"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"standalone\"",
            "10"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_pnstrdup",
          "args": [
            "p + 1",
            "q - p - 1"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlStrchr",
          "args": [
            "p + 1",
            "*p"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_XML_SPACE",
          "args": [
            "save_p"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"encoding\"",
            "8"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrchr",
          "args": [
            "p + 1",
            "*p"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"version\"",
            "7"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_XML_SPACE",
          "args": [
            "p"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_XMLISNAMECHAR",
          "args": [
            "utf8char"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlGetUTF8Char",
          "args": [
            "p + 5",
            "&utf8len"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "(const char *) (p + 5)",
            "MAX_MULTIBYTE_CHAR_LEN"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrncmp",
          "args": [
            "p",
            "(xmlChar *) \"<?xml\"",
            "5"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init_library",
          "args": [],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "945-974",
          "snippet": "void\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nvoid\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
  },
  {
    "function_name": "pg_xmlCharStrndup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1167-1177",
    "snippet": "static xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "str",
            "len"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len + 1) * sizeof(xmlChar)"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\npg_xmlCharStrndup(const char *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len);\n\tresult[len] = '\\0';\n\n\treturn result;\n}"
  },
  {
    "function_name": "xml_pnstrdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1155-1164",
    "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "str",
            "len * sizeof(xmlChar)"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len + 1) * sizeof(xmlChar)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
  },
  {
    "function_name": "pg_xml_error_occurred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1120-1124",
    "snippet": "bool\npg_xml_error_occurred(PgXmlErrorContext *errcxt)\n{\n\treturn errcxt->err_occurred;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nbool\npg_xml_error_occurred(PgXmlErrorContext *errcxt)\n{\n\treturn errcxt->err_occurred;\n}"
  },
  {
    "function_name": "pg_xml_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "1072-1114",
    "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRCXT_MAGIC\t68275028",
      "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
    ],
    "globals_used": [
      "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
      "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "errcxt"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlSetExternalEntityLoader",
          "args": [
            "errcxt->saved_entityfunc"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlSetStructuredErrorFunc",
          "args": [
            "errcxt->saved_errcxt",
            "errcxt->saved_errfunc"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"libxml error handling state is out of sync with xml.c\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!errcxt->err_occurred || isError"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "errcxt->magic == ERRCXT_MAGIC"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
  },
  {
    "function_name": "pg_xml_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "991-1060",
    "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRCXT_MAGIC\t68275028",
      "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlSetExternalEntityLoader",
          "args": [
            "xmlPgEntityLoader"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlGetExternalEntityLoader",
          "args": [],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\"))"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\""
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not set up XML error handler\""
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlSetStructuredErrorFunc",
          "args": [
            "(void *) errcxt",
            "xml_errorHandler"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&errcxt->err_buf"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(PgXmlErrorContext)"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_xml_init_library",
          "args": [],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "945-974",
          "snippet": "void\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nvoid\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
  },
  {
    "function_name": "pg_xml_init_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "945-974",
    "snippet": "void\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xml_memory_init",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "xml_memory_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1619-1630",
          "snippet": "static void\nxml_memory_init(void)\n{\n\t/* Create memory context if not there already */\n\tif (LibxmlContext == NULL)\n\t\tLibxmlContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Libxml context\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/* Re-establish the callbacks even if already set */\n\txmlMemSetup(xml_pfree, xml_palloc, xml_repalloc, xml_pstrdup);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_memory_init(void)\n{\n\t/* Create memory context if not there already */\n\tif (LibxmlContext == NULL)\n\t\tLibxmlContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"Libxml context\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/* Re-establish the callbacks even if already set */\n\txmlMemSetup(xml_pfree, xml_palloc, xml_repalloc, xml_pstrdup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar)))"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\"",
            "(int) sizeof(char)",
            "(int) sizeof(xmlChar)"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not initialize XML library\""
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nvoid\npg_xml_init_library(void)\n{\n\tstatic bool first_time = true;\n\n\tif (first_time)\n\t{\n\t\t/* Stuff we need do only once per session */\n\n\t\t/*\n\t\t * Currently, we have no pure UTF-8 support for internals -- check if\n\t\t * we can work.\n\t\t */\n\t\tif (sizeof(char) != sizeof(xmlChar))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errmsg(\"could not initialize XML library\"),\n\t\t\t\t\t errdetail(\"libxml2 has incompatible char type: sizeof(char)=%u, sizeof(xmlChar)=%u.\",\n\t\t\t\t\t\t\t   (int) sizeof(char), (int) sizeof(xmlChar))));\n\n#ifdef USE_LIBXMLCONTEXT\n\t\t/* Set up libxml's memory allocation our way */\n\t\txml_memory_init();\n#endif\n\n\t\t/* Check library compatibility */\n\t\tLIBXML_TEST_VERSION;\n\n\t\tfirst_time = false;\n\t}\n}"
  },
  {
    "function_name": "xml_is_document",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "886-929",
    "snippet": "bool\nxml_is_document(xmltype *arg)\n{\n#ifdef USE_LIBXML\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\tMemoryContext ccxt = CurrentMemoryContext;\n\n\t/* We want to catch ereport(INVALID_XML_DOCUMENT) and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse((text *) arg, XMLOPTION_DOCUMENT, true,\n\t\t\t\t\t\tGetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tErrorData  *errdata;\n\t\tMemoryContext ecxt;\n\n\t\tecxt = MemoryContextSwitchTo(ccxt);\n\t\terrdata = CopyErrorData();\n\t\tif (errdata->sqlerrcode == ERRCODE_INVALID_XML_DOCUMENT)\n\t\t{\n\t\t\tFlushErrorState();\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMemoryContextSwitchTo(ecxt);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ecxt"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FlushErrorState",
          "args": [],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "FlushErrorState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1584-1597",
          "snippet": "void\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\n\nvoid\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyErrorData",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "CopyErrorData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1494-1540",
          "snippet": "ErrorData *\nCopyErrorData(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tErrorData  *newedata;\n\n\t/*\n\t * we don't increment recursion_depth because out-of-memory here does not\n\t * indicate a problem within the error subsystem.\n\t */\n\tCHECK_STACK_DEPTH();\n\n\tAssert(CurrentMemoryContext != ErrorContext);\n\n\t/* Copy the struct itself */\n\tnewedata = (ErrorData *) palloc(sizeof(ErrorData));\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Use the calling context for string allocation */\n\tnewedata->assoc_context = CurrentMemoryContext;\n\n\treturn newedata;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nErrorData *\nCopyErrorData(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tErrorData  *newedata;\n\n\t/*\n\t * we don't increment recursion_depth because out-of-memory here does not\n\t * indicate a problem within the error subsystem.\n\t */\n\tCHECK_STACK_DEPTH();\n\n\tAssert(CurrentMemoryContext != ErrorContext);\n\n\t/* Copy the struct itself */\n\tnewedata = (ErrorData *) palloc(sizeof(ErrorData));\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Use the calling context for string allocation */\n\tnewedata->assoc_context = CurrentMemoryContext;\n\n\treturn newedata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ccxt"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parse",
          "args": [
            "(text *) arg",
            "XMLOPTION_DOCUMENT",
            "true",
            "GetDatabaseEncoding()"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "xml_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1483-1600",
          "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nbool\nxml_is_document(xmltype *arg)\n{\n#ifdef USE_LIBXML\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\tMemoryContext ccxt = CurrentMemoryContext;\n\n\t/* We want to catch ereport(INVALID_XML_DOCUMENT) and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse((text *) arg, XMLOPTION_DOCUMENT, true,\n\t\t\t\t\t\tGetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tErrorData  *errdata;\n\t\tMemoryContext ecxt;\n\n\t\tecxt = MemoryContextSwitchTo(ccxt);\n\t\terrdata = CopyErrorData();\n\t\tif (errdata->sqlerrcode == ERRCODE_INVALID_XML_DOCUMENT)\n\t\t{\n\t\t\tFlushErrorState();\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMemoryContextSwitchTo(ecxt);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
  },
  {
    "function_name": "xmlvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "876-883",
    "snippet": "Datum\nxmlvalidate(PG_FUNCTION_ARGS)\n{\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"xmlvalidate is not implemented\")));\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"xmlvalidate is not implemented\"))"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"xmlvalidate is not implemented\""
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxmlvalidate(PG_FUNCTION_ARGS)\n{\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"xmlvalidate is not implemented\")));\n\treturn 0;\n}"
  },
  {
    "function_name": "xmlroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "820-865",
    "snippet": "xmltype *\nxmlroot(xmltype *data, text *version, int standalone)\n{\n#ifdef USE_LIBXML\n\tchar\t   *str;\n\tsize_t\t\tlen;\n\txmlChar    *orig_version;\n\tint\t\t\torig_standalone;\n\tStringInfoData buf;\n\n\tlen = VARSIZE(data) - VARHDRSZ;\n\tstr = text_to_cstring((text *) data);\n\n\tparse_xml_decl((xmlChar *) str, &len, &orig_version, NULL, &orig_standalone);\n\n\tif (version)\n\t\torig_version = xml_text2xmlChar(version);\n\telse\n\t\torig_version = NULL;\n\n\tswitch (standalone)\n\t{\n\t\tcase XML_STANDALONE_YES:\n\t\t\torig_standalone = 1;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_NO:\n\t\t\torig_standalone = 0;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_NO_VALUE:\n\t\t\torig_standalone = -1;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_OMITTED:\n\t\t\t/* leave original value */\n\t\t\tbreak;\n\t}\n\n\tinitStringInfo(&buf);\n\tprint_xml_decl(&buf, orig_version, 0, orig_standalone);\n\tappendStringInfoString(&buf, str + len);\n\n\treturn stringinfo_to_xmltype(&buf);\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "&buf"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "str + len"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_xml_decl",
          "args": [
            "&buf",
            "orig_version",
            "0",
            "orig_standalone"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "print_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1358-1393",
          "snippet": "static bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PG_XML_DEFAULT_VERSION \"1.0\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define PG_XML_DEFAULT_VERSION \"1.0\"\n\nstatic bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_text2xmlChar",
          "args": [
            "version"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "xml_text2xmlChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1606-1610",
          "snippet": "static xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_text2xmlChar(text *in)\n{\n\treturn (xmlChar *) text_to_cstring(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "(xmlChar *) str",
            "&len",
            "&orig_version",
            "NULL",
            "&orig_standalone"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "(text *) data"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "data"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nxmltype *\nxmlroot(xmltype *data, text *version, int standalone)\n{\n#ifdef USE_LIBXML\n\tchar\t   *str;\n\tsize_t\t\tlen;\n\txmlChar    *orig_version;\n\tint\t\t\torig_standalone;\n\tStringInfoData buf;\n\n\tlen = VARSIZE(data) - VARHDRSZ;\n\tstr = text_to_cstring((text *) data);\n\n\tparse_xml_decl((xmlChar *) str, &len, &orig_version, NULL, &orig_standalone);\n\n\tif (version)\n\t\torig_version = xml_text2xmlChar(version);\n\telse\n\t\torig_version = NULL;\n\n\tswitch (standalone)\n\t{\n\t\tcase XML_STANDALONE_YES:\n\t\t\torig_standalone = 1;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_NO:\n\t\t\torig_standalone = 0;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_NO_VALUE:\n\t\t\torig_standalone = -1;\n\t\t\tbreak;\n\t\tcase XML_STANDALONE_OMITTED:\n\t\t\t/* leave original value */\n\t\t\tbreak;\n\t}\n\n\tinitStringInfo(&buf);\n\tprint_xml_decl(&buf, orig_version, 0, orig_standalone);\n\tappendStringInfoString(&buf, str + len);\n\n\treturn stringinfo_to_xmltype(&buf);\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "xmlpi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "768-817",
    "snippet": "xmltype *\nxmlpi(const char *target, text *arg, bool arg_is_null, bool *result_is_null)\n{\n#ifdef USE_LIBXML\n\txmltype    *result;\n\tStringInfoData buf;\n\n\tif (pg_strcasecmp(target, \"xml\") == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR), /* really */\n\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t errdetail(\"XML processing instruction target name cannot be \\\"%s\\\".\", target)));\n\n\t/*\n\t * Following the SQL standard, the null check comes after the syntax check\n\t * above.\n\t */\n\t*result_is_null = arg_is_null;\n\tif (*result_is_null)\n\t\treturn NULL;\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"<?%s\", target);\n\n\tif (arg != NULL)\n\t{\n\t\tchar\t   *string;\n\n\t\tstring = text_to_cstring(arg);\n\t\tif (strstr(string, \"?>\") != NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION),\n\t\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t\t errdetail(\"XML processing instruction cannot contain \\\"?>\\\".\")));\n\n\t\tappendStringInfoChar(&buf, ' ');\n\t\tappendStringInfoString(&buf, string + strspn(string, \" \"));\n\t\tpfree(string);\n\t}\n\tappendStringInfoString(&buf, \"?>\");\n\n\tresult = stringinfo_to_xmltype(&buf);\n\tpfree(buf.data);\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf.data"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "&buf"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"?>\""
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "string + strspn(string, \" \")"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "string",
            "\" \""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "' '"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION),\n\t\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t\t errdetail(\"XML processing instruction cannot contain \\\"?>\\\".\"))"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"XML processing instruction cannot contain \\\"?>\\\".\""
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid XML processing instruction\""
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "string",
            "\"?>\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "arg"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"<?%s\"",
            "target"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR), /* really */\n\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t errdetail(\"XML processing instruction target name cannot be \\\"%s\\\".\", target))"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "target",
            "\"xml\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nxmltype *\nxmlpi(const char *target, text *arg, bool arg_is_null, bool *result_is_null)\n{\n#ifdef USE_LIBXML\n\txmltype    *result;\n\tStringInfoData buf;\n\n\tif (pg_strcasecmp(target, \"xml\") == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR), /* really */\n\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t errdetail(\"XML processing instruction target name cannot be \\\"%s\\\".\", target)));\n\n\t/*\n\t * Following the SQL standard, the null check comes after the syntax check\n\t * above.\n\t */\n\t*result_is_null = arg_is_null;\n\tif (*result_is_null)\n\t\treturn NULL;\n\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"<?%s\", target);\n\n\tif (arg != NULL)\n\t{\n\t\tchar\t   *string;\n\n\t\tstring = text_to_cstring(arg);\n\t\tif (strstr(string, \"?>\") != NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION),\n\t\t\t\t\t errmsg(\"invalid XML processing instruction\"),\n\t\t\t\t\t errdetail(\"XML processing instruction cannot contain \\\"?>\\\".\")));\n\n\t\tappendStringInfoChar(&buf, ' ');\n\t\tappendStringInfoString(&buf, string + strspn(string, \" \"));\n\t\tpfree(string);\n\t}\n\tappendStringInfoString(&buf, \"?>\");\n\n\tresult = stringinfo_to_xmltype(&buf);\n\tpfree(buf.data);\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "xmlparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "750-765",
    "snippet": "xmltype *\nxmlparse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace)\n{\n#ifdef USE_LIBXML\n\txmlDocPtr\tdoc;\n\n\tdoc = xml_parse(data, xmloption_arg, preserve_whitespace,\n\t\t\t\t\tGetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\treturn (xmltype *) data;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parse",
          "args": [
            "data",
            "xmloption_arg",
            "preserve_whitespace",
            "GetDatabaseEncoding()"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "xml_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1483-1600",
          "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nxmltype *\nxmlparse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace)\n{\n#ifdef USE_LIBXML\n\txmlDocPtr\tdoc;\n\n\tdoc = xml_parse(data, xmloption_arg, preserve_whitespace,\n\t\t\t\t\tGetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\treturn (xmltype *) data;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "xmlelement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "626-747",
    "snippet": "xmltype *\nxmlelement(XmlExpr *xexpr,\n\t\t   Datum *named_argvalue, bool *named_argnull,\n\t\t   Datum *argvalue, bool *argnull)\n{\n#ifdef USE_LIBXML\n\txmltype    *result;\n\tList\t   *named_arg_strings;\n\tList\t   *arg_strings;\n\tint\t\t\ti;\n\tListCell   *arg;\n\tListCell   *narg;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlBufferPtr buf = NULL;\n\tvolatile xmlTextWriterPtr writer = NULL;\n\n\t/*\n\t * All arguments are already evaluated, and their values are passed in the\n\t * named_argvalue/named_argnull or argvalue/argnull arrays.  This avoids\n\t * issues if one of the arguments involves a call to some other function\n\t * or subsystem that wants to use libxml on its own terms.  We examine the\n\t * original XmlExpr to identify the numbers and types of the arguments.\n\t */\n\tnamed_arg_strings = NIL;\n\ti = 0;\n\tforeach(arg, xexpr->named_args)\n\t{\n\t\tExpr\t   *e = (Expr *) lfirst(arg);\n\t\tchar\t   *str;\n\n\t\tif (named_argnull[i])\n\t\t\tstr = NULL;\n\t\telse\n\t\t\tstr = map_sql_value_to_xml_value(named_argvalue[i],\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) e),\n\t\t\t\t\t\t\t\t\t\t\t false);\n\t\tnamed_arg_strings = lappend(named_arg_strings, str);\n\t\ti++;\n\t}\n\n\targ_strings = NIL;\n\ti = 0;\n\tforeach(arg, xexpr->args)\n\t{\n\t\tExpr\t   *e = (Expr *) lfirst(arg);\n\t\tchar\t   *str;\n\n\t\t/* here we can just forget NULL elements immediately */\n\t\tif (!argnull[i])\n\t\t{\n\t\t\tstr = map_sql_value_to_xml_value(argvalue[i],\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) e),\n\t\t\t\t\t\t\t\t\t\t\t true);\n\t\t\targ_strings = lappend(arg_strings, str);\n\t\t}\n\t\ti++;\n\t}\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\tbuf = xmlBufferCreate();\n\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\txmlTextWriterStartElement(writer, (xmlChar *) xexpr->name);\n\n\t\tforboth(arg, named_arg_strings, narg, xexpr->arg_names)\n\t\t{\n\t\t\tchar\t   *str = (char *) lfirst(arg);\n\t\t\tchar\t   *argname = strVal(lfirst(narg));\n\n\t\t\tif (str)\n\t\t\t\txmlTextWriterWriteAttribute(writer,\n\t\t\t\t\t\t\t\t\t\t\t(xmlChar *) argname,\n\t\t\t\t\t\t\t\t\t\t\t(xmlChar *) str);\n\t\t}\n\n\t\tforeach(arg, arg_strings)\n\t\t{\n\t\t\tchar\t   *str = (char *) lfirst(arg);\n\n\t\t\txmlTextWriterWriteRaw(writer, (xmlChar *) str);\n\t\t}\n\n\t\txmlTextWriterEndElement(writer);\n\n\t\t/* we MUST do this now to flush data out to the buffer ... */\n\t\txmlFreeTextWriter(writer);\n\t\twriter = NULL;\n\n\t\tresult = xmlBuffer_to_xmltype(buf);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (writer)\n\t\t\txmlFreeTextWriter(writer);\n\t\tif (buf)\n\t\t\txmlBufferFree(buf);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlBufferFree(buf);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_done",
          "args": [
            "xmlerrcxt",
            "false"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1072-1114",
          "snippet": "void\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [
            "static bool XmlTableFetchRow(struct TableFuncScanState *state);",
            "static void XmlTableDestroyOpaque(struct TableFuncScanState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nstatic bool XmlTableFetchRow(struct TableFuncScanState *state);\nstatic void XmlTableDestroyOpaque(struct TableFuncScanState *state);\n\nvoid\npg_xml_done(PgXmlErrorContext *errcxt, bool isError)\n{\n\tvoid\t   *cur_errcxt;\n\n\t/* An assert seems like enough protection here */\n\tAssert(errcxt->magic == ERRCXT_MAGIC);\n\n\t/*\n\t * In a normal exit, there should be no un-handled libxml errors.  But we\n\t * shouldn't try to enforce this during error recovery, since the longjmp\n\t * could have been thrown before xml_ereport had a chance to run.\n\t */\n\tAssert(!errcxt->err_occurred || isError);\n\n\t/*\n\t * Check that libxml's global state is correct, warn if not.  This is a\n\t * real test and not an Assert because it has a higher probability of\n\t * happening.\n\t */\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tcur_errcxt = xmlStructuredErrorContext;\n#else\n\tcur_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (cur_errcxt != (void *) errcxt)\n\t\telog(WARNING, \"libxml error handling state is out of sync with xml.c\");\n\n\t/* Restore the saved handlers */\n\txmlSetStructuredErrorFunc(errcxt->saved_errcxt, errcxt->saved_errfunc);\n\txmlSetExternalEntityLoader(errcxt->saved_entityfunc);\n\n\t/*\n\t * Mark the struct as invalid, just in case somebody somehow manages to\n\t * call xml_errorHandler or xml_ereport with it.\n\t */\n\terrcxt->magic = 0;\n\n\t/* Release memory */\n\tpfree(errcxt->err_buf.data);\n\tpfree(errcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "buf"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeTextWriter",
          "args": [
            "writer"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBuffer_to_xmltype",
          "args": [
            "buf"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xmlBuffer_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "460-465",
          "snippet": "static xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeTextWriter",
          "args": [
            "writer"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterEndElement",
          "args": [
            "writer"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterWriteRaw",
          "args": [
            "writer",
            "(xmlChar *) str"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "arg"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "arg",
            "arg_strings"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterWriteAttribute",
          "args": [
            "writer",
            "(xmlChar *) argname",
            "(xmlChar *) str"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "lfirst(narg)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "narg"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "arg"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forboth",
          "args": [
            "arg",
            "named_arg_strings",
            "narg",
            "xexpr->arg_names"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlTextWriterStartElement",
          "args": [
            "writer",
            "(xmlChar *) xexpr->name"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_ereport",
          "args": [
            "xmlerrcxt",
            "ERROR",
            "ERRCODE_OUT_OF_MEMORY",
            "\"could not allocate xmlTextWriter\""
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlNewTextWriterMemory",
          "args": [
            "buf",
            "0"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferCreate",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_xml_init",
          "args": [
            "PG_XML_STRICTNESS_ALL"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "pg_xml_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "991-1060",
          "snippet": "PgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRCXT_MAGIC\t68275028",
            "#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define ERRCXT_MAGIC\t68275028\n#define HAVE_XMLSTRUCTUREDERRORCONTEXT 1\n\nPgXmlErrorContext *\npg_xml_init(PgXmlStrictness strictness)\n{\n\tPgXmlErrorContext *errcxt;\n\tvoid\t   *new_errcxt;\n\n\t/* Do one-time setup if needed */\n\tpg_xml_init_library();\n\n\t/* Create error handling context structure */\n\terrcxt = (PgXmlErrorContext *) palloc(sizeof(PgXmlErrorContext));\n\terrcxt->magic = ERRCXT_MAGIC;\n\terrcxt->strictness = strictness;\n\terrcxt->err_occurred = false;\n\tinitStringInfo(&errcxt->err_buf);\n\n\t/*\n\t * Save original error handler and install ours. libxml originally didn't\n\t * distinguish between the contexts for generic and for structured error\n\t * handlers.  If we're using an old libxml version, we must thus save the\n\t * generic error context, even though we're using a structured error\n\t * handler.\n\t */\n\terrcxt->saved_errfunc = xmlStructuredError;\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\terrcxt->saved_errcxt = xmlStructuredErrorContext;\n#else\n\terrcxt->saved_errcxt = xmlGenericErrorContext;\n#endif\n\n\txmlSetStructuredErrorFunc((void *) errcxt, xml_errorHandler);\n\n\t/*\n\t * Verify that xmlSetStructuredErrorFunc set the context variable we\n\t * expected it to.  If not, the error context pointer we just saved is not\n\t * the correct thing to restore, and since that leaves us without a way to\n\t * restore the context in pg_xml_done, we must fail.\n\t *\n\t * The only known situation in which this test fails is if we compile with\n\t * headers from a libxml2 that doesn't track the structured error context\n\t * separately (< 2.7.4), but at runtime use a version that does, or vice\n\t * versa.  The libxml2 authors did not treat that change as constituting\n\t * an ABI break, so the LIBXML_TEST_VERSION test in pg_xml_init_library\n\t * fails to protect us from this.\n\t */\n\n#ifdef HAVE_XMLSTRUCTUREDERRORCONTEXT\n\tnew_errcxt = xmlStructuredErrorContext;\n#else\n\tnew_errcxt = xmlGenericErrorContext;\n#endif\n\n\tif (new_errcxt != (void *) errcxt)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"could not set up XML error handler\"),\n\t\t\t\t errhint(\"This probably indicates that the version of libxml2\"\n\t\t\t\t\t\t \" being used is not compatible with the libxml2\"\n\t\t\t\t\t\t \" header files that PostgreSQL was built with.\")));\n\n\t/*\n\t * Also, install an entity loader to prevent unwanted fetches of external\n\t * files and URLs.\n\t */\n\terrcxt->saved_entityfunc = xmlGetExternalEntityLoader();\n\txmlSetExternalEntityLoader(xmlPgEntityLoader);\n\n\treturn errcxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "arg_strings",
            "str"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_sql_value_to_xml_value",
          "args": [
            "argvalue[i]",
            "exprType((Node *) e)",
            "true"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "map_sql_value_to_xml_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2120-2329",
          "snippet": "char *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\txmlbinary;",
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmlbinary;\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nchar *\nmap_sql_value_to_xml_value(Datum value, Oid type, bool xml_escape_strings)\n{\n\tif (type_is_array_domain(type))\n\t{\n\t\tArrayType  *array;\n\t\tOid\t\t\telmtype;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tStringInfoData buf;\n\t\tint\t\t\ti;\n\n\t\tarray = DatumGetArrayTypeP(value);\n\t\telmtype = ARR_ELEMTYPE(array);\n\t\tget_typlenbyvalalign(elmtype, &elmlen, &elmbyval, &elmalign);\n\n\t\tdeconstruct_array(array, elmtype,\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls,\n\t\t\t\t\t\t  &num_elems);\n\n\t\tinitStringInfo(&buf);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tif (elem_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tappendStringInfoString(&buf, \"<element>\");\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   map_sql_value_to_xml_value(elem_values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  elmtype, true));\n\t\t\tappendStringInfoString(&buf, \"</element>\");\n\t\t}\n\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\n\t\treturn buf.data;\n\t}\n\telse\n\t{\n\t\tOid\t\t\ttypeOut;\n\t\tbool\t\tisvarlena;\n\t\tchar\t   *str;\n\n\t\t/*\n\t\t * Flatten domains; the special-case treatments below should apply to,\n\t\t * eg, domains over boolean not just boolean.\n\t\t */\n\t\ttype = getBaseType(type);\n\n\t\t/*\n\t\t * Special XSD formatting for some data types\n\t\t */\n\t\tswitch (type)\n\t\t{\n\t\t\tcase BOOLOID:\n\t\t\t\tif (DatumGetBool(value))\n\t\t\t\t\treturn \"true\";\n\t\t\t\telse\n\t\t\t\t\treturn \"false\";\n\n\t\t\tcase DATEOID:\n\t\t\t\t{\n\t\t\t\t\tDateADT\t\tdate;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\tdate = DatumGetDateADT(value);\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"date out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite date values.\")));\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPOID:\n\t\t\t\t{\n\t\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n\t\t\tcase TIMESTAMPTZOID:\n\t\t\t\t{\n\t\t\t\t\tTimestampTz timestamp;\n\t\t\t\t\tstruct pg_tm tm;\n\t\t\t\t\tint\t\t\ttz;\n\t\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\t\tconst char *tzn = NULL;\n\t\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\n\t\t\t\t\t/* XSD doesn't support infinite values */\n\t\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"),\n\t\t\t\t\t\t\t\t errdetail(\"XML does not support infinite timestamp values.\")));\n\t\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\t\t\t\treturn pstrdup(buf);\n\t\t\t\t}\n\n#ifdef USE_LIBXML\n\t\t\tcase BYTEAOID:\n\t\t\t\t{\n\t\t\t\t\tbytea\t   *bstr = DatumGetByteaPP(value);\n\t\t\t\t\tPgXmlErrorContext *xmlerrcxt;\n\t\t\t\t\tvolatile xmlBufferPtr buf = NULL;\n\t\t\t\t\tvolatile xmlTextWriterPtr writer = NULL;\n\t\t\t\t\tchar\t   *result;\n\n\t\t\t\t\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\t\t\t\t\tPG_TRY();\n\t\t\t\t\t{\n\t\t\t\t\t\tbuf = xmlBufferCreate();\n\t\t\t\t\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\t\t\t\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\t\t\t\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\t\t\t\t\tif (xmlbinary == XMLBINARY_BASE64)\n\t\t\t\t\t\t\txmlTextWriterWriteBase64(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\txmlTextWriterWriteBinHex(writer, VARDATA_ANY(bstr),\n\t\t\t\t\t\t\t\t\t\t\t\t\t 0, VARSIZE_ANY_EXHDR(bstr));\n\n\t\t\t\t\t\t/* we MUST do this now to flush data out to the buffer */\n\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\twriter = NULL;\n\n\t\t\t\t\t\tresult = pstrdup((const char *) xmlBufferContent(buf));\n\t\t\t\t\t}\n\t\t\t\t\tPG_CATCH();\n\t\t\t\t\t{\n\t\t\t\t\t\tif (writer)\n\t\t\t\t\t\t\txmlFreeTextWriter(writer);\n\t\t\t\t\t\tif (buf)\n\t\t\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\t\t\t\t\tPG_RE_THROW();\n\t\t\t\t\t}\n\t\t\t\t\tPG_END_TRY();\n\n\t\t\t\t\txmlBufferFree(buf);\n\n\t\t\t\t\tpg_xml_done(xmlerrcxt, false);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n#endif\t\t\t\t\t\t\t/* USE_LIBXML */\n\n\t\t}\n\n\t\t/*\n\t\t * otherwise, just use the type's native text representation\n\t\t */\n\t\tgetTypeOutputInfo(type, &typeOut, &isvarlena);\n\t\tstr = OidOutputFunctionCall(typeOut, value);\n\n\t\t/* ... exactly as-is for XML, and when escaping is not wanted */\n\t\tif (type == XMLOID || !xml_escape_strings)\n\t\t\treturn str;\n\n\t\t/* otherwise, translate special characters as needed */\n\t\treturn escape_xml(str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "(Node *) e"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "arg"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "arg",
            "xexpr->args"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "named_arg_strings",
            "str"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "(Node *) e"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "arg"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "arg",
            "xexpr->named_args"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nxmltype *\nxmlelement(XmlExpr *xexpr,\n\t\t   Datum *named_argvalue, bool *named_argnull,\n\t\t   Datum *argvalue, bool *argnull)\n{\n#ifdef USE_LIBXML\n\txmltype    *result;\n\tList\t   *named_arg_strings;\n\tList\t   *arg_strings;\n\tint\t\t\ti;\n\tListCell   *arg;\n\tListCell   *narg;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlBufferPtr buf = NULL;\n\tvolatile xmlTextWriterPtr writer = NULL;\n\n\t/*\n\t * All arguments are already evaluated, and their values are passed in the\n\t * named_argvalue/named_argnull or argvalue/argnull arrays.  This avoids\n\t * issues if one of the arguments involves a call to some other function\n\t * or subsystem that wants to use libxml on its own terms.  We examine the\n\t * original XmlExpr to identify the numbers and types of the arguments.\n\t */\n\tnamed_arg_strings = NIL;\n\ti = 0;\n\tforeach(arg, xexpr->named_args)\n\t{\n\t\tExpr\t   *e = (Expr *) lfirst(arg);\n\t\tchar\t   *str;\n\n\t\tif (named_argnull[i])\n\t\t\tstr = NULL;\n\t\telse\n\t\t\tstr = map_sql_value_to_xml_value(named_argvalue[i],\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) e),\n\t\t\t\t\t\t\t\t\t\t\t false);\n\t\tnamed_arg_strings = lappend(named_arg_strings, str);\n\t\ti++;\n\t}\n\n\targ_strings = NIL;\n\ti = 0;\n\tforeach(arg, xexpr->args)\n\t{\n\t\tExpr\t   *e = (Expr *) lfirst(arg);\n\t\tchar\t   *str;\n\n\t\t/* here we can just forget NULL elements immediately */\n\t\tif (!argnull[i])\n\t\t{\n\t\t\tstr = map_sql_value_to_xml_value(argvalue[i],\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) e),\n\t\t\t\t\t\t\t\t\t\t\t true);\n\t\t\targ_strings = lappend(arg_strings, str);\n\t\t}\n\t\ti++;\n\t}\n\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_ALL);\n\n\tPG_TRY();\n\t{\n\t\tbuf = xmlBufferCreate();\n\t\tif (buf == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate xmlBuffer\");\n\t\twriter = xmlNewTextWriterMemory(buf, 0);\n\t\tif (writer == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate xmlTextWriter\");\n\n\t\txmlTextWriterStartElement(writer, (xmlChar *) xexpr->name);\n\n\t\tforboth(arg, named_arg_strings, narg, xexpr->arg_names)\n\t\t{\n\t\t\tchar\t   *str = (char *) lfirst(arg);\n\t\t\tchar\t   *argname = strVal(lfirst(narg));\n\n\t\t\tif (str)\n\t\t\t\txmlTextWriterWriteAttribute(writer,\n\t\t\t\t\t\t\t\t\t\t\t(xmlChar *) argname,\n\t\t\t\t\t\t\t\t\t\t\t(xmlChar *) str);\n\t\t}\n\n\t\tforeach(arg, arg_strings)\n\t\t{\n\t\t\tchar\t   *str = (char *) lfirst(arg);\n\n\t\t\txmlTextWriterWriteRaw(writer, (xmlChar *) str);\n\t\t}\n\n\t\txmlTextWriterEndElement(writer);\n\n\t\t/* we MUST do this now to flush data out to the buffer ... */\n\t\txmlFreeTextWriter(writer);\n\t\twriter = NULL;\n\n\t\tresult = xmlBuffer_to_xmltype(buf);\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (writer)\n\t\t\txmlFreeTextWriter(writer);\n\t\tif (buf)\n\t\t\txmlBufferFree(buf);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlBufferFree(buf);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn result;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "xmltotext_with_xmloption",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "613-623",
    "snippet": "text *\nxmltotext_with_xmloption(xmltype *data, XmlOptionType xmloption_arg)\n{\n\tif (xmloption_arg == XMLOPTION_DOCUMENT && !xml_is_document(data))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NOT_AN_XML_DOCUMENT),\n\t\t\t\t errmsg(\"not an XML document\")));\n\n\t/* It's actually binary compatible, save for the above check. */\n\treturn (text *) data;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NOT_AN_XML_DOCUMENT),\n\t\t\t\t errmsg(\"not an XML document\"))"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"not an XML document\""
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NOT_AN_XML_DOCUMENT"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml_is_document",
          "args": [
            "data"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xml_is_document",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "886-929",
          "snippet": "bool\nxml_is_document(xmltype *arg)\n{\n#ifdef USE_LIBXML\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\tMemoryContext ccxt = CurrentMemoryContext;\n\n\t/* We want to catch ereport(INVALID_XML_DOCUMENT) and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse((text *) arg, XMLOPTION_DOCUMENT, true,\n\t\t\t\t\t\tGetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tErrorData  *errdata;\n\t\tMemoryContext ecxt;\n\n\t\tecxt = MemoryContextSwitchTo(ccxt);\n\t\terrdata = CopyErrorData();\n\t\tif (errdata->sqlerrcode == ERRCODE_INVALID_XML_DOCUMENT)\n\t\t{\n\t\t\tFlushErrorState();\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMemoryContextSwitchTo(ecxt);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nbool\nxml_is_document(xmltype *arg)\n{\n#ifdef USE_LIBXML\n\tbool\t\tresult;\n\tvolatile xmlDocPtr doc = NULL;\n\tMemoryContext ccxt = CurrentMemoryContext;\n\n\t/* We want to catch ereport(INVALID_XML_DOCUMENT) and return false */\n\tPG_TRY();\n\t{\n\t\tdoc = xml_parse((text *) arg, XMLOPTION_DOCUMENT, true,\n\t\t\t\t\t\tGetDatabaseEncoding());\n\t\tresult = true;\n\t}\n\tPG_CATCH();\n\t{\n\t\tErrorData  *errdata;\n\t\tMemoryContext ecxt;\n\n\t\tecxt = MemoryContextSwitchTo(ccxt);\n\t\terrdata = CopyErrorData();\n\t\tif (errdata->sqlerrcode == ERRCODE_INVALID_XML_DOCUMENT)\n\t\t{\n\t\t\tFlushErrorState();\n\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMemoryContextSwitchTo(ecxt);\n\t\t\tPG_RE_THROW();\n\t\t}\n\t}\n\tPG_END_TRY();\n\n\tif (doc)\n\t\txmlFreeDoc(doc);\n\n\treturn result;\n#else\t\t\t\t\t\t\t/* not USE_LIBXML */\n\tNO_XML_SUPPORT();\n\treturn false;\n#endif\t\t\t\t\t\t\t/* not USE_LIBXML */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\ntext *\nxmltotext_with_xmloption(xmltype *data, XmlOptionType xmloption_arg)\n{\n\tif (xmloption_arg == XMLOPTION_DOCUMENT && !xml_is_document(data))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NOT_AN_XML_DOCUMENT),\n\t\t\t\t errmsg(\"not an XML document\")));\n\n\t/* It's actually binary compatible, save for the above check. */\n\treturn (text *) data;\n}"
  },
  {
    "function_name": "xmltotext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "603-610",
    "snippet": "Datum\nxmltotext(PG_FUNCTION_ARGS)\n{\n\txmltype    *data = PG_GETARG_XML_P(0);\n\n\t/* It's actually binary compatible. */\n\tPG_RETURN_TEXT_P((text *) data);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "(text *) data"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxmltotext(PG_FUNCTION_ARGS)\n{\n\txmltype    *data = PG_GETARG_XML_P(0);\n\n\t/* It's actually binary compatible. */\n\tPG_RETURN_TEXT_P((text *) data);\n}"
  },
  {
    "function_name": "texttoxml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "594-600",
    "snippet": "Datum\ntexttoxml(PG_FUNCTION_ARGS)\n{\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_XML_P(xmlparse(data, xmloption, true));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmloption;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "xmlparse(data, xmloption, true)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlparse",
          "args": [
            "data",
            "xmloption",
            "true"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xmlparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "750-765",
          "snippet": "xmltype *\nxmlparse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace)\n{\n#ifdef USE_LIBXML\n\txmlDocPtr\tdoc;\n\n\tdoc = xml_parse(data, xmloption_arg, preserve_whitespace,\n\t\t\t\t\tGetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\treturn (xmltype *) data;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nxmltype *\nxmlparse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace)\n{\n#ifdef USE_LIBXML\n\txmlDocPtr\tdoc;\n\n\tdoc = xml_parse(data, xmloption_arg, preserve_whitespace,\n\t\t\t\t\tGetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\treturn (xmltype *) data;\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmloption;\n\nDatum\ntexttoxml(PG_FUNCTION_ARGS)\n{\n\ttext\t   *data = PG_GETARG_TEXT_PP(0);\n\n\tPG_RETURN_XML_P(xmlparse(data, xmloption, true));\n}"
  },
  {
    "function_name": "xmlconcat2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "576-591",
    "snippet": "Datum\nxmlconcat2(PG_FUNCTION_ARGS)\n{\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tif (PG_ARGISNULL(1))\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(1));\n\t}\n\telse if (PG_ARGISNULL(1))\n\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(0));\n\telse\n\t\tPG_RETURN_XML_P(xmlconcat(list_make2(PG_GETARG_XML_P(0),\n\t\t\t\t\t\t\t\t\t\t\t PG_GETARG_XML_P(1))));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "xmlconcat(list_make2(PG_GETARG_XML_P(0),\n\t\t\t\t\t\t\t\t\t\t\t PG_GETARG_XML_P(1)))"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlconcat",
          "args": [
            "list_make2(PG_GETARG_XML_P(0),\n\t\t\t\t\t\t\t\t\t\t\t PG_GETARG_XML_P(1))"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xmlconcat2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "576-591",
          "snippet": "Datum\nxmlconcat2(PG_FUNCTION_ARGS)\n{\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tif (PG_ARGISNULL(1))\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(1));\n\t}\n\telse if (PG_ARGISNULL(1))\n\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(0));\n\telse\n\t\tPG_RETURN_XML_P(xmlconcat(list_make2(PG_GETARG_XML_P(0),\n\t\t\t\t\t\t\t\t\t\t\t PG_GETARG_XML_P(1))));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "PG_GETARG_XML_P(0)",
            "PG_GETARG_XML_P(1)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "PG_GETARG_XML_P(0)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "0"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "PG_GETARG_XML_P(1)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "1"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxmlconcat2(PG_FUNCTION_ARGS)\n{\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tif (PG_ARGISNULL(1))\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(1));\n\t}\n\telse if (PG_ARGISNULL(1))\n\t\tPG_RETURN_XML_P(PG_GETARG_XML_P(0));\n\telse\n\t\tPG_RETURN_XML_P(xmlconcat(list_make2(PG_GETARG_XML_P(0),\n\t\t\t\t\t\t\t\t\t\t\t PG_GETARG_XML_P(1))));\n}"
  },
  {
    "function_name": "xmlconcat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "510-570",
    "snippet": "xmltype *\nxmlconcat(List *args)\n{\n#ifdef USE_LIBXML\n\tint\t\t\tglobal_standalone = 1;\n\txmlChar    *global_version = NULL;\n\tbool\t\tglobal_version_no_value = false;\n\tStringInfoData buf;\n\tListCell   *v;\n\n\tinitStringInfo(&buf);\n\tforeach(v, args)\n\t{\n\t\txmltype    *x = DatumGetXmlP(PointerGetDatum(lfirst(v)));\n\t\tsize_t\t\tlen;\n\t\txmlChar    *version;\n\t\tint\t\t\tstandalone;\n\t\tchar\t   *str;\n\n\t\tlen = VARSIZE(x) - VARHDRSZ;\n\t\tstr = text_to_cstring((text *) x);\n\n\t\tparse_xml_decl((xmlChar *) str, &len, &version, NULL, &standalone);\n\n\t\tif (standalone == 0 && global_standalone == 1)\n\t\t\tglobal_standalone = 0;\n\t\tif (standalone < 0)\n\t\t\tglobal_standalone = -1;\n\n\t\tif (!version)\n\t\t\tglobal_version_no_value = true;\n\t\telse if (!global_version)\n\t\t\tglobal_version = version;\n\t\telse if (xmlStrcmp(version, global_version) != 0)\n\t\t\tglobal_version_no_value = true;\n\n\t\tappendStringInfoString(&buf, str + len);\n\t\tpfree(str);\n\t}\n\n\tif (!global_version_no_value || global_standalone >= 0)\n\t{\n\t\tStringInfoData buf2;\n\n\t\tinitStringInfo(&buf2);\n\n\t\tprint_xml_decl(&buf2,\n\t\t\t\t\t   (!global_version_no_value) ? global_version : NULL,\n\t\t\t\t\t   0,\n\t\t\t\t\t   global_standalone);\n\n\t\tappendStringInfoString(&buf2, buf.data);\n\t\tbuf = buf2;\n\t}\n\n\treturn stringinfo_to_xmltype(&buf);\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "&buf"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf2",
            "buf.data"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_xml_decl",
          "args": [
            "&buf2",
            "(!global_version_no_value) ? global_version : NULL",
            "0",
            "global_standalone"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "print_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1358-1393",
          "snippet": "static bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PG_XML_DEFAULT_VERSION \"1.0\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define PG_XML_DEFAULT_VERSION \"1.0\"\n\nstatic bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf2"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "str + len"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlStrcmp",
          "args": [
            "version",
            "global_version"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "(xmlChar *) str",
            "&len",
            "&version",
            "NULL",
            "&standalone"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "(text *) x"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "x"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetXmlP",
          "args": [
            "PointerGetDatum(lfirst(v))"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "lfirst(v)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "v"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "v",
            "args"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nxmltype *\nxmlconcat(List *args)\n{\n#ifdef USE_LIBXML\n\tint\t\t\tglobal_standalone = 1;\n\txmlChar    *global_version = NULL;\n\tbool\t\tglobal_version_no_value = false;\n\tStringInfoData buf;\n\tListCell   *v;\n\n\tinitStringInfo(&buf);\n\tforeach(v, args)\n\t{\n\t\txmltype    *x = DatumGetXmlP(PointerGetDatum(lfirst(v)));\n\t\tsize_t\t\tlen;\n\t\txmlChar    *version;\n\t\tint\t\t\tstandalone;\n\t\tchar\t   *str;\n\n\t\tlen = VARSIZE(x) - VARHDRSZ;\n\t\tstr = text_to_cstring((text *) x);\n\n\t\tparse_xml_decl((xmlChar *) str, &len, &version, NULL, &standalone);\n\n\t\tif (standalone == 0 && global_standalone == 1)\n\t\t\tglobal_standalone = 0;\n\t\tif (standalone < 0)\n\t\t\tglobal_standalone = -1;\n\n\t\tif (!version)\n\t\t\tglobal_version_no_value = true;\n\t\telse if (!global_version)\n\t\t\tglobal_version = version;\n\t\telse if (xmlStrcmp(version, global_version) != 0)\n\t\t\tglobal_version_no_value = true;\n\n\t\tappendStringInfoString(&buf, str + len);\n\t\tpfree(str);\n\t}\n\n\tif (!global_version_no_value || global_standalone >= 0)\n\t{\n\t\tStringInfoData buf2;\n\n\t\tinitStringInfo(&buf2);\n\n\t\tprint_xml_decl(&buf2,\n\t\t\t\t\t   (!global_version_no_value) ? global_version : NULL,\n\t\t\t\t\t   0,\n\t\t\t\t\t   global_standalone);\n\n\t\tappendStringInfoString(&buf2, buf.data);\n\t\tbuf = buf2;\n\t}\n\n\treturn stringinfo_to_xmltype(&buf);\n#else\n\tNO_XML_SUPPORT();\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "xmlcomment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "469-502",
    "snippet": "Datum\nxmlcomment(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *arg = PG_GETARG_TEXT_PP(0);\n\tchar\t   *argdata = VARDATA_ANY(arg);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(arg);\n\tStringInfoData buf;\n\tint\t\t\ti;\n\n\t/* check for \"--\" in string or \"-\" at the end */\n\tfor (i = 1; i < len; i++)\n\t{\n\t\tif (argdata[i] == '-' && argdata[i - 1] == '-')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t\t errmsg(\"invalid XML comment\")));\n\t}\n\tif (len > 0 && argdata[len - 1] == '-')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t errmsg(\"invalid XML comment\")));\n\n\tinitStringInfo(&buf);\n\tappendStringInfoString(&buf, \"<!--\");\n\tappendStringInfoText(&buf, arg);\n\tappendStringInfoString(&buf, \"-->\");\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(&buf));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "stringinfo_to_xmltype(&buf)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringinfo_to_xmltype",
          "args": [
            "&buf"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "stringinfo_to_xmltype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "445-449",
          "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"-->\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoText",
          "args": [
            "&buf",
            "arg"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "437-441",
          "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"<!--\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t errmsg(\"invalid XML comment\"))"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid XML comment\""
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_XML_COMMENT"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t\t errmsg(\"invalid XML comment\"))"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxmlcomment(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\ttext\t   *arg = PG_GETARG_TEXT_PP(0);\n\tchar\t   *argdata = VARDATA_ANY(arg);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(arg);\n\tStringInfoData buf;\n\tint\t\t\ti;\n\n\t/* check for \"--\" in string or \"-\" at the end */\n\tfor (i = 1; i < len; i++)\n\t{\n\t\tif (argdata[i] == '-' && argdata[i - 1] == '-')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t\t errmsg(\"invalid XML comment\")));\n\t}\n\tif (len > 0 && argdata[len - 1] == '-')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_XML_COMMENT),\n\t\t\t\t errmsg(\"invalid XML comment\")));\n\n\tinitStringInfo(&buf);\n\tappendStringInfoString(&buf, \"<!--\");\n\tappendStringInfoText(&buf, arg);\n\tappendStringInfoString(&buf, \"-->\");\n\n\tPG_RETURN_XML_P(stringinfo_to_xmltype(&buf));\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xmlBuffer_to_xmltype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "460-465",
    "snippet": "static xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "(const char *) xmlBufferContent(buf)",
            "xmlBufferLength(buf)"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlBufferLength",
          "args": [
            "buf"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferContent",
          "args": [
            "buf"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nxmlBuffer_to_xmltype(xmlBufferPtr buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len((const char *) xmlBufferContent(buf),\n\t\t\t\t\t\t\t\t\t\t\t\txmlBufferLength(buf));\n}"
  },
  {
    "function_name": "cstring_to_xmltype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "452-456",
    "snippet": "static xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "string"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\ncstring_to_xmltype(const char *string)\n{\n\treturn (xmltype *) cstring_to_text(string);\n}"
  },
  {
    "function_name": "stringinfo_to_xmltype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "445-449",
    "snippet": "static xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "buf->data",
            "buf->len"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmltype *\nstringinfo_to_xmltype(StringInfo buf)\n{\n\treturn (xmltype *) cstring_to_text_with_len(buf->data, buf->len);\n}"
  },
  {
    "function_name": "appendStringInfoText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "437-441",
    "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "str",
            "VARDATA_ANY(t)",
            "VARSIZE_ANY_EXHDR(t)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
  },
  {
    "function_name": "xml_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "416-433",
    "snippet": "Datum\nxml_send(PG_FUNCTION_ARGS)\n{\n\txmltype    *x = PG_GETARG_XML_P(0);\n\tchar\t   *outval;\n\tStringInfoData buf;\n\n\t/*\n\t * xml_out_internal doesn't convert the encoding, it just prints the right\n\t * declaration. pq_sendtext will do the conversion.\n\t */\n\toutval = xml_out_internal(x, pg_get_client_encoding());\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, outval, strlen(outval));\n\tpfree(outval);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "outval"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "outval",
            "strlen(outval)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "outval"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_out_internal",
          "args": [
            "x",
            "pg_get_client_encoding()"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "xml_out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "291-331",
          "snippet": "static char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_get_client_encoding",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_client_encoding_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "314-318",
          "snippet": "const char *\npg_get_client_encoding_name(void)\n{\n\treturn ClientEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\npg_get_client_encoding_name(void)\n{\n\treturn ClientEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "0"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxml_send(PG_FUNCTION_ARGS)\n{\n\txmltype    *x = PG_GETARG_XML_P(0);\n\tchar\t   *outval;\n\tStringInfoData buf;\n\n\t/*\n\t * xml_out_internal doesn't convert the encoding, it just prints the right\n\t * declaration. pq_sendtext will do the conversion.\n\t */\n\toutval = xml_out_internal(x, pg_get_client_encoding());\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, outval, strlen(outval));\n\tpfree(outval);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "xml_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "349-413",
    "snippet": "Datum\nxml_recv(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\txmltype    *result;\n\tchar\t   *str;\n\tchar\t   *newstr;\n\tint\t\t\tnbytes;\n\txmlDocPtr\tdoc;\n\txmlChar    *encodingStr = NULL;\n\tint\t\t\tencoding;\n\n\t/*\n\t * Read the data in raw format. We don't know yet what the encoding is, as\n\t * that information is embedded in the xml declaration; so we have to\n\t * parse that before converting to server encoding.\n\t */\n\tnbytes = buf->len - buf->cursor;\n\tstr = (char *) pq_getmsgbytes(buf, nbytes);\n\n\t/*\n\t * We need a null-terminated string to pass to parse_xml_decl().  Rather\n\t * than make a separate copy, make the temporary result one byte bigger\n\t * than it needs to be.\n\t */\n\tresult = palloc(nbytes + 1 + VARHDRSZ);\n\tSET_VARSIZE(result, nbytes + VARHDRSZ);\n\tmemcpy(VARDATA(result), str, nbytes);\n\tstr = VARDATA(result);\n\tstr[nbytes] = '\\0';\n\n\tparse_xml_decl((const xmlChar *) str, NULL, NULL, &encodingStr, NULL);\n\n\t/*\n\t * If encoding wasn't explicitly specified in the XML header, treat it as\n\t * UTF-8, as that's the default in XML. This is different from xml_in(),\n\t * where the input has to go through the normal client to server encoding\n\t * conversion.\n\t */\n\tencoding = encodingStr ? xmlChar_to_encoding(encodingStr) : PG_UTF8;\n\n\t/*\n\t * Parse the data to check if it is well-formed XML data.  Assume that\n\t * xml_parse will throw ERROR if not.\n\t */\n\tdoc = xml_parse(result, xmloption, true, encoding);\n\txmlFreeDoc(doc);\n\n\t/* Now that we know what we're dealing with, convert to server encoding */\n\tnewstr = pg_any_to_server(str, nbytes, encoding);\n\n\tif (newstr != str)\n\t{\n\t\tpfree(result);\n\t\tresult = (xmltype *) cstring_to_text(newstr);\n\t\tpfree(newstr);\n\t}\n\n\tPG_RETURN_XML_P(result);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmloption;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "result"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "newstr"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "newstr"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_any_to_server",
          "args": [
            "str",
            "nbytes",
            "encoding"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "pg_any_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "560-615",
          "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parse",
          "args": [
            "result",
            "xmloption",
            "true",
            "encoding"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "xml_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1483-1600",
          "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlChar_to_encoding",
          "args": [
            "encodingStr"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xmlChar_to_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "234-245",
          "snippet": "static int\nxmlChar_to_encoding(const xmlChar *encoding_name)\n{\n\tint\t\t\tencoding = pg_char_to_encoding((const char *) encoding_name);\n\n\tif (encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\t(const char *) encoding_name)));\n\treturn encoding;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic int\nxmlChar_to_encoding(const xmlChar *encoding_name)\n{\n\tint\t\t\tencoding = pg_char_to_encoding((const char *) encoding_name);\n\n\tif (encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\t(const char *) encoding_name)));\n\treturn encoding;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "(const xmlChar *) str",
            "NULL",
            "NULL",
            "&encodingStr",
            "NULL"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(result)",
            "str",
            "nbytes"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes + VARHDRSZ"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nbytes + 1 + VARHDRSZ"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgbytes",
          "args": [
            "buf",
            "nbytes"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmloption;\n\nDatum\nxml_recv(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\txmltype    *result;\n\tchar\t   *str;\n\tchar\t   *newstr;\n\tint\t\t\tnbytes;\n\txmlDocPtr\tdoc;\n\txmlChar    *encodingStr = NULL;\n\tint\t\t\tencoding;\n\n\t/*\n\t * Read the data in raw format. We don't know yet what the encoding is, as\n\t * that information is embedded in the xml declaration; so we have to\n\t * parse that before converting to server encoding.\n\t */\n\tnbytes = buf->len - buf->cursor;\n\tstr = (char *) pq_getmsgbytes(buf, nbytes);\n\n\t/*\n\t * We need a null-terminated string to pass to parse_xml_decl().  Rather\n\t * than make a separate copy, make the temporary result one byte bigger\n\t * than it needs to be.\n\t */\n\tresult = palloc(nbytes + 1 + VARHDRSZ);\n\tSET_VARSIZE(result, nbytes + VARHDRSZ);\n\tmemcpy(VARDATA(result), str, nbytes);\n\tstr = VARDATA(result);\n\tstr[nbytes] = '\\0';\n\n\tparse_xml_decl((const xmlChar *) str, NULL, NULL, &encodingStr, NULL);\n\n\t/*\n\t * If encoding wasn't explicitly specified in the XML header, treat it as\n\t * UTF-8, as that's the default in XML. This is different from xml_in(),\n\t * where the input has to go through the normal client to server encoding\n\t * conversion.\n\t */\n\tencoding = encodingStr ? xmlChar_to_encoding(encodingStr) : PG_UTF8;\n\n\t/*\n\t * Parse the data to check if it is well-formed XML data.  Assume that\n\t * xml_parse will throw ERROR if not.\n\t */\n\tdoc = xml_parse(result, xmloption, true, encoding);\n\txmlFreeDoc(doc);\n\n\t/* Now that we know what we're dealing with, convert to server encoding */\n\tnewstr = pg_any_to_server(str, nbytes, encoding);\n\n\tif (newstr != str)\n\t{\n\t\tpfree(result);\n\t\tresult = (xmltype *) cstring_to_text(newstr);\n\t\tpfree(newstr);\n\t}\n\n\tPG_RETURN_XML_P(result);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xml_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "334-346",
    "snippet": "Datum\nxml_out(PG_FUNCTION_ARGS)\n{\n\txmltype    *x = PG_GETARG_XML_P(0);\n\n\t/*\n\t * xml_out removes the encoding property in all cases.  This is because we\n\t * cannot control from here whether the datum will be converted to a\n\t * different client encoding, so we'd do more harm than good by including\n\t * it.\n\t */\n\tPG_RETURN_CSTRING(xml_out_internal(x, 0));\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "xml_out_internal(x, 0)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_out_internal",
          "args": [
            "x",
            "0"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "xml_out_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "291-331",
          "snippet": "static char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_XML_P",
          "args": [
            "0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nDatum\nxml_out(PG_FUNCTION_ARGS)\n{\n\txmltype    *x = PG_GETARG_XML_P(0);\n\n\t/*\n\t * xml_out removes the encoding property in all cases.  This is because we\n\t * cannot control from here whether the datum will be converted to a\n\t * different client encoding, so we'd do more harm than good by including\n\t * it.\n\t */\n\tPG_RETURN_CSTRING(xml_out_internal(x, 0));\n}"
  },
  {
    "function_name": "xml_out_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "291-331",
    "snippet": "static char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xml_ereport_by_code",
          "args": [
            "WARNING",
            "ERRCODE_INTERNAL_ERROR",
            "\"could not parse XML declaration in stored value\"",
            "res_code"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xml_ereport_by_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1896-1931",
          "snippet": "static void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic void\nxml_ereport_by_code(int level, int sqlcode,\n\t\t\t\t\tconst char *msg, int code)\n{\n\tconst char *det;\n\n\tswitch (code)\n\t{\n\t\tcase XML_ERR_INVALID_CHAR:\n\t\t\tdet = gettext_noop(\"Invalid character value.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_SPACE_REQUIRED:\n\t\t\tdet = gettext_noop(\"Space required.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_STANDALONE_VALUE:\n\t\t\tdet = gettext_noop(\"standalone accepts only 'yes' or 'no'.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_VERSION_MISSING:\n\t\t\tdet = gettext_noop(\"Malformed declaration: missing version.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_MISSING_ENCODING:\n\t\t\tdet = gettext_noop(\"Missing encoding in text declaration.\");\n\t\t\tbreak;\n\t\tcase XML_ERR_XMLDECL_NOT_FINISHED:\n\t\t\tdet = gettext_noop(\"Parsing XML declaration: '?>' expected.\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdet = gettext_noop(\"Unrecognized libxml error code: %d.\");\n\t\t\tbreak;\n\t}\n\n\tereport(level,\n\t\t\t(errcode(sqlcode),\n\t\t\t errmsg_internal(\"%s\", msg),\n\t\t\t errdetail(det, code)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "str + len"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_xml_decl",
          "args": [
            "&buf",
            "version",
            "target_encoding",
            "standalone"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "print_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1358-1393",
          "snippet": "static bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PG_XML_DEFAULT_VERSION \"1.0\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\n#define PG_XML_DEFAULT_VERSION \"1.0\"\n\nstatic bool\nprint_xml_decl(StringInfo buf, const xmlChar *version,\n\t\t\t   pg_enc encoding, int standalone)\n{\n\tif ((version && strcmp((const char *) version, PG_XML_DEFAULT_VERSION) != 0)\n\t\t|| (encoding && encoding != PG_UTF8)\n\t\t|| standalone != -1)\n\t{\n\t\tappendStringInfoString(buf, \"<?xml\");\n\n\t\tif (version)\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", version);\n\t\telse\n\t\t\tappendStringInfo(buf, \" version=\\\"%s\\\"\", PG_XML_DEFAULT_VERSION);\n\n\t\tif (encoding && encoding != PG_UTF8)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX might be useful to convert this to IANA names (ISO-8859-1\n\t\t\t * instead of LATIN1 etc.); needs field experience\n\t\t\t */\n\t\t\tappendStringInfo(buf, \" encoding=\\\"%s\\\"\",\n\t\t\t\t\t\t\t pg_encoding_to_char(encoding));\n\t\t}\n\n\t\tif (standalone == 1)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"yes\\\"\");\n\t\telse if (standalone == 0)\n\t\t\tappendStringInfoString(buf, \" standalone=\\\"no\\\"\");\n\t\tappendStringInfoString(buf, \"?>\");\n\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_xml_decl",
          "args": [
            "(xmlChar *) str",
            "&len",
            "&version",
            "NULL",
            "&standalone"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "parse_xml_decl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1185-1341",
          "snippet": "static int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic int\nparse_xml_decl(const xmlChar *str, size_t *lenp,\n\t\t\t   xmlChar **version, xmlChar **encoding, int *standalone)\n{\n\tconst xmlChar *p;\n\tconst xmlChar *save_p;\n\tsize_t\t\tlen;\n\tint\t\t\tutf8char;\n\tint\t\t\tutf8len;\n\n\t/*\n\t * Only initialize libxml.  We don't need error handling here, but we do\n\t * need to make sure libxml is initialized before calling any of its\n\t * functions.  Note that this is safe (and a no-op) if caller has already\n\t * done pg_xml_init().\n\t */\n\tpg_xml_init_library();\n\n\t/* Initialize output arguments to \"not present\" */\n\tif (version)\n\t\t*version = NULL;\n\tif (encoding)\n\t\t*encoding = NULL;\n\tif (standalone)\n\t\t*standalone = -1;\n\n\tp = str;\n\n\tif (xmlStrncmp(p, (xmlChar *) \"<?xml\", 5) != 0)\n\t\tgoto finished;\n\n\t/*\n\t * If next char is a name char, it's a PI like <?xml-stylesheet ...?>\n\t * rather than an XMLDecl, so we have done what we came to do and found no\n\t * XMLDecl.\n\t *\n\t * We need an input length value for xmlGetUTF8Char, but there's no need\n\t * to count the whole document size, so use strnlen not strlen.\n\t */\n\tutf8len = strnlen((const char *) (p + 5), MAX_MULTIBYTE_CHAR_LEN);\n\tutf8char = xmlGetUTF8Char(p + 5, &utf8len);\n\tif (PG_XMLISNAMECHAR(utf8char))\n\t\tgoto finished;\n\n\tp += 5;\n\n\t/* version */\n\tCHECK_XML_SPACE(p);\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"version\", 7) != 0)\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 7;\n\tSKIP_XML_SPACE(p);\n\tif (*p != '=')\n\t\treturn XML_ERR_VERSION_MISSING;\n\tp += 1;\n\tSKIP_XML_SPACE(p);\n\n\tif (*p == '\\'' || *p == '\"')\n\t{\n\t\tconst xmlChar *q;\n\n\t\tq = xmlStrchr(p + 1, *p);\n\t\tif (!q)\n\t\t\treturn XML_ERR_VERSION_MISSING;\n\n\t\tif (version)\n\t\t\t*version = xml_pnstrdup(p + 1, q - p - 1);\n\t\tp = q + 1;\n\t}\n\telse\n\t\treturn XML_ERR_VERSION_MISSING;\n\n\t/* encoding */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"encoding\", 8) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 8;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\n\t\tif (*p == '\\'' || *p == '\"')\n\t\t{\n\t\t\tconst xmlChar *q;\n\n\t\t\tq = xmlStrchr(p + 1, *p);\n\t\t\tif (!q)\n\t\t\t\treturn XML_ERR_MISSING_ENCODING;\n\n\t\t\tif (encoding)\n\t\t\t\t*encoding = xml_pnstrdup(p + 1, q - p - 1);\n\t\t\tp = q + 1;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_MISSING_ENCODING;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\t/* standalone */\n\tsave_p = p;\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"standalone\", 10) == 0)\n\t{\n\t\tCHECK_XML_SPACE(save_p);\n\t\tp += 10;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (*p != '=')\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t\tp += 1;\n\t\tSKIP_XML_SPACE(p);\n\t\tif (xmlStrncmp(p, (xmlChar *) \"'yes'\", 5) == 0 ||\n\t\t\txmlStrncmp(p, (xmlChar *) \"\\\"yes\\\"\", 5) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 1;\n\t\t\tp += 5;\n\t\t}\n\t\telse if (xmlStrncmp(p, (xmlChar *) \"'no'\", 4) == 0 ||\n\t\t\t\t xmlStrncmp(p, (xmlChar *) \"\\\"no\\\"\", 4) == 0)\n\t\t{\n\t\t\tif (standalone)\n\t\t\t\t*standalone = 0;\n\t\t\tp += 4;\n\t\t}\n\t\telse\n\t\t\treturn XML_ERR_STANDALONE_VALUE;\n\t}\n\telse\n\t{\n\t\tp = save_p;\n\t}\n\n\tSKIP_XML_SPACE(p);\n\tif (xmlStrncmp(p, (xmlChar *) \"?>\", 2) != 0)\n\t\treturn XML_ERR_XMLDECL_NOT_FINISHED;\n\tp += 2;\n\nfinished:\n\tlen = p - str;\n\n\tfor (p = str; p < str + len; p++)\n\t\tif (*p > 127)\n\t\t\treturn XML_ERR_INVALID_CHAR;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn XML_ERR_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "(text *) x"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void XmlTableSetDocument(struct TableFuncScanState *state, Datum value);\n\nstatic char *\nxml_out_internal(xmltype *x, pg_enc target_encoding)\n{\n\tchar\t   *str = text_to_cstring((text *) x);\n\n#ifdef USE_LIBXML\n\tsize_t\t\tlen = strlen(str);\n\txmlChar    *version;\n\tint\t\t\tstandalone;\n\tint\t\t\tres_code;\n\n\tif ((res_code = parse_xml_decl((xmlChar *) str,\n\t\t\t\t\t\t\t\t   &len, &version, NULL, &standalone)) == 0)\n\t{\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tif (!print_xml_decl(&buf, version, target_encoding, standalone))\n\t\t{\n\t\t\t/*\n\t\t\t * If we are not going to produce an XML declaration, eat a single\n\t\t\t * newline in the original string to prevent empty first lines in\n\t\t\t * the output.\n\t\t\t */\n\t\t\tif (*(str + len) == '\\n')\n\t\t\t\tlen += 1;\n\t\t}\n\t\tappendStringInfoString(&buf, str + len);\n\n\t\tpfree(str);\n\n\t\treturn buf.data;\n\t}\n\n\txml_ereport_by_code(WARNING, ERRCODE_INTERNAL_ERROR,\n\t\t\t\t\t\t\"could not parse XML declaration in stored value\",\n\t\t\t\t\t\tres_code);\n#endif\n\treturn str;\n}"
  },
  {
    "function_name": "xml_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "256-278",
    "snippet": "Datum\nxml_in(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\txmltype    *vardata;\n\txmlDocPtr\tdoc;\n\n\tvardata = (xmltype *) cstring_to_text(s);\n\n\t/*\n\t * Parse the data to check if it is well-formed XML data.  Assume that\n\t * ERROR occurred if parsing failed.\n\t */\n\tdoc = xml_parse(vardata, xmloption, true, GetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\tPG_RETURN_XML_P(vardata);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\txmloption;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NO_XML_SUPPORT",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_XML_P",
          "args": [
            "vardata"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml_parse",
          "args": [
            "vardata",
            "xmloption",
            "true",
            "GetDatabaseEncoding()"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "xml_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1483-1600",
          "snippet": "static xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlDocPtr\nxml_parse(text *data, XmlOptionType xmloption_arg, bool preserve_whitespace,\n\t\t  int encoding)\n{\n\tint32\t\tlen;\n\txmlChar    *string;\n\txmlChar    *utf8string;\n\tPgXmlErrorContext *xmlerrcxt;\n\tvolatile xmlParserCtxtPtr ctxt = NULL;\n\tvolatile xmlDocPtr doc = NULL;\n\n\tlen = VARSIZE_ANY_EXHDR(data);\t/* will be useful later */\n\tstring = xml_text2xmlChar(data);\n\n\tutf8string = pg_do_encoding_conversion(string,\n\t\t\t\t\t\t\t\t\t\t   len,\n\t\t\t\t\t\t\t\t\t\t   encoding,\n\t\t\t\t\t\t\t\t\t\t   PG_UTF8);\n\n\t/* Start up libxml and its parser */\n\txmlerrcxt = pg_xml_init(PG_XML_STRICTNESS_WELLFORMED);\n\n\t/* Use a TRY block to ensure we clean up correctly */\n\tPG_TRY();\n\t{\n\t\tbool\t\tparse_as_document = false;\n\t\tint\t\t\tres_code;\n\t\tsize_t\t\tcount = 0;\n\t\txmlChar    *version = NULL;\n\t\tint\t\t\tstandalone = 0;\n\n\t\txmlInitParser();\n\n\t\tctxt = xmlNewParserCtxt();\n\t\tif (ctxt == NULL || xmlerrcxt->err_occurred)\n\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_OUT_OF_MEMORY,\n\t\t\t\t\t\t\"could not allocate parser context\");\n\n\t\t/* Decide whether to parse as document or content */\n\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\tparse_as_document = true;\n\t\telse\n\t\t{\n\t\t\t/* Parse and skip over the XML declaration, if any */\n\t\t\tres_code = parse_xml_decl(utf8string,\n\t\t\t\t\t\t\t\t\t  &count, &version, NULL, &standalone);\n\t\t\tif (res_code != 0)\n\t\t\t\txml_ereport_by_code(ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\t\"invalid XML content: invalid XML declaration\",\n\t\t\t\t\t\t\t\t\tres_code);\n\n\t\t\t/* Is there a DOCTYPE element? */\n\t\t\tif (xml_doctype_in_content(utf8string + count))\n\t\t\t\tparse_as_document = true;\n\t\t}\n\n\t\tif (parse_as_document)\n\t\t{\n\t\t\t/*\n\t\t\t * Note, that here we try to apply DTD defaults\n\t\t\t * (XML_PARSE_DTDATTR) according to SQL/XML:2008 GR 10.16.7.d:\n\t\t\t * 'Default values defined by internal DTD are applied'. As for\n\t\t\t * external DTDs, we try to support them too, (see SQL/XML:2008 GR\n\t\t\t * 10.16.7.e)\n\t\t\t */\n\t\t\tdoc = xmlCtxtReadDoc(ctxt, utf8string,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t \"UTF-8\",\n\t\t\t\t\t\t\t\t XML_PARSE_NOENT | XML_PARSE_DTDATTR\n\t\t\t\t\t\t\t\t | (preserve_whitespace ? 0 : XML_PARSE_NOBLANKS));\n\t\t\tif (doc == NULL || xmlerrcxt->err_occurred)\n\t\t\t{\n\t\t\t\t/* Use original option to decide which error code to throw */\n\t\t\t\tif (xmloption_arg == XMLOPTION_DOCUMENT)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_DOCUMENT,\n\t\t\t\t\t\t\t\t\"invalid XML document\");\n\t\t\t\telse\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc = xmlNewDoc(version);\n\t\t\tAssert(doc->encoding == NULL);\n\t\t\tdoc->encoding = xmlStrdup((const xmlChar *) \"UTF-8\");\n\t\t\tdoc->standalone = standalone;\n\n\t\t\t/* allow empty content */\n\t\t\tif (*(utf8string + count))\n\t\t\t{\n\t\t\t\tres_code = xmlParseBalancedChunkMemory(doc, NULL, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   utf8string + count, NULL);\n\t\t\t\tif (res_code != 0 || xmlerrcxt->err_occurred)\n\t\t\t\t\txml_ereport(xmlerrcxt, ERROR, ERRCODE_INVALID_XML_CONTENT,\n\t\t\t\t\t\t\t\t\"invalid XML content\");\n\t\t\t}\n\t\t}\n\t}\n\tPG_CATCH();\n\t{\n\t\tif (doc != NULL)\n\t\t\txmlFreeDoc(doc);\n\t\tif (ctxt != NULL)\n\t\t\txmlFreeParserCtxt(ctxt);\n\n\t\tpg_xml_done(xmlerrcxt, true);\n\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\txmlFreeParserCtxt(ctxt);\n\n\tpg_xml_done(xmlerrcxt, false);\n\n\treturn doc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "s"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nint\t\t\txmloption;\n\nDatum\nxml_in(PG_FUNCTION_ARGS)\n{\n#ifdef USE_LIBXML\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\txmltype    *vardata;\n\txmlDocPtr\tdoc;\n\n\tvardata = (xmltype *) cstring_to_text(s);\n\n\t/*\n\t * Parse the data to check if it is well-formed XML data.  Assume that\n\t * ERROR occurred if parsing failed.\n\t */\n\tdoc = xml_parse(vardata, xmloption, true, GetDatabaseEncoding());\n\txmlFreeDoc(doc);\n\n\tPG_RETURN_XML_P(vardata);\n#else\n\tNO_XML_SUPPORT();\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "xmlChar_to_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
    "lines": "234-245",
    "snippet": "static int\nxmlChar_to_encoding(const xmlChar *encoding_name)\n{\n\tint\t\t\tencoding = pg_char_to_encoding((const char *) encoding_name);\n\n\tif (encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\t(const char *) encoding_name)));\n\treturn encoding;\n}",
    "includes": [
      "#include \"utils/xml.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/execnodes.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"fmgr.h\"",
      "#include \"executor/tablefunc.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/xpath.h>",
      "#include <libxml/xmlwriter.h>",
      "#include <libxml/xmlversion.h>",
      "#include <libxml/xmlerror.h>",
      "#include <libxml/uri.h>",
      "#include <libxml/tree.h>",
      "#include <libxml/parserInternals.h>",
      "#include <libxml/parser.h>",
      "#include <libxml/chvalid.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\t(const char *) encoding_name))"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid encoding name \\\"%s\\\"\"",
            "(const char *) encoding_name"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_char_to_encoding",
          "args": [
            "(const char *) encoding_name"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_to_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "550-594",
          "snippet": "int\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nstatic const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};\n\nint\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic int\nxmlChar_to_encoding(const xmlChar *encoding_name)\n{\n\tint\t\t\tencoding = pg_char_to_encoding((const char *) encoding_name);\n\n\tif (encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\t(const char *) encoding_name)));\n\treturn encoding;\n}"
  }
]