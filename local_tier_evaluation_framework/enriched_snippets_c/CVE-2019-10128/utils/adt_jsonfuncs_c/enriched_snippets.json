[
  {
    "function_name": "transform_string_values_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5309-5322",
    "snippet": "static void\ntransform_string_values_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (tokentype == JSON_TOKEN_STRING)\n\t{\n\t\ttext\t   *out = _state->action(_state->action_state, token, strlen(token));\n\n\t\tescape_json(_state->strval, text_to_cstring(out));\n\t}\n\telse\n\t\tappendStringInfoString(_state->strval, token);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "_state->strval",
            "token"
          ],
          "line": 5321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "_state->strval",
            "text_to_cstring(out)"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "out"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_state->action",
          "args": [
            "_state->action_state",
            "token",
            "strlen(token)"
          ],
          "line": 5316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token"
          ],
          "line": 5316
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\ntransform_string_values_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (tokentype == JSON_TOKEN_STRING)\n\t{\n\t\ttext\t   *out = _state->action(_state->action_state, token, strlen(token));\n\n\t\tescape_json(_state->strval, text_to_cstring(out));\n\t}\n\telse\n\t\tappendStringInfoString(_state->strval, token);\n}"
  },
  {
    "function_name": "transform_string_values_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5300-5307",
    "snippet": "static void\ntransform_string_values_array_element_start(void *state, bool isnull)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '[')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "','"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\ntransform_string_values_array_element_start(void *state, bool isnull)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '[')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n}"
  },
  {
    "function_name": "transform_string_values_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5284-5298",
    "snippet": "static void\ntransform_string_values_object_field_start(void *state, char *fname, bool isnull)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '{')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n\n\t/*\n\t * Unfortunately we don't have the quoted and escaped string any more, so\n\t * we have to re-escape it.\n\t */\n\tescape_json(_state->strval, fname);\n\tappendStringInfoCharMacro(_state->strval, ':');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "':'"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "_state->strval",
            "fname"
          ],
          "line": 5296
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "','"
          ],
          "line": 5290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\ntransform_string_values_object_field_start(void *state, char *fname, bool isnull)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '{')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n\n\t/*\n\t * Unfortunately we don't have the quoted and escaped string any more, so\n\t * we have to re-escape it.\n\t */\n\tescape_json(_state->strval, fname);\n\tappendStringInfoCharMacro(_state->strval, ':');\n}"
  },
  {
    "function_name": "transform_string_values_array_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5276-5282",
    "snippet": "static void\ntransform_string_values_array_end(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, ']');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "']'"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\ntransform_string_values_array_end(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, ']');\n}"
  },
  {
    "function_name": "transform_string_values_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5268-5274",
    "snippet": "static void\ntransform_string_values_array_start(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '[');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'['"
          ],
          "line": 5273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\ntransform_string_values_array_start(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '[');\n}"
  },
  {
    "function_name": "transform_string_values_object_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5260-5266",
    "snippet": "static void\ntransform_string_values_object_end(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '}');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'}'"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\ntransform_string_values_object_end(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '}');\n}"
  },
  {
    "function_name": "transform_string_values_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5252-5258",
    "snippet": "static void\ntransform_string_values_object_start(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '{');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'{'"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\ntransform_string_values_object_start(void *state)\n{\n\tTransformJsonStringValuesState *_state = (TransformJsonStringValuesState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '{');\n}"
  },
  {
    "function_name": "transform_json_string_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5219-5245",
    "snippet": "text *\ntransform_json_string_values(text *json, void *action_state,\n\t\t\t\t\t\t\t JsonTransformStringValuesAction transform_action)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tTransformJsonStringValuesState *state = palloc0(sizeof(TransformJsonStringValuesState));\n\n\tstate->lex = lex;\n\tstate->strval = makeStringInfo();\n\tstate->action = transform_action;\n\tstate->action_state = action_state;\n\n\tsem->semstate = (void *) state;\n\tsem->scalar = transform_string_values_scalar;\n\tsem->object_start = transform_string_values_object_start;\n\tsem->object_end = transform_string_values_object_end;\n\tsem->array_start = transform_string_values_array_start;\n\tsem->array_end = transform_string_values_array_end;\n\tsem->scalar = transform_string_values_scalar;\n\tsem->array_element_start = transform_string_values_array_element_start;\n\tsem->object_field_start = transform_string_values_object_field_start;\n\n\tpg_parse_json(lex, sem);\n\n\treturn cstring_to_text_with_len(state->strval->data, state->strval->len);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "state->strval->data",
            "state->strval->len"
          ],
          "line": 5244
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 5228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(TransformJsonStringValuesState)"
          ],
          "line": 5225
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 5223
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\ntext *\ntransform_json_string_values(text *json, void *action_state,\n\t\t\t\t\t\t\t JsonTransformStringValuesAction transform_action)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tTransformJsonStringValuesState *state = palloc0(sizeof(TransformJsonStringValuesState));\n\n\tstate->lex = lex;\n\tstate->strval = makeStringInfo();\n\tstate->action = transform_action;\n\tstate->action_state = action_state;\n\n\tsem->semstate = (void *) state;\n\tsem->scalar = transform_string_values_scalar;\n\tsem->object_start = transform_string_values_object_start;\n\tsem->object_end = transform_string_values_object_end;\n\tsem->array_start = transform_string_values_array_start;\n\tsem->array_end = transform_string_values_array_end;\n\tsem->scalar = transform_string_values_scalar;\n\tsem->array_element_start = transform_string_values_array_element_start;\n\tsem->object_field_start = transform_string_values_object_field_start;\n\n\tpg_parse_json(lex, sem);\n\n\treturn cstring_to_text_with_len(state->strval->data, state->strval->len);\n}"
  },
  {
    "function_name": "transform_jsonb_string_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5174-5210",
    "snippet": "Jsonb *\ntransform_jsonb_string_values(Jsonb *jsonb, void *action_state,\n\t\t\t\t\t\t\t  JsonTransformStringValuesAction transform_action)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken type;\n\tJsonbParseState *st = NULL;\n\ttext\t   *out;\n\tbool\t\tis_scalar = false;\n\n\tit = JsonbIteratorInit(&jsonb->root);\n\tis_scalar = it->isScalar;\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tif ((type == WJB_VALUE || type == WJB_ELEM) && v.type == jbvString)\n\t\t{\n\t\t\tout = transform_action(action_state, v.val.string.val, v.val.string.len);\n\t\t\tv.val.string.val = VARDATA_ANY(out);\n\t\t\tv.val.string.len = VARSIZE_ANY_EXHDR(out);\n\t\t\tres = pushJsonbValue(&st, type, type < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = pushJsonbValue(&st, type, (type == WJB_KEY ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_VALUE ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_ELEM) ? &v : NULL);\n\t\t}\n\t}\n\n\tif (res->type == jbvArray)\n\t\tres->val.array.rawScalar = is_scalar;\n\n\treturn JsonbValueToJsonb(res);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 5209
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&st",
            "type",
            "(type == WJB_KEY ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_VALUE ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_ELEM) ? &v : NULL"
          ],
          "line": 5200
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "out"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "out"
          ],
          "line": 5194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transform_action",
          "args": [
            "action_state",
            "v.val.string.val",
            "v.val.string.len"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jsonb->root"
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\n\nJsonb *\ntransform_jsonb_string_values(Jsonb *jsonb, void *action_state,\n\t\t\t\t\t\t\t  JsonTransformStringValuesAction transform_action)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken type;\n\tJsonbParseState *st = NULL;\n\ttext\t   *out;\n\tbool\t\tis_scalar = false;\n\n\tit = JsonbIteratorInit(&jsonb->root);\n\tis_scalar = it->isScalar;\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tif ((type == WJB_VALUE || type == WJB_ELEM) && v.type == jbvString)\n\t\t{\n\t\t\tout = transform_action(action_state, v.val.string.val, v.val.string.len);\n\t\t\tv.val.string.val = VARDATA_ANY(out);\n\t\t\tv.val.string.len = VARSIZE_ANY_EXHDR(out);\n\t\t\tres = pushJsonbValue(&st, type, type < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = pushJsonbValue(&st, type, (type == WJB_KEY ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_VALUE ||\n\t\t\t\t\t\t\t\t\t\t\t type == WJB_ELEM) ? &v : NULL);\n\t\t}\n\t}\n\n\tif (res->type == jbvArray)\n\t\tres->val.array.rawScalar = is_scalar;\n\n\treturn JsonbValueToJsonb(res);\n}"
  },
  {
    "function_name": "iterate_values_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5155-5166",
    "snippet": "static void\niterate_values_object_field_start(void *state, char *fname, bool isnull)\n{\n\tIterateJsonStringValuesState *_state = (IterateJsonStringValuesState *) state;\n\n\tif (_state->flags & jtiKey)\n\t{\n\t\tchar\t   *val = pstrdup(fname);\n\n\t\t_state->action(_state->action_state, val, strlen(val));\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_state->action",
          "args": [
            "_state->action_state",
            "val",
            "strlen(val)"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 5164
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "fname"
          ],
          "line": 5162
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\niterate_values_object_field_start(void *state, char *fname, bool isnull)\n{\n\tIterateJsonStringValuesState *_state = (IterateJsonStringValuesState *) state;\n\n\tif (_state->flags & jtiKey)\n\t{\n\t\tchar\t   *val = pstrdup(fname);\n\n\t\t_state->action(_state->action_state, val, strlen(val));\n\t}\n}"
  },
  {
    "function_name": "iterate_values_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5129-5153",
    "snippet": "static void\niterate_values_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tIterateJsonStringValuesState *_state = (IterateJsonStringValuesState *) state;\n\n\tswitch (tokentype)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tif (_state->flags & jtiString)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tif (_state->flags & jtiNumeric)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tif (_state->flags & jtiBool)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* do not call callback for any other token */\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_state->action",
          "args": [
            "_state->action_state",
            "token",
            "strlen(token)"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_state->action",
          "args": [
            "_state->action_state",
            "token",
            "strlen(token)"
          ],
          "line": 5142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_state->action",
          "args": [
            "_state->action_state",
            "token",
            "strlen(token)"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\niterate_values_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tIterateJsonStringValuesState *_state = (IterateJsonStringValuesState *) state;\n\n\tswitch (tokentype)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tif (_state->flags & jtiString)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tif (_state->flags & jtiNumeric)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tif (_state->flags & jtiBool)\n\t\t\t\t_state->action(_state->action_state, token, strlen(token));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* do not call callback for any other token */\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "iterate_json_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5105-5123",
    "snippet": "void\niterate_json_values(text *json, uint32 flags, void *action_state,\n\t\t\t\t\tJsonIterateStringValuesAction action)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tIterateJsonStringValuesState *state = palloc0(sizeof(IterateJsonStringValuesState));\n\n\tstate->lex = lex;\n\tstate->action = action;\n\tstate->action_state = action_state;\n\tstate->flags = flags;\n\n\tsem->semstate = (void *) state;\n\tsem->scalar = iterate_values_scalar;\n\tsem->object_field_start = iterate_values_object_field_start;\n\n\tpg_parse_json(lex, sem);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(IterateJsonStringValuesState)"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 5109
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nvoid\niterate_json_values(text *json, uint32 flags, void *action_state,\n\t\t\t\t\tJsonIterateStringValuesAction action)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tIterateJsonStringValuesState *state = palloc0(sizeof(IterateJsonStringValuesState));\n\n\tstate->lex = lex;\n\tstate->action = action;\n\tstate->action_state = action_state;\n\tstate->flags = flags;\n\n\tsem->semstate = (void *) state;\n\tsem->scalar = iterate_values_scalar;\n\tsem->object_field_start = iterate_values_object_field_start;\n\n\tpg_parse_json(lex, sem);\n}"
  },
  {
    "function_name": "iterate_jsonb_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "5037-5099",
    "snippet": "void\niterate_jsonb_values(Jsonb *jb, uint32 flags, void *state,\n\t\t\t\t\t JsonIterateStringValuesAction action)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\t/*\n\t * Just recursively iterating over jsonb and call callback on all\n\t * correspoding elements\n\t */\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tif (type == WJB_KEY)\n\t\t{\n\t\t\tif (flags & jtiKey)\n\t\t\t\taction(state, v.val.string.val, v.val.string.len);\n\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!(type == WJB_VALUE || type == WJB_ELEM))\n\t\t{\n\t\t\t/* do not call callback for composite JsonbValue */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* JsonbValue is a value of object or element of array */\n\t\tswitch (v.type)\n\t\t{\n\t\t\tcase jbvString:\n\t\t\t\tif (flags & jtiString)\n\t\t\t\t\taction(state, v.val.string.val, v.val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tif (flags & jtiNumeric)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val;\n\n\t\t\t\t\tval = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(v.val.numeric)));\n\n\t\t\t\t\taction(state, val, strlen(val));\n\t\t\t\t\tpfree(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tif (flags & jtiBool)\n\t\t\t\t{\n\t\t\t\t\tif (v.val.boolean)\n\t\t\t\t\t\taction(state, \"true\", 4);\n\t\t\t\t\telse\n\t\t\t\t\t\taction(state, \"false\", 5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* do not call callback for composite JsonbValue */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action",
          "args": [
            "state",
            "\"false\"",
            "5"
          ],
          "line": 5091
        },
        "resolved": true,
        "details": {
          "function_name": "TransactionIdInArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "1641-1646",
          "snippet": "static bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "val"
          ],
          "line": 5082
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 5081
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(v.val.numeric))"
          ],
          "line": 5078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 5078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 5051
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nvoid\niterate_jsonb_values(Jsonb *jb, uint32 flags, void *state,\n\t\t\t\t\t JsonIterateStringValuesAction action)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\t/*\n\t * Just recursively iterating over jsonb and call callback on all\n\t * correspoding elements\n\t */\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tif (type == WJB_KEY)\n\t\t{\n\t\t\tif (flags & jtiKey)\n\t\t\t\taction(state, v.val.string.val, v.val.string.len);\n\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!(type == WJB_VALUE || type == WJB_ELEM))\n\t\t{\n\t\t\t/* do not call callback for composite JsonbValue */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* JsonbValue is a value of object or element of array */\n\t\tswitch (v.type)\n\t\t{\n\t\t\tcase jbvString:\n\t\t\t\tif (flags & jtiString)\n\t\t\t\t\taction(state, v.val.string.val, v.val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tif (flags & jtiNumeric)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *val;\n\n\t\t\t\t\tval = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(v.val.numeric)));\n\n\t\t\t\t\taction(state, val, strlen(val));\n\t\t\t\t\tpfree(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tif (flags & jtiBool)\n\t\t\t\t{\n\t\t\t\t\tif (v.val.boolean)\n\t\t\t\t\t\taction(state, \"true\", 4);\n\t\t\t\t\telse\n\t\t\t\t\t\taction(state, \"false\", 5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* do not call callback for composite JsonbValue */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "parse_jsonb_index_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4969-5031",
    "snippet": "uint32\nparse_jsonb_index_flags(Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\tuint32\t\tflags = 0;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\ttype = JsonbIteratorNext(&it, &v, false);\n\n\t/*\n\t * We iterate over array (scalar internally is represented as array, so,\n\t * we will accept it too) to check all its elements.  Flag names are\n\t * chosen the same as jsonb_typeof uses.\n\t */\n\tif (type != WJB_BEGIN_ARRAY)\n\t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\terrmsg(\"wrong flag type, only arrays and scalars are allowed\")));\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) == WJB_ELEM)\n\t{\n\t\tif (v.type != jbvString)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"flag array element is not a string\"),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\")));\n\n\t\tif (v.val.string.len == 3 &&\n\t\t\tpg_strncasecmp(v.val.string.val, \"all\", 3) == 0)\n\t\t\tflags |= jtiAll;\n\t\telse if (v.val.string.len == 3 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"key\", 3) == 0)\n\t\t\tflags |= jtiKey;\n\t\telse if (v.val.string.len == 6 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"string\", 5) == 0)\n\t\t\tflags |= jtiString;\n\t\telse if (v.val.string.len == 7 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"numeric\", 7) == 0)\n\t\t\tflags |= jtiNumeric;\n\t\telse if (v.val.string.len == 7 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"boolean\", 7) == 0)\n\t\t\tflags |= jtiBool;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"wrong flag in flag array: \\\"%s\\\"\",\n\t\t\t\t\t\t\tpnstrdup(v.val.string.val, v.val.string.len)),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\")));\n\t}\n\n\t/* expect end of array now */\n\tif (type != WJB_END_ARRAY)\n\t\telog(ERROR, \"unexpected end of flag array\");\n\n\t/* get final WJB_DONE and free iterator */\n\ttype = JsonbIteratorNext(&it, &v, false);\n\tif (type != WJB_DONE)\n\t\telog(ERROR, \"unexpected end of flag array\");\n\n\treturn flags;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected end of flag array\""
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"wrong flag in flag array: \\\"%s\\\"\",\n\t\t\t\t\t\t\tpnstrdup(v.val.string.val, v.val.string.len)),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\"))"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\""
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"wrong flag in flag array: \\\"%s\\\"\"",
            "pnstrdup(v.val.string.val, v.val.string.len)"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "v.val.string.val",
            "v.val.string.len"
          ],
          "line": 5017
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5015
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "v.val.string.val",
            "\"boolean\"",
            "7"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "v.val.string.val",
            "\"numeric\"",
            "7"
          ],
          "line": 5008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "v.val.string.val",
            "\"string\"",
            "5"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "v.val.string.val",
            "\"key\"",
            "3"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strncasecmp",
          "args": [
            "v.val.string.val",
            "\"all\"",
            "3"
          ],
          "line": 4999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"flag array element is not a string\"),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\"))"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\terrmsg(\"wrong flag type, only arrays and scalars are allowed\"))"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nuint32\nparse_jsonb_index_flags(Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\tuint32\t\tflags = 0;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\ttype = JsonbIteratorNext(&it, &v, false);\n\n\t/*\n\t * We iterate over array (scalar internally is represented as array, so,\n\t * we will accept it too) to check all its elements.  Flag names are\n\t * chosen the same as jsonb_typeof uses.\n\t */\n\tif (type != WJB_BEGIN_ARRAY)\n\t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\terrmsg(\"wrong flag type, only arrays and scalars are allowed\")));\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) == WJB_ELEM)\n\t{\n\t\tif (v.type != jbvString)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"flag array element is not a string\"),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\")));\n\n\t\tif (v.val.string.len == 3 &&\n\t\t\tpg_strncasecmp(v.val.string.val, \"all\", 3) == 0)\n\t\t\tflags |= jtiAll;\n\t\telse if (v.val.string.len == 3 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"key\", 3) == 0)\n\t\t\tflags |= jtiKey;\n\t\telse if (v.val.string.len == 6 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"string\", 5) == 0)\n\t\t\tflags |= jtiString;\n\t\telse if (v.val.string.len == 7 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"numeric\", 7) == 0)\n\t\t\tflags |= jtiNumeric;\n\t\telse if (v.val.string.len == 7 &&\n\t\t\t\t pg_strncasecmp(v.val.string.val, \"boolean\", 7) == 0)\n\t\t\tflags |= jtiBool;\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"wrong flag in flag array: \\\"%s\\\"\",\n\t\t\t\t\t\t\tpnstrdup(v.val.string.val, v.val.string.len)),\n\t\t\t\t\t errhint(\"Possible values are: \\\"string\\\", \\\"numeric\\\", \\\"boolean\\\", \\\"key\\\", and \\\"all\\\"\")));\n\t}\n\n\t/* expect end of array now */\n\tif (type != WJB_END_ARRAY)\n\t\telog(ERROR, \"unexpected end of flag array\");\n\n\t/* get final WJB_DONE and free iterator */\n\ttype = JsonbIteratorNext(&it, &v, false);\n\tif (type != WJB_DONE)\n\t\telog(ERROR, \"unexpected end of flag array\");\n\n\treturn flags;\n}"
  },
  {
    "function_name": "setPathArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4846-4962",
    "snippet": "static void\nsetPathArray(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t int path_len, JsonbParseState **st, int level,\n\t\t\t Jsonb *newval, uint32 nelems, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\tidx,\n\t\t\t\ti;\n\tbool\t\tdone = false;\n\n\t/* pick correct index */\n\tif (level < path_len && !path_nulls[level])\n\t{\n\t\tchar\t   *c = TextDatumGetCString(path_elems[level]);\n\t\tlong\t\tlindex;\n\t\tchar\t   *badp;\n\n\t\terrno = 0;\n\t\tlindex = strtol(c, &badp, 10);\n\t\tif (errno != 0 || badp == c || *badp != '\\0' || lindex > INT_MAX ||\n\t\t\tlindex < INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"path element at position %d is not an integer: \\\"%s\\\"\",\n\t\t\t\t\t\t\tlevel + 1, c)));\n\t\tidx = lindex;\n\t}\n\telse\n\t\tidx = nelems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > nelems)\n\t\t\tidx = INT_MIN;\n\t\telse\n\t\t\tidx = nelems + idx;\n\t}\n\n\tif (idx > 0 && idx > nelems)\n\t\tidx = nelems;\n\n\t/*\n\t * if we're creating, and idx == INT_MIN, we prepend the new value to the\n\t * array also if the array is empty - in which case we don't really care\n\t * what the idx value is\n\t */\n\n\tif ((idx == INT_MIN || nelems == 0) && (level == path_len - 1) &&\n\t\t(op_type & JB_PATH_CREATE_OR_INSERT))\n\t{\n\t\tAssert(newval != NULL);\n\t\taddJsonbToParseState(st, newval);\n\t\tdone = true;\n\t}\n\n\t/* iterate over the array elements */\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tJsonbIteratorToken r;\n\n\t\tif (i == idx && level < path_len)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip */\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_CREATE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\t/*\n\t\t\t\t * We should keep current value only in case of\n\t\t\t\t * JB_PATH_INSERT_BEFORE or JB_PATH_INSERT_AFTER because\n\t\t\t\t * otherwise it should be deleted or replaced\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_INSERT_BEFORE))\n\t\t\t\t\t(void) pushJsonbValue(st, r, &v);\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_REPLACE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(void) setPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\t\t   st, level + 1, newval, op_type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == nelems - 1)\n\t\t\t{\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)",
      "#define JB_PATH_INSERT_AFTER\t\t\t0x0010",
      "#define JB_PATH_INSERT_BEFORE\t\t\t0x0008",
      "#define JB_PATH_REPLACE\t\t\t\t\t0x0004",
      "#define JB_PATH_CREATE\t\t\t\t\t0x0001"
    ],
    "globals_used": [
      "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
      "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
      "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addJsonbToParseState",
          "args": [
            "st",
            "newval"
          ],
          "line": 4958
        },
        "resolved": true,
        "details": {
          "function_name": "addJsonbToParseState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4119-4160",
          "snippet": "static void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "st",
            "r",
            "r < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 4951
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "it",
            "&v",
            "false"
          ],
          "line": 4944
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setPath",
          "args": [
            "it",
            "path_elems",
            "path_nulls",
            "path_len",
            "st",
            "level + 1",
            "newval",
            "op_type"
          ],
          "line": 4929
        },
        "resolved": true,
        "details": {
          "function_name": "setPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4686-4734",
          "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "newval != NULL"
          ],
          "line": 4896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"path element at position %d is not an integer: \\\"%s\\\"\",\n\t\t\t\t\t\t\tlevel + 1, c))"
          ],
          "line": 4867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"path element at position %d is not an integer: \\\"%s\\\"\"",
            "level + 1",
            "c"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 4868
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "c",
            "&badp",
            "10"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "path_elems[level]"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)\n#define JB_PATH_INSERT_AFTER\t\t\t0x0010\n#define JB_PATH_INSERT_BEFORE\t\t\t0x0008\n#define JB_PATH_REPLACE\t\t\t\t\t0x0004\n#define JB_PATH_CREATE\t\t\t\t\t0x0001\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic void\nsetPathArray(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t int path_len, JsonbParseState **st, int level,\n\t\t\t Jsonb *newval, uint32 nelems, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\tidx,\n\t\t\t\ti;\n\tbool\t\tdone = false;\n\n\t/* pick correct index */\n\tif (level < path_len && !path_nulls[level])\n\t{\n\t\tchar\t   *c = TextDatumGetCString(path_elems[level]);\n\t\tlong\t\tlindex;\n\t\tchar\t   *badp;\n\n\t\terrno = 0;\n\t\tlindex = strtol(c, &badp, 10);\n\t\tif (errno != 0 || badp == c || *badp != '\\0' || lindex > INT_MAX ||\n\t\t\tlindex < INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"path element at position %d is not an integer: \\\"%s\\\"\",\n\t\t\t\t\t\t\tlevel + 1, c)));\n\t\tidx = lindex;\n\t}\n\telse\n\t\tidx = nelems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > nelems)\n\t\t\tidx = INT_MIN;\n\t\telse\n\t\t\tidx = nelems + idx;\n\t}\n\n\tif (idx > 0 && idx > nelems)\n\t\tidx = nelems;\n\n\t/*\n\t * if we're creating, and idx == INT_MIN, we prepend the new value to the\n\t * array also if the array is empty - in which case we don't really care\n\t * what the idx value is\n\t */\n\n\tif ((idx == INT_MIN || nelems == 0) && (level == path_len - 1) &&\n\t\t(op_type & JB_PATH_CREATE_OR_INSERT))\n\t{\n\t\tAssert(newval != NULL);\n\t\taddJsonbToParseState(st, newval);\n\t\tdone = true;\n\t}\n\n\t/* iterate over the array elements */\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tJsonbIteratorToken r;\n\n\t\tif (i == idx && level < path_len)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip */\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_CREATE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\t/*\n\t\t\t\t * We should keep current value only in case of\n\t\t\t\t * JB_PATH_INSERT_BEFORE or JB_PATH_INSERT_AFTER because\n\t\t\t\t * otherwise it should be deleted or replaced\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_INSERT_BEFORE))\n\t\t\t\t\t(void) pushJsonbValue(st, r, &v);\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_REPLACE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(void) setPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\t\t   st, level + 1, newval, op_type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == nelems - 1)\n\t\t\t{\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "setPathObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4739-4841",
    "snippet": "static void\nsetPathObject(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t  int path_len, JsonbParseState **st, int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\ti;\n\tJsonbValue\tk;\n\tbool\t\tdone = false;\n\n\tif (level >= path_len || path_nulls[level])\n\t\tdone = true;\n\n\t/* empty object is a special case for create */\n\tif ((npairs == 0) && (op_type & JB_PATH_CREATE_OR_INSERT) &&\n\t\t(level == path_len - 1))\n\t{\n\t\tJsonbValue\tnewkey;\n\n\t\tnewkey.type = jbvString;\n\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\taddJsonbToParseState(st, newval);\n\t}\n\n\tfor (i = 0; i < npairs; i++)\n\t{\n\t\tJsonbIteratorToken r = JsonbIteratorNext(it, &k, true);\n\n\t\tAssert(r == WJB_KEY);\n\n\t\tif (!done &&\n\t\t\tk.val.string.len == VARSIZE_ANY_EXHDR(path_elems[level]) &&\n\t\t\tmemcmp(k.val.string.val, VARDATA_ANY(path_elems[level]),\n\t\t\t\t   k.val.string.len) == 0)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * called from jsonb_insert(), it forbids redefining an\n\t\t\t\t * existing value\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"cannot replace existing key\"),\n\t\t\t\t\t\t\t errhint(\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\")));\n\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip value */\n\t\t\t\tif (!(op_type & JB_PATH_DELETE))\n\t\t\t\t{\n\t\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &k);\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\t\tsetPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\tst, level + 1, newval, op_type);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == npairs - 1)\n\t\t\t{\n\t\t\t\tJsonbValue\tnewkey;\n\n\t\t\t\tnewkey.type = jbvString;\n\t\t\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\t\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\n\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)",
      "#define JB_PATH_INSERT_AFTER\t\t\t0x0010",
      "#define JB_PATH_INSERT_BEFORE\t\t\t0x0008",
      "#define JB_PATH_DELETE\t\t\t\t\t0x0002"
    ],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
      "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
      "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "st",
            "r",
            "r < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "it",
            "&v",
            "false"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addJsonbToParseState",
          "args": [
            "st",
            "newval"
          ],
          "line": 4817
        },
        "resolved": true,
        "details": {
          "function_name": "addJsonbToParseState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4119-4160",
          "snippet": "static void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "path_elems[level]"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "path_elems[level]"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPath",
          "args": [
            "it",
            "path_elems",
            "path_nulls",
            "path_len",
            "st",
            "level + 1",
            "newval",
            "op_type"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "setPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4686-4734",
          "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"cannot replace existing key\"),\n\t\t\t\t\t\t\t errhint(\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\"))"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\""
          ],
          "line": 4787
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot replace existing key\""
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "k.val.string.val",
            "VARDATA_ANY(path_elems[level])",
            "k.val.string.len"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "path_elems[level]"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "path_elems[level]"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r == WJB_KEY"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "path_elems[level]"
          ],
          "line": 4760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "path_elems[level]"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)\n#define JB_PATH_INSERT_AFTER\t\t\t0x0010\n#define JB_PATH_INSERT_BEFORE\t\t\t0x0008\n#define JB_PATH_DELETE\t\t\t\t\t0x0002\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic void\nsetPathObject(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t  int path_len, JsonbParseState **st, int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\ti;\n\tJsonbValue\tk;\n\tbool\t\tdone = false;\n\n\tif (level >= path_len || path_nulls[level])\n\t\tdone = true;\n\n\t/* empty object is a special case for create */\n\tif ((npairs == 0) && (op_type & JB_PATH_CREATE_OR_INSERT) &&\n\t\t(level == path_len - 1))\n\t{\n\t\tJsonbValue\tnewkey;\n\n\t\tnewkey.type = jbvString;\n\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\taddJsonbToParseState(st, newval);\n\t}\n\n\tfor (i = 0; i < npairs; i++)\n\t{\n\t\tJsonbIteratorToken r = JsonbIteratorNext(it, &k, true);\n\n\t\tAssert(r == WJB_KEY);\n\n\t\tif (!done &&\n\t\t\tk.val.string.len == VARSIZE_ANY_EXHDR(path_elems[level]) &&\n\t\t\tmemcmp(k.val.string.val, VARDATA_ANY(path_elems[level]),\n\t\t\t\t   k.val.string.len) == 0)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * called from jsonb_insert(), it forbids redefining an\n\t\t\t\t * existing value\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"cannot replace existing key\"),\n\t\t\t\t\t\t\t errhint(\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\")));\n\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip value */\n\t\t\t\tif (!(op_type & JB_PATH_DELETE))\n\t\t\t\t{\n\t\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &k);\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\t\tsetPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\tst, level + 1, newval, op_type);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == npairs - 1)\n\t\t\t{\n\t\t\t\tJsonbValue\tnewkey;\n\n\t\t\t\tnewkey.type = jbvString;\n\t\t\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\t\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\n\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "setPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4686-4734",
    "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
      "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
      "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized iterator result: %d\"",
            "(int) r"
          ],
          "line": 4728
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "st",
            "r",
            "&v"
          ],
          "line": 4725
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r == WJB_END_OBJECT"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "it",
            "&v",
            "true"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setPathObject",
          "args": [
            "it",
            "path_elems",
            "path_nulls",
            "path_len",
            "st",
            "level",
            "newval",
            "v.val.object.nPairs",
            "op_type"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "setPathObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4739-4841",
          "snippet": "static void\nsetPathObject(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t  int path_len, JsonbParseState **st, int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\ti;\n\tJsonbValue\tk;\n\tbool\t\tdone = false;\n\n\tif (level >= path_len || path_nulls[level])\n\t\tdone = true;\n\n\t/* empty object is a special case for create */\n\tif ((npairs == 0) && (op_type & JB_PATH_CREATE_OR_INSERT) &&\n\t\t(level == path_len - 1))\n\t{\n\t\tJsonbValue\tnewkey;\n\n\t\tnewkey.type = jbvString;\n\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\taddJsonbToParseState(st, newval);\n\t}\n\n\tfor (i = 0; i < npairs; i++)\n\t{\n\t\tJsonbIteratorToken r = JsonbIteratorNext(it, &k, true);\n\n\t\tAssert(r == WJB_KEY);\n\n\t\tif (!done &&\n\t\t\tk.val.string.len == VARSIZE_ANY_EXHDR(path_elems[level]) &&\n\t\t\tmemcmp(k.val.string.val, VARDATA_ANY(path_elems[level]),\n\t\t\t\t   k.val.string.len) == 0)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * called from jsonb_insert(), it forbids redefining an\n\t\t\t\t * existing value\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"cannot replace existing key\"),\n\t\t\t\t\t\t\t errhint(\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\")));\n\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip value */\n\t\t\t\tif (!(op_type & JB_PATH_DELETE))\n\t\t\t\t{\n\t\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &k);\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\t\tsetPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\tst, level + 1, newval, op_type);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == npairs - 1)\n\t\t\t{\n\t\t\t\tJsonbValue\tnewkey;\n\n\t\t\t\tnewkey.type = jbvString;\n\t\t\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\t\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\n\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)",
            "#define JB_PATH_INSERT_AFTER\t\t\t0x0010",
            "#define JB_PATH_INSERT_BEFORE\t\t\t0x0008",
            "#define JB_PATH_DELETE\t\t\t\t\t0x0002"
          ],
          "globals_used": [
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)\n#define JB_PATH_INSERT_AFTER\t\t\t0x0010\n#define JB_PATH_INSERT_BEFORE\t\t\t0x0008\n#define JB_PATH_DELETE\t\t\t\t\t0x0002\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic void\nsetPathObject(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t  int path_len, JsonbParseState **st, int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\ti;\n\tJsonbValue\tk;\n\tbool\t\tdone = false;\n\n\tif (level >= path_len || path_nulls[level])\n\t\tdone = true;\n\n\t/* empty object is a special case for create */\n\tif ((npairs == 0) && (op_type & JB_PATH_CREATE_OR_INSERT) &&\n\t\t(level == path_len - 1))\n\t{\n\t\tJsonbValue\tnewkey;\n\n\t\tnewkey.type = jbvString;\n\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\taddJsonbToParseState(st, newval);\n\t}\n\n\tfor (i = 0; i < npairs; i++)\n\t{\n\t\tJsonbIteratorToken r = JsonbIteratorNext(it, &k, true);\n\n\t\tAssert(r == WJB_KEY);\n\n\t\tif (!done &&\n\t\t\tk.val.string.len == VARSIZE_ANY_EXHDR(path_elems[level]) &&\n\t\t\tmemcmp(k.val.string.val, VARDATA_ANY(path_elems[level]),\n\t\t\t\t   k.val.string.len) == 0)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * called from jsonb_insert(), it forbids redefining an\n\t\t\t\t * existing value\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"cannot replace existing key\"),\n\t\t\t\t\t\t\t errhint(\"Try using the function jsonb_set \"\n\t\t\t\t\t\t\t\t\t \"to replace key value.\")));\n\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip value */\n\t\t\t\tif (!(op_type & JB_PATH_DELETE))\n\t\t\t\t{\n\t\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &k);\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\t\tsetPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\tst, level + 1, newval, op_type);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == npairs - 1)\n\t\t\t{\n\t\t\t\tJsonbValue\tnewkey;\n\n\t\t\t\tnewkey.type = jbvString;\n\t\t\t\tnewkey.val.string.len = VARSIZE_ANY_EXHDR(path_elems[level]);\n\t\t\t\tnewkey.val.string.val = VARDATA_ANY(path_elems[level]);\n\n\t\t\t\t(void) pushJsonbValue(st, WJB_KEY, &newkey);\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\n\t\t\t(void) pushJsonbValue(st, r, &k);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r == WJB_END_ARRAY"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPathArray",
          "args": [
            "it",
            "path_elems",
            "path_nulls",
            "path_len",
            "st",
            "level",
            "newval",
            "v.val.array.nElems",
            "op_type"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "setPathArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4846-4962",
          "snippet": "static void\nsetPathArray(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t int path_len, JsonbParseState **st, int level,\n\t\t\t Jsonb *newval, uint32 nelems, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\tidx,\n\t\t\t\ti;\n\tbool\t\tdone = false;\n\n\t/* pick correct index */\n\tif (level < path_len && !path_nulls[level])\n\t{\n\t\tchar\t   *c = TextDatumGetCString(path_elems[level]);\n\t\tlong\t\tlindex;\n\t\tchar\t   *badp;\n\n\t\terrno = 0;\n\t\tlindex = strtol(c, &badp, 10);\n\t\tif (errno != 0 || badp == c || *badp != '\\0' || lindex > INT_MAX ||\n\t\t\tlindex < INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"path element at position %d is not an integer: \\\"%s\\\"\",\n\t\t\t\t\t\t\tlevel + 1, c)));\n\t\tidx = lindex;\n\t}\n\telse\n\t\tidx = nelems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > nelems)\n\t\t\tidx = INT_MIN;\n\t\telse\n\t\t\tidx = nelems + idx;\n\t}\n\n\tif (idx > 0 && idx > nelems)\n\t\tidx = nelems;\n\n\t/*\n\t * if we're creating, and idx == INT_MIN, we prepend the new value to the\n\t * array also if the array is empty - in which case we don't really care\n\t * what the idx value is\n\t */\n\n\tif ((idx == INT_MIN || nelems == 0) && (level == path_len - 1) &&\n\t\t(op_type & JB_PATH_CREATE_OR_INSERT))\n\t{\n\t\tAssert(newval != NULL);\n\t\taddJsonbToParseState(st, newval);\n\t\tdone = true;\n\t}\n\n\t/* iterate over the array elements */\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tJsonbIteratorToken r;\n\n\t\tif (i == idx && level < path_len)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip */\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_CREATE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\t/*\n\t\t\t\t * We should keep current value only in case of\n\t\t\t\t * JB_PATH_INSERT_BEFORE or JB_PATH_INSERT_AFTER because\n\t\t\t\t * otherwise it should be deleted or replaced\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_INSERT_BEFORE))\n\t\t\t\t\t(void) pushJsonbValue(st, r, &v);\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_REPLACE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(void) setPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\t\t   st, level + 1, newval, op_type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == nelems - 1)\n\t\t\t{\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)",
            "#define JB_PATH_INSERT_AFTER\t\t\t0x0010",
            "#define JB_PATH_INSERT_BEFORE\t\t\t0x0008",
            "#define JB_PATH_REPLACE\t\t\t\t\t0x0004",
            "#define JB_PATH_CREATE\t\t\t\t\t0x0001"
          ],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_CREATE_OR_INSERT \\\n\t(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)\n#define JB_PATH_INSERT_AFTER\t\t\t0x0010\n#define JB_PATH_INSERT_BEFORE\t\t\t0x0008\n#define JB_PATH_REPLACE\t\t\t\t\t0x0004\n#define JB_PATH_CREATE\t\t\t\t\t0x0001\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic void\nsetPathArray(JsonbIterator **it, Datum *path_elems, bool *path_nulls,\n\t\t\t int path_len, JsonbParseState **st, int level,\n\t\t\t Jsonb *newval, uint32 nelems, int op_type)\n{\n\tJsonbValue\tv;\n\tint\t\t\tidx,\n\t\t\t\ti;\n\tbool\t\tdone = false;\n\n\t/* pick correct index */\n\tif (level < path_len && !path_nulls[level])\n\t{\n\t\tchar\t   *c = TextDatumGetCString(path_elems[level]);\n\t\tlong\t\tlindex;\n\t\tchar\t   *badp;\n\n\t\terrno = 0;\n\t\tlindex = strtol(c, &badp, 10);\n\t\tif (errno != 0 || badp == c || *badp != '\\0' || lindex > INT_MAX ||\n\t\t\tlindex < INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"path element at position %d is not an integer: \\\"%s\\\"\",\n\t\t\t\t\t\t\tlevel + 1, c)));\n\t\tidx = lindex;\n\t}\n\telse\n\t\tidx = nelems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > nelems)\n\t\t\tidx = INT_MIN;\n\t\telse\n\t\t\tidx = nelems + idx;\n\t}\n\n\tif (idx > 0 && idx > nelems)\n\t\tidx = nelems;\n\n\t/*\n\t * if we're creating, and idx == INT_MIN, we prepend the new value to the\n\t * array also if the array is empty - in which case we don't really care\n\t * what the idx value is\n\t */\n\n\tif ((idx == INT_MIN || nelems == 0) && (level == path_len - 1) &&\n\t\t(op_type & JB_PATH_CREATE_OR_INSERT))\n\t{\n\t\tAssert(newval != NULL);\n\t\taddJsonbToParseState(st, newval);\n\t\tdone = true;\n\t}\n\n\t/* iterate over the array elements */\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tJsonbIteratorToken r;\n\n\t\tif (i == idx && level < path_len)\n\t\t{\n\t\t\tif (level == path_len - 1)\n\t\t\t{\n\t\t\t\tr = JsonbIteratorNext(it, &v, true);\t/* skip */\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_BEFORE | JB_PATH_CREATE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\t/*\n\t\t\t\t * We should keep current value only in case of\n\t\t\t\t * JB_PATH_INSERT_BEFORE or JB_PATH_INSERT_AFTER because\n\t\t\t\t * otherwise it should be deleted or replaced\n\t\t\t\t */\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_INSERT_BEFORE))\n\t\t\t\t\t(void) pushJsonbValue(st, r, &v);\n\n\t\t\t\tif (op_type & (JB_PATH_INSERT_AFTER | JB_PATH_REPLACE))\n\t\t\t\t\taddJsonbToParseState(st, newval);\n\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\t(void) setPath(it, path_elems, path_nulls, path_len,\n\t\t\t\t\t\t\t   st, level + 1, newval, op_type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\n\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t{\n\t\t\t\tint\t\t\twalking_level = 1;\n\n\t\t\t\twhile (walking_level != 0)\n\t\t\t\t{\n\t\t\t\t\tr = JsonbIteratorNext(it, &v, false);\n\n\t\t\t\t\tif (r == WJB_BEGIN_ARRAY || r == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t++walking_level;\n\t\t\t\t\tif (r == WJB_END_ARRAY || r == WJB_END_OBJECT)\n\t\t\t\t\t\t--walking_level;\n\n\t\t\t\t\t(void) pushJsonbValue(st, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((op_type & JB_PATH_CREATE_OR_INSERT) && !done &&\n\t\t\t\tlevel == path_len - 1 && i == nelems - 1)\n\t\t\t{\n\t\t\t\taddJsonbToParseState(st, newval);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1))"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"path element at position %d is null\"",
            "level + 1"
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "IteratorConcat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4568-4670",
    "snippet": "static JsonbValue *\nIteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state)\n{\n\tJsonbValue\tv1,\n\t\t\t\tv2,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r1,\n\t\t\t\tr2,\n\t\t\t\trk1,\n\t\t\t\trk2;\n\n\tr1 = rk1 = JsonbIteratorNext(it1, &v1, false);\n\tr2 = rk2 = JsonbIteratorNext(it2, &v2, false);\n\n\t/*\n\t * Both elements are objects.\n\t */\n\tif (rk1 == WJB_BEGIN_OBJECT && rk2 == WJB_BEGIN_OBJECT)\n\t{\n\t\t/*\n\t\t * Append the all tokens from v1 to res, except last WJB_END_OBJECT\n\t\t * (because res will not be finished yet).\n\t\t */\n\t\tpushJsonbValue(state, r1, NULL);\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_OBJECT)\n\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t/*\n\t\t * Append the all tokens from v2 to res, include last WJB_END_OBJECT\n\t\t * (the concatenation will be completed).\n\t\t */\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_DONE)\n\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\t}\n\n\t/*\n\t * Both elements are arrays (either can be scalar).\n\t */\n\telse if (rk1 == WJB_BEGIN_ARRAY && rk2 == WJB_BEGIN_ARRAY)\n\t{\n\t\tpushJsonbValue(state, r1, NULL);\n\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r1 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, r1, &v1);\n\t\t}\n\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r2 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, WJB_ELEM, &v2);\n\t\t}\n\n\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL /* signal to sort */ );\n\t}\n\t/* have we got array || object or object || array? */\n\telse if (((rk1 == WJB_BEGIN_ARRAY && !(*it1)->isScalar) && rk2 == WJB_BEGIN_OBJECT) ||\n\t\t\t (rk1 == WJB_BEGIN_OBJECT && (rk2 == WJB_BEGIN_ARRAY && !(*it2)->isScalar)))\n\t{\n\n\t\tJsonbIterator **it_array = rk1 == WJB_BEGIN_ARRAY ? it1 : it2;\n\t\tJsonbIterator **it_object = rk1 == WJB_BEGIN_OBJECT ? it1 : it2;\n\n\t\tbool\t\tprepend = (rk1 == WJB_BEGIN_OBJECT);\n\n\t\tpushJsonbValue(state, WJB_BEGIN_ARRAY, NULL);\n\n\t\tif (prepend)\n\t\t{\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r1 = JsonbIteratorNext(it_object, &v1, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r1, r1 != WJB_END_OBJECT ? &v1 : NULL);\n\n\t\t\twhile ((r2 = JsonbIteratorNext(it_array, &v2, true)) != WJB_DONE)\n\t\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_ARRAY ? &v2 : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile ((r1 = JsonbIteratorNext(it_array, &v1, true)) != WJB_END_ARRAY)\n\t\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r2 = JsonbIteratorNext(it_object, &v2, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\n\t\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This must be scalar || object or object || scalar, as that's all\n\t\t * that's left. Both of these make no sense, so error out.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid concatenation of jsonb objects\")));\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid concatenation of jsonb objects\"))"
          ],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid concatenation of jsonb objects\""
          ],
          "line": 4666
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "state",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 4655
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "it_object",
            "&v2",
            "true"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r2 == WJB_ELEM"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r1 == WJB_ELEM"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic JsonbValue *\nIteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state)\n{\n\tJsonbValue\tv1,\n\t\t\t\tv2,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r1,\n\t\t\t\tr2,\n\t\t\t\trk1,\n\t\t\t\trk2;\n\n\tr1 = rk1 = JsonbIteratorNext(it1, &v1, false);\n\tr2 = rk2 = JsonbIteratorNext(it2, &v2, false);\n\n\t/*\n\t * Both elements are objects.\n\t */\n\tif (rk1 == WJB_BEGIN_OBJECT && rk2 == WJB_BEGIN_OBJECT)\n\t{\n\t\t/*\n\t\t * Append the all tokens from v1 to res, except last WJB_END_OBJECT\n\t\t * (because res will not be finished yet).\n\t\t */\n\t\tpushJsonbValue(state, r1, NULL);\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_OBJECT)\n\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t/*\n\t\t * Append the all tokens from v2 to res, include last WJB_END_OBJECT\n\t\t * (the concatenation will be completed).\n\t\t */\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_DONE)\n\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\t}\n\n\t/*\n\t * Both elements are arrays (either can be scalar).\n\t */\n\telse if (rk1 == WJB_BEGIN_ARRAY && rk2 == WJB_BEGIN_ARRAY)\n\t{\n\t\tpushJsonbValue(state, r1, NULL);\n\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r1 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, r1, &v1);\n\t\t}\n\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r2 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, WJB_ELEM, &v2);\n\t\t}\n\n\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL /* signal to sort */ );\n\t}\n\t/* have we got array || object or object || array? */\n\telse if (((rk1 == WJB_BEGIN_ARRAY && !(*it1)->isScalar) && rk2 == WJB_BEGIN_OBJECT) ||\n\t\t\t (rk1 == WJB_BEGIN_OBJECT && (rk2 == WJB_BEGIN_ARRAY && !(*it2)->isScalar)))\n\t{\n\n\t\tJsonbIterator **it_array = rk1 == WJB_BEGIN_ARRAY ? it1 : it2;\n\t\tJsonbIterator **it_object = rk1 == WJB_BEGIN_OBJECT ? it1 : it2;\n\n\t\tbool\t\tprepend = (rk1 == WJB_BEGIN_OBJECT);\n\n\t\tpushJsonbValue(state, WJB_BEGIN_ARRAY, NULL);\n\n\t\tif (prepend)\n\t\t{\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r1 = JsonbIteratorNext(it_object, &v1, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r1, r1 != WJB_END_OBJECT ? &v1 : NULL);\n\n\t\t\twhile ((r2 = JsonbIteratorNext(it_array, &v2, true)) != WJB_DONE)\n\t\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_ARRAY ? &v2 : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile ((r1 = JsonbIteratorNext(it_array, &v1, true)) != WJB_END_ARRAY)\n\t\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r2 = JsonbIteratorNext(it_object, &v2, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\n\t\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This must be scalar || object or object || scalar, as that's all\n\t\t * that's left. Both of these make no sense, so error out.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid concatenation of jsonb objects\")));\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "jsonb_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4521-4559",
    "snippet": "Datum\njsonb_insert(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *newval = PG_GETARG_JSONB_P(2);\n\tbool\t\tafter = PG_GETARG_BOOL(3);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\")));\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st, 0, newval,\n\t\t\t\t  after ? JB_PATH_INSERT_AFTER : JB_PATH_INSERT_BEFORE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JB_PATH_INSERT_AFTER\t\t\t0x0010",
      "#define JB_PATH_INSERT_BEFORE\t\t\t0x0008"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPath",
          "args": [
            "&it",
            "path_elems",
            "path_nulls",
            "path_len",
            "&st",
            "0",
            "newval",
            "after ? JB_PATH_INSERT_AFTER : JB_PATH_INSERT_BEFORE"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "setPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4686-4734",
          "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "path",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&path_elems",
            "&path_nulls",
            "&path_len"
          ],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\"))"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot set path in scalar\""
          ],
          "line": 4543
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 4536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "path"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "2"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_INSERT_AFTER\t\t\t0x0010\n#define JB_PATH_INSERT_BEFORE\t\t\t0x0008\n\nDatum\njsonb_insert(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *newval = PG_GETARG_JSONB_P(2);\n\tbool\t\tafter = PG_GETARG_BOOL(3);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\")));\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st, 0, newval,\n\t\t\t\t  after ? JB_PATH_INSERT_AFTER : JB_PATH_INSERT_BEFORE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_delete_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4476-4515",
    "snippet": "Datum\njsonb_delete_path(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete path in scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st,\n\t\t\t\t  0, NULL, JB_PATH_DELETE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JB_PATH_DELETE\t\t\t\t\t0x0002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4514
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPath",
          "args": [
            "&it",
            "path_elems",
            "path_nulls",
            "path_len",
            "&st",
            "0",
            "NULL",
            "JB_PATH_DELETE"
          ],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "setPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4686-4734",
          "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4507
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "path",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&path_elems",
            "&path_nulls",
            "&path_len"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "in"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete path in scalar\"))"
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot delete path in scalar\""
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "path"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_DELETE\t\t\t\t\t0x0002\n\nDatum\njsonb_delete_path(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete path in scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st,\n\t\t\t\t  0, NULL, JB_PATH_DELETE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4429-4470",
    "snippet": "Datum\njsonb_set(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *newval = PG_GETARG_JSONB_P(2);\n\tbool\t\tcreate = PG_GETARG_BOOL(3);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0 && !create)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st,\n\t\t\t\t  0, newval, create ? JB_PATH_CREATE : JB_PATH_REPLACE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define JB_PATH_REPLACE\t\t\t\t\t0x0004",
      "#define JB_PATH_CREATE\t\t\t\t\t0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setPath",
          "args": [
            "&it",
            "path_elems",
            "path_nulls",
            "path_len",
            "&st",
            "0",
            "newval",
            "create ? JB_PATH_CREATE : JB_PATH_REPLACE"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "setPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4686-4734",
          "snippet": "static JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);",
            "static void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);",
            "static void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic JsonbValue *setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval,\n\t\tint op_type);\nstatic void setPathObject(JsonbIterator **it, Datum *path_elems,\n\t\t\t  bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t  int level,\n\t\t\t  Jsonb *newval, uint32 npairs, int op_type);\nstatic void setPathArray(JsonbIterator **it, Datum *path_elems,\n\t\t\t bool *path_nulls, int path_len, JsonbParseState **st,\n\t\t\t int level, Jsonb *newval, uint32 nelems, int op_type);\n\nstatic JsonbValue *\nsetPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, int op_type)\n{\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tJsonbValue *res;\n\n\tcheck_stack_depth();\n\n\tif (path_nulls[level])\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"path element at position %d is null\",\n\t\t\t\t\t\tlevel + 1)));\n\n\tr = JsonbIteratorNext(it, &v, false);\n\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, op_type);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized iterator result: %d\", (int) r);\n\t\t\tres = NULL;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "path",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&path_elems",
            "&path_nulls",
            "&path_len"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "in"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\"))"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot set path in scalar\""
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "path"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "2"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define JB_PATH_REPLACE\t\t\t\t\t0x0004\n#define JB_PATH_CREATE\t\t\t\t\t0x0001\n\nDatum\njsonb_set(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *newval = PG_GETARG_JSONB_P(2);\n\tbool\t\tcreate = PG_GETARG_BOOL(3);\n\tJsonbValue *res = NULL;\n\tDatum\t   *path_elems;\n\tbool\t   *path_nulls;\n\tint\t\t\tpath_len;\n\tJsonbIterator *it;\n\tJsonbParseState *st = NULL;\n\n\tif (ARR_NDIM(path) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot set path in scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0 && !create)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &path_elems, &path_nulls, &path_len);\n\n\tif (path_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tres = setPath(&it, path_elems, path_nulls, path_len, &st,\n\t\t\t\t  0, newval, create ? JB_PATH_CREATE : JB_PATH_REPLACE);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_delete_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4364-4423",
    "snippet": "Datum\njsonb_delete_idx(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tint\t\t\tidx = PG_GETARG_INT32(1);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tuint32\t\ti = 0,\n\t\t\t\tn;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from object using integer index\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tr = JsonbIteratorNext(&it, &v, false);\n\tAssert(r == WJB_BEGIN_ARRAY);\n\tn = v.val.array.nElems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > n)\n\t\t\tidx = n;\n\t\telse\n\t\t\tidx = n + idx;\n\t}\n\n\tif (idx >= n)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tpushJsonbValue(&state, r, NULL);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, true)) != WJB_DONE)\n\t{\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tif (i++ == idx)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&state",
            "r",
            "r < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "true"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r == WJB_BEGIN_ARRAY"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4390
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "in"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from object using integer index\"))"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot delete from object using integer index\""
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "in"
          ],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\"))"
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 4368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njsonb_delete_idx(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tint\t\t\tidx = PG_GETARG_INT32(1);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tuint32\t\ti = 0,\n\t\t\t\tn;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from object using integer index\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tr = JsonbIteratorNext(&it, &v, false);\n\tAssert(r == WJB_BEGIN_ARRAY);\n\tn = v.val.array.nElems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > n)\n\t\t\tidx = n;\n\t\telse\n\t\t\tidx = n + idx;\n\t}\n\n\tif (idx >= n)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tpushJsonbValue(&state, r, NULL);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, true)) != WJB_DONE)\n\t{\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tif (i++ == idx)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_delete_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4277-4355",
    "snippet": "Datum\njsonb_delete_array(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tDatum\t   *keys_elems;\n\tbool\t   *keys_nulls;\n\tint\t\t\tkeys_len;\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tbool\t\tskipNested = false;\n\tJsonbIteratorToken r;\n\n\tif (ARR_NDIM(keys) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &keys_elems, &keys_nulls, &keys_len);\n\n\tif (keys_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif ((r == WJB_ELEM || r == WJB_KEY) && v.type == jbvString)\n\t\t{\n\t\t\tint\t\t\ti;\n\t\t\tbool\t\tfound = false;\n\n\t\t\tfor (i = 0; i < keys_len; i++)\n\t\t\t{\n\t\t\t\tchar\t   *keyptr;\n\t\t\t\tint\t\t\tkeylen;\n\n\t\t\t\tif (keys_nulls[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tkeyptr = VARDATA_ANY(keys_elems[i]);\n\t\t\t\tkeylen = VARSIZE_ANY_EXHDR(keys_elems[i]);\n\t\t\t\tif (keylen == v.val.string.len &&\n\t\t\t\t\tmemcmp(keyptr, v.val.string.val, keylen) == 0)\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\t/* skip corresponding value as well */\n\t\t\t\tif (r == WJB_KEY)\n\t\t\t\t\t(void) JsonbIteratorNext(&it, &v, true);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&state",
            "r",
            "r < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "true"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "keyptr",
            "v.val.string.val",
            "keylen"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "keys_elems[i]"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "keys_elems[i]"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "keys",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&keys_elems",
            "&keys_nulls",
            "&keys_len"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "in"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\"))"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot delete from scalar\""
          ],
          "line": 4300
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "keys"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njsonb_delete_array(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tDatum\t   *keys_elems;\n\tbool\t   *keys_nulls;\n\tint\t\t\tkeys_len;\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tbool\t\tskipNested = false;\n\tJsonbIteratorToken r;\n\n\tif (ARR_NDIM(keys) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &keys_elems, &keys_nulls, &keys_len);\n\n\tif (keys_len == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif ((r == WJB_ELEM || r == WJB_KEY) && v.type == jbvString)\n\t\t{\n\t\t\tint\t\t\ti;\n\t\t\tbool\t\tfound = false;\n\n\t\t\tfor (i = 0; i < keys_len; i++)\n\t\t\t{\n\t\t\t\tchar\t   *keyptr;\n\t\t\t\tint\t\t\tkeylen;\n\n\t\t\t\tif (keys_nulls[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tkeyptr = VARDATA_ANY(keys_elems[i]);\n\t\t\t\tkeylen = VARSIZE_ANY_EXHDR(keys_elems[i]);\n\t\t\t\tif (keylen == v.val.string.len &&\n\t\t\t\t\tmemcmp(keyptr, v.val.string.val, keylen) == 0)\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\t/* skip corresponding value as well */\n\t\t\t\tif (r == WJB_KEY)\n\t\t\t\t\t(void) JsonbIteratorNext(&it, &v, true);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4224-4269",
    "snippet": "Datum\njsonb_delete(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tchar\t   *keyptr = VARDATA_ANY(key);\n\tint\t\t\tkeylen = VARSIZE_ANY_EXHDR(key);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tbool\t\tskipNested = false;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif ((r == WJB_ELEM || r == WJB_KEY) &&\n\t\t\t(v.type == jbvString && keylen == v.val.string.len &&\n\t\t\t memcmp(keyptr, v.val.string.val, keylen) == 0))\n\t\t{\n\t\t\t/* skip corresponding value as well */\n\t\t\tif (r == WJB_KEY)\n\t\t\t\t(void) JsonbIteratorNext(&it, &v, true);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&state",
            "r",
            "r < WJB_BEGIN_ARRAY ? &v : NULL"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "true"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "keyptr",
            "v.val.string.val",
            "keylen"
          ],
          "line": 4254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "in"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "in"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\"))"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot delete from scalar\""
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "key"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njsonb_delete(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tchar\t   *keyptr = VARDATA_ANY(key);\n\tint\t\t\tkeylen = VARSIZE_ANY_EXHDR(key);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\tbool\t\tskipNested = false;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB_P(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif ((r == WJB_ELEM || r == WJB_KEY) &&\n\t\t\t(v.type == jbvString && keylen == v.val.string.len &&\n\t\t\t memcmp(keyptr, v.val.string.val, keylen) == 0))\n\t\t{\n\t\t\t/* skip corresponding value as well */\n\t\t\tif (r == WJB_KEY)\n\t\t\t\t(void) JsonbIteratorNext(&it, &v, true);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4183-4215",
    "snippet": "Datum\njsonb_concat(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb1 = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jb2 = PG_GETARG_JSONB_P(1);\n\tJsonbParseState *state = NULL;\n\tJsonbValue *res;\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\t/*\n\t * If one of the jsonb is empty, just return the other if it's not scalar\n\t * and both are of the same kind.  If it's a scalar or they are of\n\t * different kinds we need to perform the concatenation even if one is\n\t * empty.\n\t */\n\tif (JB_ROOT_IS_OBJECT(jb1) == JB_ROOT_IS_OBJECT(jb2))\n\t{\n\t\tif (JB_ROOT_COUNT(jb1) == 0 && !JB_ROOT_IS_SCALAR(jb2))\n\t\t\tPG_RETURN_JSONB_P(jb2);\n\t\telse if (JB_ROOT_COUNT(jb2) == 0 && !JB_ROOT_IS_SCALAR(jb1))\n\t\t\tPG_RETURN_JSONB_P(jb1);\n\t}\n\n\tit1 = JsonbIteratorInit(&jb1->root);\n\tit2 = JsonbIteratorInit(&jb2->root);\n\n\tres = IteratorConcat(&it1, &it2, &state);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IteratorConcat",
          "args": [
            "&it1",
            "&it2",
            "&state"
          ],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "IteratorConcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "4568-4670",
          "snippet": "static JsonbValue *\nIteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state)\n{\n\tJsonbValue\tv1,\n\t\t\t\tv2,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r1,\n\t\t\t\tr2,\n\t\t\t\trk1,\n\t\t\t\trk2;\n\n\tr1 = rk1 = JsonbIteratorNext(it1, &v1, false);\n\tr2 = rk2 = JsonbIteratorNext(it2, &v2, false);\n\n\t/*\n\t * Both elements are objects.\n\t */\n\tif (rk1 == WJB_BEGIN_OBJECT && rk2 == WJB_BEGIN_OBJECT)\n\t{\n\t\t/*\n\t\t * Append the all tokens from v1 to res, except last WJB_END_OBJECT\n\t\t * (because res will not be finished yet).\n\t\t */\n\t\tpushJsonbValue(state, r1, NULL);\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_OBJECT)\n\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t/*\n\t\t * Append the all tokens from v2 to res, include last WJB_END_OBJECT\n\t\t * (the concatenation will be completed).\n\t\t */\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_DONE)\n\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\t}\n\n\t/*\n\t * Both elements are arrays (either can be scalar).\n\t */\n\telse if (rk1 == WJB_BEGIN_ARRAY && rk2 == WJB_BEGIN_ARRAY)\n\t{\n\t\tpushJsonbValue(state, r1, NULL);\n\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r1 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, r1, &v1);\n\t\t}\n\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r2 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, WJB_ELEM, &v2);\n\t\t}\n\n\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL /* signal to sort */ );\n\t}\n\t/* have we got array || object or object || array? */\n\telse if (((rk1 == WJB_BEGIN_ARRAY && !(*it1)->isScalar) && rk2 == WJB_BEGIN_OBJECT) ||\n\t\t\t (rk1 == WJB_BEGIN_OBJECT && (rk2 == WJB_BEGIN_ARRAY && !(*it2)->isScalar)))\n\t{\n\n\t\tJsonbIterator **it_array = rk1 == WJB_BEGIN_ARRAY ? it1 : it2;\n\t\tJsonbIterator **it_object = rk1 == WJB_BEGIN_OBJECT ? it1 : it2;\n\n\t\tbool\t\tprepend = (rk1 == WJB_BEGIN_OBJECT);\n\n\t\tpushJsonbValue(state, WJB_BEGIN_ARRAY, NULL);\n\n\t\tif (prepend)\n\t\t{\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r1 = JsonbIteratorNext(it_object, &v1, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r1, r1 != WJB_END_OBJECT ? &v1 : NULL);\n\n\t\t\twhile ((r2 = JsonbIteratorNext(it_array, &v2, true)) != WJB_DONE)\n\t\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_ARRAY ? &v2 : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile ((r1 = JsonbIteratorNext(it_array, &v1, true)) != WJB_END_ARRAY)\n\t\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r2 = JsonbIteratorNext(it_object, &v2, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\n\t\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This must be scalar || object or object || scalar, as that's all\n\t\t * that's left. Both of these make no sense, so error out.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid concatenation of jsonb objects\")));\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic JsonbValue *\nIteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state)\n{\n\tJsonbValue\tv1,\n\t\t\t\tv2,\n\t\t\t   *res = NULL;\n\tJsonbIteratorToken r1,\n\t\t\t\tr2,\n\t\t\t\trk1,\n\t\t\t\trk2;\n\n\tr1 = rk1 = JsonbIteratorNext(it1, &v1, false);\n\tr2 = rk2 = JsonbIteratorNext(it2, &v2, false);\n\n\t/*\n\t * Both elements are objects.\n\t */\n\tif (rk1 == WJB_BEGIN_OBJECT && rk2 == WJB_BEGIN_OBJECT)\n\t{\n\t\t/*\n\t\t * Append the all tokens from v1 to res, except last WJB_END_OBJECT\n\t\t * (because res will not be finished yet).\n\t\t */\n\t\tpushJsonbValue(state, r1, NULL);\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_OBJECT)\n\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t/*\n\t\t * Append the all tokens from v2 to res, include last WJB_END_OBJECT\n\t\t * (the concatenation will be completed).\n\t\t */\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_DONE)\n\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\t}\n\n\t/*\n\t * Both elements are arrays (either can be scalar).\n\t */\n\telse if (rk1 == WJB_BEGIN_ARRAY && rk2 == WJB_BEGIN_ARRAY)\n\t{\n\t\tpushJsonbValue(state, r1, NULL);\n\n\t\twhile ((r1 = JsonbIteratorNext(it1, &v1, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r1 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, r1, &v1);\n\t\t}\n\n\t\twhile ((r2 = JsonbIteratorNext(it2, &v2, true)) != WJB_END_ARRAY)\n\t\t{\n\t\t\tAssert(r2 == WJB_ELEM);\n\t\t\tpushJsonbValue(state, WJB_ELEM, &v2);\n\t\t}\n\n\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL /* signal to sort */ );\n\t}\n\t/* have we got array || object or object || array? */\n\telse if (((rk1 == WJB_BEGIN_ARRAY && !(*it1)->isScalar) && rk2 == WJB_BEGIN_OBJECT) ||\n\t\t\t (rk1 == WJB_BEGIN_OBJECT && (rk2 == WJB_BEGIN_ARRAY && !(*it2)->isScalar)))\n\t{\n\n\t\tJsonbIterator **it_array = rk1 == WJB_BEGIN_ARRAY ? it1 : it2;\n\t\tJsonbIterator **it_object = rk1 == WJB_BEGIN_OBJECT ? it1 : it2;\n\n\t\tbool\t\tprepend = (rk1 == WJB_BEGIN_OBJECT);\n\n\t\tpushJsonbValue(state, WJB_BEGIN_ARRAY, NULL);\n\n\t\tif (prepend)\n\t\t{\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r1 = JsonbIteratorNext(it_object, &v1, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r1, r1 != WJB_END_OBJECT ? &v1 : NULL);\n\n\t\t\twhile ((r2 = JsonbIteratorNext(it_array, &v2, true)) != WJB_DONE)\n\t\t\t\tres = pushJsonbValue(state, r2, r2 != WJB_END_ARRAY ? &v2 : NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile ((r1 = JsonbIteratorNext(it_array, &v1, true)) != WJB_END_ARRAY)\n\t\t\t\tpushJsonbValue(state, r1, &v1);\n\n\t\t\tpushJsonbValue(state, WJB_BEGIN_OBJECT, NULL);\n\t\t\twhile ((r2 = JsonbIteratorNext(it_object, &v2, true)) != WJB_DONE)\n\t\t\t\tpushJsonbValue(state, r2, r2 != WJB_END_OBJECT ? &v2 : NULL);\n\n\t\t\tres = pushJsonbValue(state, WJB_END_ARRAY, NULL);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This must be scalar || object or object || scalar, as that's all\n\t\t * that's left. Both of these make no sense, so error out.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid concatenation of jsonb objects\")));\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb2->root"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "jb1"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb1"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb2"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "jb2"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb2"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb1"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb2"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb1"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njsonb_concat(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb1 = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jb2 = PG_GETARG_JSONB_P(1);\n\tJsonbParseState *state = NULL;\n\tJsonbValue *res;\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\t/*\n\t * If one of the jsonb is empty, just return the other if it's not scalar\n\t * and both are of the same kind.  If it's a scalar or they are of\n\t * different kinds we need to perform the concatenation even if one is\n\t * empty.\n\t */\n\tif (JB_ROOT_IS_OBJECT(jb1) == JB_ROOT_IS_OBJECT(jb2))\n\t{\n\t\tif (JB_ROOT_COUNT(jb1) == 0 && !JB_ROOT_IS_SCALAR(jb2))\n\t\t\tPG_RETURN_JSONB_P(jb2);\n\t\telse if (JB_ROOT_COUNT(jb2) == 0 && !JB_ROOT_IS_SCALAR(jb1))\n\t\t\tPG_RETURN_JSONB_P(jb1);\n\t}\n\n\tit1 = JsonbIteratorInit(&jb1->root);\n\tit2 = JsonbIteratorInit(&jb2->root);\n\n\tres = IteratorConcat(&it1, &it2, &state);\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB_P(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "jsonb_pretty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4167-4176",
    "snippet": "Datum\njsonb_pretty(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tStringInfo\tstr = makeStringInfo();\n\n\tJsonbToCStringIndent(str, &jb->root, VARSIZE(jb));\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(str->data, str->len));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(str->data, str->len)"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str->data",
            "str->len"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCStringIndent",
          "args": [
            "str",
            "&jb->root",
            "VARSIZE(jb)"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jb"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_pretty(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tStringInfo\tstr = makeStringInfo();\n\n\tJsonbToCStringIndent(str, &jb->root, VARSIZE(jb));\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(str->data, str->len));\n}"
  },
  {
    "function_name": "addJsonbToParseState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4119-4160",
    "snippet": "static void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "jbps",
            "type",
            "NULL"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected parent of nested structure\""
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "v.type == jbvArray"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "o->type == jbvArray || o->type == jbvObject"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic void\naddJsonbToParseState(JsonbParseState **jbps, Jsonb *jb)\n{\n\tJsonbIterator *it;\n\tJsonbValue *o = &(*jbps)->contVal;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\tAssert(o->type == jbvArray || o->type == jbvObject);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t{\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* skip array header */\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, false);\t/* fetch scalar value */\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t(void) pushJsonbValue(jbps, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t\t{\n\t\t\tif (type == WJB_KEY || type == WJB_VALUE || type == WJB_ELEM)\n\t\t\t\t(void) pushJsonbValue(jbps, type, &v);\n\t\t\telse\n\t\t\t\t(void) pushJsonbValue(jbps, type, NULL);\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "jsonb_strip_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4057-4108",
    "snippet": "Datum\njsonb_strip_nulls(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbParseState *parseState = NULL;\n\tJsonbValue *res = NULL;\n\tJsonbValue\tv,\n\t\t\t\tk;\n\tJsonbIteratorToken type;\n\tbool\t\tlast_was_key = false;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tPG_RETURN_POINTER(jb);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tAssert(!(type == WJB_KEY && last_was_key));\n\n\t\tif (type == WJB_KEY)\n\t\t{\n\t\t\t/* stash the key until we know if it has a null value */\n\t\t\tk = v;\n\t\t\tlast_was_key = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (last_was_key)\n\t\t{\n\t\t\t/* if the last element was a key this one can't be */\n\t\t\tlast_was_key = false;\n\n\t\t\t/* skip this field if value is null */\n\t\t\tif (type == WJB_VALUE && v.type == jbvNull)\n\t\t\t\tcontinue;\n\n\t\t\t/* otherwise, do a delayed push of the key */\n\t\t\t(void) pushJsonbValue(&parseState, WJB_KEY, &k);\n\t\t}\n\n\t\tif (type == WJB_VALUE || type == WJB_ELEM)\n\t\t\tres = pushJsonbValue(&parseState, type, &v);\n\t\telse\n\t\t\tres = pushJsonbValue(&parseState, type, NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(res)"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "res"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "res != NULL"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&parseState",
            "type",
            "NULL"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(type == WJB_KEY && last_was_key)"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "jb"
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_strip_nulls(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbParseState *parseState = NULL;\n\tJsonbValue *res = NULL;\n\tJsonbValue\tv,\n\t\t\t\tk;\n\tJsonbIteratorToken type;\n\tbool\t\tlast_was_key = false;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tPG_RETURN_POINTER(jb);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tAssert(!(type == WJB_KEY && last_was_key));\n\n\t\tif (type == WJB_KEY)\n\t\t{\n\t\t\t/* stash the key until we know if it has a null value */\n\t\t\tk = v;\n\t\t\tlast_was_key = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (last_was_key)\n\t\t{\n\t\t\t/* if the last element was a key this one can't be */\n\t\t\tlast_was_key = false;\n\n\t\t\t/* skip this field if value is null */\n\t\t\tif (type == WJB_VALUE && v.type == jbvNull)\n\t\t\t\tcontinue;\n\n\t\t\t/* otherwise, do a delayed push of the key */\n\t\t\t(void) pushJsonbValue(&parseState, WJB_KEY, &k);\n\t\t}\n\n\t\tif (type == WJB_VALUE || type == WJB_ELEM)\n\t\t\tres = pushJsonbValue(&parseState, type, &v);\n\t\telse\n\t\t\tres = pushJsonbValue(&parseState, type, NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(res));\n}"
  },
  {
    "function_name": "json_strip_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4022-4052",
    "snippet": "Datum\njson_strip_nulls(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tStripnullState *state;\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(StripnullState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->strval = makeStringInfo();\n\tstate->skip_next_null = false;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = sn_object_start;\n\tsem->object_end = sn_object_end;\n\tsem->array_start = sn_array_start;\n\tsem->array_end = sn_array_end;\n\tsem->scalar = sn_scalar;\n\tsem->array_element_start = sn_array_element_start;\n\tsem->object_field_start = sn_object_field_start;\n\n\tpg_parse_json(lex, sem);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(state->strval->data,\n\t\t\t\t\t\t\t\t\t\t\t  state->strval->len));\n\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(state->strval->data,\n\t\t\t\t\t\t\t\t\t\t\t  state->strval->len)"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "state->strval->data",
            "state->strval->len"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 4047
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 4032
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njson_strip_nulls(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tStripnullState *state;\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(StripnullState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->strval = makeStringInfo();\n\tstate->skip_next_null = false;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = sn_object_start;\n\tsem->object_end = sn_object_end;\n\tsem->array_start = sn_array_start;\n\tsem->array_end = sn_array_end;\n\tsem->scalar = sn_scalar;\n\tsem->array_element_start = sn_array_element_start;\n\tsem->object_field_start = sn_object_field_start;\n\n\tpg_parse_json(lex, sem);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(state->strval->data,\n\t\t\t\t\t\t\t\t\t\t\t  state->strval->len));\n\n}"
  },
  {
    "function_name": "sn_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "4001-4017",
    "snippet": "static void\nsn_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (_state->skip_next_null)\n\t{\n\t\tAssert(tokentype == JSON_TOKEN_NULL);\n\t\t_state->skip_next_null = false;\n\t\treturn;\n\t}\n\n\tif (tokentype == JSON_TOKEN_STRING)\n\t\tescape_json(_state->strval, token);\n\telse\n\t\tappendStringInfoString(_state->strval, token);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "_state->strval",
            "token"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "_state->strval",
            "token"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tokentype == JSON_TOKEN_NULL"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nsn_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (_state->skip_next_null)\n\t{\n\t\tAssert(tokentype == JSON_TOKEN_NULL);\n\t\t_state->skip_next_null = false;\n\t\treturn;\n\t}\n\n\tif (tokentype == JSON_TOKEN_STRING)\n\t\tescape_json(_state->strval, token);\n\telse\n\t\tappendStringInfoString(_state->strval, token);\n}"
  },
  {
    "function_name": "sn_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3992-3999",
    "snippet": "static void\nsn_array_element_start(void *state, bool isnull)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '[')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "','"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nsn_array_element_start(void *state, bool isnull)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (_state->strval->data[_state->strval->len - 1] != '[')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n}"
  },
  {
    "function_name": "sn_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3964-3990",
    "snippet": "static void\nsn_object_field_start(void *state, char *fname, bool isnull)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (isnull)\n\t{\n\t\t/*\n\t\t * The next thing must be a scalar or isnull couldn't be true, so\n\t\t * there is no danger of this state being carried down into a nested\n\t\t * object or array. The flag will be reset in the scalar action.\n\t\t */\n\t\t_state->skip_next_null = true;\n\t\treturn;\n\t}\n\n\tif (_state->strval->data[_state->strval->len - 1] != '{')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n\n\t/*\n\t * Unfortunately we don't have the quoted and escaped string any more, so\n\t * we have to re-escape it.\n\t */\n\tescape_json(_state->strval, fname);\n\n\tappendStringInfoCharMacro(_state->strval, ':');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "':'"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "_state->strval",
            "fname"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "','"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nsn_object_field_start(void *state, char *fname, bool isnull)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tif (isnull)\n\t{\n\t\t/*\n\t\t * The next thing must be a scalar or isnull couldn't be true, so\n\t\t * there is no danger of this state being carried down into a nested\n\t\t * object or array. The flag will be reset in the scalar action.\n\t\t */\n\t\t_state->skip_next_null = true;\n\t\treturn;\n\t}\n\n\tif (_state->strval->data[_state->strval->len - 1] != '{')\n\t\tappendStringInfoCharMacro(_state->strval, ',');\n\n\t/*\n\t * Unfortunately we don't have the quoted and escaped string any more, so\n\t * we have to re-escape it.\n\t */\n\tescape_json(_state->strval, fname);\n\n\tappendStringInfoCharMacro(_state->strval, ':');\n}"
  },
  {
    "function_name": "sn_array_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3956-3962",
    "snippet": "static void\nsn_array_end(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, ']');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "']'"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nsn_array_end(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, ']');\n}"
  },
  {
    "function_name": "sn_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3948-3954",
    "snippet": "static void\nsn_array_start(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '[');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'['"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nsn_array_start(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '[');\n}"
  },
  {
    "function_name": "sn_object_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3940-3946",
    "snippet": "static void\nsn_object_end(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '}');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'}'"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nsn_object_end(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '}');\n}"
  },
  {
    "function_name": "sn_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3932-3938",
    "snippet": "static void\nsn_object_start(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '{');\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "_state->strval",
            "'{'"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nsn_object_start(void *state)\n{\n\tStripnullState *_state = (StripnullState *) state;\n\n\tappendStringInfoCharMacro(_state->strval, '{');\n}"
  },
  {
    "function_name": "findJsonbValueFromContainerLen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3910-3921",
    "snippet": "static JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "findJsonbValueFromContainer",
          "args": [
            "container",
            "flags",
            "&k"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "326-411",
          "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\n\nstatic JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}"
  },
  {
    "function_name": "populate_recordset_object_field_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3858-3905",
    "snippet": "static void\npopulate_recordset_object_field_end(void *state, char *fname, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tJsonHashEntry *hashentry;\n\tbool\t\tfound;\n\n\t/*\n\t * Ignore nested fields.\n\t */\n\tif (_state->lex->lex_level > 2)\n\t\treturn;\n\n\t/*\n\t * Ignore field names >= NAMEDATALEN - they can't match a record field.\n\t * (Note: without this test, the hash code would truncate the string at\n\t * NAMEDATALEN-1, and could then match against a similarly-truncated\n\t * record field name.  That would be a reasonable behavior, but this code\n\t * has previously insisted on exact equality, so we keep this behavior.)\n\t */\n\tif (strlen(fname) >= NAMEDATALEN)\n\t\treturn;\n\n\thashentry = hash_search(_state->json_hash, fname, HASH_ENTER, &found);\n\n\t/*\n\t * found being true indicates a duplicate. We don't do anything about\n\t * that, a later field with the same name overrides the earlier field.\n\t */\n\n\thashentry->type = _state->saved_token_type;\n\tAssert(isnull == (hashentry->type == JSON_TOKEN_NULL));\n\n\tif (_state->save_json_start != NULL)\n\t{\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - _state->save_json_start;\n\t\tchar\t   *val = palloc((len + 1) * sizeof(char));\n\n\t\tmemcpy(val, _state->save_json_start, len);\n\t\tval[len] = '\\0';\n\t\thashentry->val = val;\n\t}\n\telse\n\t{\n\t\t/* must have had a scalar instead */\n\t\thashentry->val = _state->saved_scalar;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "_state->save_json_start",
            "len"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len + 1) * sizeof(char)"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "isnull == (hashentry->type == JSON_TOKEN_NULL)"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "_state->json_hash",
            "fname",
            "HASH_ENTER",
            "&found"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\npopulate_recordset_object_field_end(void *state, char *fname, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tJsonHashEntry *hashentry;\n\tbool\t\tfound;\n\n\t/*\n\t * Ignore nested fields.\n\t */\n\tif (_state->lex->lex_level > 2)\n\t\treturn;\n\n\t/*\n\t * Ignore field names >= NAMEDATALEN - they can't match a record field.\n\t * (Note: without this test, the hash code would truncate the string at\n\t * NAMEDATALEN-1, and could then match against a similarly-truncated\n\t * record field name.  That would be a reasonable behavior, but this code\n\t * has previously insisted on exact equality, so we keep this behavior.)\n\t */\n\tif (strlen(fname) >= NAMEDATALEN)\n\t\treturn;\n\n\thashentry = hash_search(_state->json_hash, fname, HASH_ENTER, &found);\n\n\t/*\n\t * found being true indicates a duplicate. We don't do anything about\n\t * that, a later field with the same name overrides the earlier field.\n\t */\n\n\thashentry->type = _state->saved_token_type;\n\tAssert(isnull == (hashentry->type == JSON_TOKEN_NULL));\n\n\tif (_state->save_json_start != NULL)\n\t{\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - _state->save_json_start;\n\t\tchar\t   *val = palloc((len + 1) * sizeof(char));\n\n\t\tmemcpy(val, _state->save_json_start, len);\n\t\tval[len] = '\\0';\n\t\thashentry->val = val;\n\t}\n\telse\n\t{\n\t\t/* must have had a scalar instead */\n\t\thashentry->val = _state->saved_scalar;\n\t}\n}"
  },
  {
    "function_name": "populate_recordset_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3837-3856",
    "snippet": "static void\npopulate_recordset_object_field_start(void *state, char *fname, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level > 2)\n\t\treturn;\n\n\t_state->saved_token_type = _state->lex->token_type;\n\n\tif (_state->lex->token_type == JSON_TOKEN_ARRAY_START ||\n\t\t_state->lex->token_type == JSON_TOKEN_OBJECT_START)\n\t{\n\t\t_state->save_json_start = _state->lex->token_start;\n\t}\n\telse\n\t{\n\t\t_state->save_json_start = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\npopulate_recordset_object_field_start(void *state, char *fname, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level > 2)\n\t\treturn;\n\n\t_state->saved_token_type = _state->lex->token_type;\n\n\tif (_state->lex->token_type == JSON_TOKEN_ARRAY_START ||\n\t\t_state->lex->token_type == JSON_TOKEN_OBJECT_START)\n\t{\n\t\t_state->save_json_start = _state->lex->token_start;\n\t}\n\telse\n\t{\n\t\t_state->save_json_start = NULL;\n\t}\n}"
  },
  {
    "function_name": "populate_recordset_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3822-3835",
    "snippet": "static void\npopulate_recordset_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name)));\n\n\tif (_state->lex->lex_level == 2)\n\t\t_state->saved_scalar = token;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name))"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on a scalar\"",
            "_state->function_name"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\npopulate_recordset_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name)));\n\n\tif (_state->lex->lex_level == 2)\n\t\t_state->saved_scalar = token;\n}"
  },
  {
    "function_name": "populate_recordset_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3816-3820",
    "snippet": "static void\npopulate_recordset_array_start(void *state)\n{\n\t/* nothing to do */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_array_start(void *state)\n{\n\t/* nothing to do */\n}"
  },
  {
    "function_name": "populate_recordset_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3803-3814",
    "snippet": "static void\npopulate_recordset_array_element_start(void *state, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level == 1 &&\n\t\t_state->lex->token_type != JSON_TOKEN_OBJECT_START)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t_state->function_name)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t_state->function_name))"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument of %s must be an array of objects\"",
            "_state->function_name"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3811
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\npopulate_recordset_array_element_start(void *state, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level == 1 &&\n\t\t_state->lex->token_type != JSON_TOKEN_OBJECT_START)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t_state->function_name)));\n}"
  },
  {
    "function_name": "populate_recordset_object_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3782-3801",
    "snippet": "static void\npopulate_recordset_object_end(void *state)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tJsObject\tobj;\n\n\t/* Nested objects require no special processing */\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\tobj.is_json = true;\n\tobj.val.json_hash = _state->json_hash;\n\n\t/* Otherwise, construct and return a tuple based on this level-1 object */\n\tpopulate_recordset_record(_state, &obj);\n\n\t/* Done with hash for this object */\n\thash_destroy(_state->json_hash);\n\t_state->json_hash = NULL;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
      "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_destroy",
          "args": [
            "_state->json_hash"
          ],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "hash_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "813-830",
          "snippet": "void\nhash_destroy(HTAB *hashp)\n{\n\tif (hashp != NULL)\n\t{\n\t\t/* allocation method must be one we know how to free, too */\n\t\tAssert(hashp->alloc == DynaHashAlloc);\n\t\t/* so this hashtable must have it's own context */\n\t\tAssert(hashp->hcxt != NULL);\n\n\t\thash_stats(\"destroy\", hashp);\n\n\t\t/*\n\t\t * Free everything by destroying the hash table's memory context.\n\t\t */\n\t\tMemoryContextDelete(hashp->hcxt);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_destroy(HTAB *hashp)\n{\n\tif (hashp != NULL)\n\t{\n\t\t/* allocation method must be one we know how to free, too */\n\t\tAssert(hashp->alloc == DynaHashAlloc);\n\t\t/* so this hashtable must have it's own context */\n\t\tAssert(hashp->hcxt != NULL);\n\n\t\thash_stats(\"destroy\", hashp);\n\n\t\t/*\n\t\t * Free everything by destroying the hash table's memory context.\n\t\t */\n\t\tMemoryContextDelete(hashp->hcxt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_recordset_record",
          "args": [
            "_state",
            "&obj"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3522-3553",
          "snippet": "static void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_object_end(void *state)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tJsObject\tobj;\n\n\t/* Nested objects require no special processing */\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\tobj.is_json = true;\n\tobj.val.json_hash = _state->json_hash;\n\n\t/* Otherwise, construct and return a tuple based on this level-1 object */\n\tpopulate_recordset_record(_state, &obj);\n\n\t/* Done with hash for this object */\n\thash_destroy(_state->json_hash);\n\t_state->json_hash = NULL;\n}"
  },
  {
    "function_name": "populate_recordset_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3753-3780",
    "snippet": "static void\npopulate_recordset_object_start(void *state)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\tHASHCTL\t\tctl;\n\n\t/* Reject object at top level: we must have an array at level 0 */\n\tif (lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an object\",\n\t\t\t\t\t\t_state->function_name)));\n\n\t/* Nested objects require no special processing */\n\tif (lex_level > 1)\n\t\treturn;\n\n\t/* Object at level 1: set up a new hash table for this object */\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\t_state->json_hash = hash_create(\"json object hashtable\",\n\t\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t\t&ctl,\n\t\t\t\t\t\t\t\t\tHASH_ELEM | HASH_CONTEXT);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"json object hashtable\"",
            "100",
            "&ctl",
            "HASH_ELEM | HASH_CONTEXT"
          ],
          "line": 3776
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an object\",\n\t\t\t\t\t\t_state->function_name))"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on an object\"",
            "_state->function_name"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_object_start(void *state)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\tHASHCTL\t\tctl;\n\n\t/* Reject object at top level: we must have an array at level 0 */\n\tif (lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an object\",\n\t\t\t\t\t\t_state->function_name)));\n\n\t/* Nested objects require no special processing */\n\tif (lex_level > 1)\n\t\treturn;\n\n\t/* Object at level 1: set up a new hash table for this object */\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\t_state->json_hash = hash_create(\"json object hashtable\",\n\t\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t\t&ctl,\n\t\t\t\t\t\t\t\t\tHASH_ELEM | HASH_CONTEXT);\n}"
  },
  {
    "function_name": "populate_recordset_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3559-3751",
    "snippet": "static Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
      "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
      "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
      "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "cache->c.io.composite.tupdesc"
          ],
          "line": 3748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_recordset_record",
          "args": [
            "state",
            "&obj"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3522-3553",
          "snippet": "static void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname))"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument of %s must be an array of objects\"",
            "funcname"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsObject",
          "args": [
            "v.val.binary.data"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "skipNested"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname))"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "json_arg_num"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "json_arg_num"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rsi->econtext->ecxt_per_query_memory"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cached_tupdesc",
          "args": [
            "&cache->c.io.composite",
            "cache->fn_mcxt"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "update_cached_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2725-2746",
          "snippet": "static void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "json_arg_num"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "rec"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "rec"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "cache->fn_mcxt"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupdesc"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\"))"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\""
          ],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_call_result_type",
          "args": [
            "fcinfo",
            "NULL",
            "&tupdesc"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "210-220",
          "snippet": "TypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname))"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_column_cache",
          "args": [
            "&cache->c",
            "cache->argtype",
            "-1",
            "cache->fn_mcxt",
            "false"
          ],
          "line": 3599
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_column_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2906-2990",
          "snippet": "static void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);\n\nstatic void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(*cache)"
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\"))"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsi",
            "ReturnSetInfo"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "populate_recordset_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3522-3553",
    "snippet": "static void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
      "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "state->tuple_store",
            "&tuple"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple.t_self)"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "tuphead"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "HeapTupleHeaderGetDatum(tuphead)",
            "false",
            "cache->argtype",
            "&cache->c.io.composite.domain_info",
            "cache->fn_mcxt"
          ],
          "line": 3541
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatum",
          "args": [
            "tuphead"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_record",
          "args": [
            "cache->c.io.composite.tupdesc",
            "&cache->c.io.composite.record_io",
            "state->rec",
            "cache->fn_mcxt",
            "obj"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3102-3208",
          "snippet": "static HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\n\nstatic HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cached_tupdesc",
          "args": [
            "&cache->c.io.composite",
            "cache->fn_mcxt"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "update_cached_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2725-2746",
          "snippet": "static void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_recordset_record(PopulateRecordsetState *state, JsObject *obj)\n{\n\tPopulateRecordsetCache *cache = state->cache;\n\tHeapTupleHeader tuphead;\n\tHeapTupleData tuple;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\t/* replace record fields from json */\n\ttuphead = populate_record(cache->c.io.composite.tupdesc,\n\t\t\t\t\t\t\t  &cache->c.io.composite.record_io,\n\t\t\t\t\t\t\t  state->rec,\n\t\t\t\t\t\t\t  cache->fn_mcxt,\n\t\t\t\t\t\t\t  obj);\n\n\t/* if it's domain over composite, check domain constraints */\n\tif (cache->c.typcat == TYPECAT_COMPOSITE_DOMAIN)\n\t\tdomain_check(HeapTupleHeaderGetDatum(tuphead), false,\n\t\t\t\t\t cache->argtype,\n\t\t\t\t\t &cache->c.io.composite.domain_info,\n\t\t\t\t\t cache->fn_mcxt);\n\n\t/* ok, save into tuplestore */\n\ttuple.t_len = HeapTupleHeaderGetDatumLength(tuphead);\n\tItemPointerSetInvalid(&(tuple.t_self));\n\ttuple.t_tableOid = InvalidOid;\n\ttuple.t_data = tuphead;\n\n\ttuplestore_puttuple(state->tuple_store, &tuple);\n}"
  },
  {
    "function_name": "json_to_recordset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3515-3520",
    "snippet": "Datum\njson_to_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"json_to_recordset\",\n\t\t\t\t\t\t\t\t\t true, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_recordset_worker",
          "args": [
            "fcinfo",
            "\"json_to_recordset\"",
            "true",
            "false"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3559-3751",
          "snippet": "static Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_to_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"json_to_recordset\",\n\t\t\t\t\t\t\t\t\t true, false);\n}"
  },
  {
    "function_name": "json_populate_recordset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3508-3513",
    "snippet": "Datum\njson_populate_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"json_populate_recordset\",\n\t\t\t\t\t\t\t\t\t true, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_recordset_worker",
          "args": [
            "fcinfo",
            "\"json_populate_recordset\"",
            "true",
            "true"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3559-3751",
          "snippet": "static Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_populate_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"json_populate_recordset\",\n\t\t\t\t\t\t\t\t\t true, true);\n}"
  },
  {
    "function_name": "jsonb_to_recordset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3501-3506",
    "snippet": "Datum\njsonb_to_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"jsonb_to_recordset\",\n\t\t\t\t\t\t\t\t\t false, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_recordset_worker",
          "args": [
            "fcinfo",
            "\"jsonb_to_recordset\"",
            "false",
            "false"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3559-3751",
          "snippet": "static Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_to_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"jsonb_to_recordset\",\n\t\t\t\t\t\t\t\t\t false, false);\n}"
  },
  {
    "function_name": "jsonb_populate_recordset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3494-3499",
    "snippet": "Datum\njsonb_populate_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"jsonb_populate_recordset\",\n\t\t\t\t\t\t\t\t\t false, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_recordset_worker",
          "args": [
            "fcinfo",
            "\"jsonb_populate_recordset\"",
            "false",
            "true"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "populate_recordset_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3559-3751",
          "snippet": "static Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\npopulate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tHeapTupleHeader rec;\n\tPopulateRecordsetCache *cache = fcinfo->flinfo->fn_extra;\n\tPopulateRecordsetState *state;\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fcinfo->flinfo->fn_mcxt, sizeof(*cache));\n\t\tcache->fn_mcxt = fcinfo->flinfo->fn_mcxt;\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_recordset case: result type will be same as\n\t\t\t * first argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t cache->fn_mcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_recordset case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(cache->fn_mcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* if the json is null send back an empty set */\n\tif (PG_ARGISNULL(json_arg_num))\n\t\tPG_RETURN_NULL();\n\n\t/*\n\t * Forcibly update the cached tupdesc, to ensure we have the right tupdesc\n\t * to return even if the JSON contains no rows.\n\t */\n\tupdate_cached_tupdesc(&cache->c.io.composite, cache->fn_mcxt);\n\n\tstate = palloc0(sizeof(PopulateRecordsetState));\n\n\t/* make tuplestore in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\tstate->tuple_store = tuplestore_begin_heap(rsi->allowedModes &\n\t\t\t\t\t\t\t\t\t\t\t   SFRM_Materialize_Random,\n\t\t\t\t\t\t\t\t\t\t\t   false, work_mem);\n\tMemoryContextSwitchTo(old_cxt);\n\n\tstate->function_name = funcname;\n\tstate->cache = cache;\n\tstate->rec = rec;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\t\tJsonLexContext *lex;\n\t\tJsonSemAction *sem;\n\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tlex = makeJsonLexContext(json, true);\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = populate_recordset_array_start;\n\t\tsem->array_element_start = populate_recordset_array_element_start;\n\t\tsem->scalar = populate_recordset_scalar;\n\t\tsem->object_field_start = populate_recordset_object_field_start;\n\t\tsem->object_field_end = populate_recordset_object_field_end;\n\t\tsem->object_start = populate_recordset_object_start;\n\t\tsem->object_end = populate_recordset_object_end;\n\n\t\tstate->lex = lex;\n\n\t\tpg_parse_json(lex, sem);\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb) || !JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t\tfuncname)));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_ELEM)\n\t\t\t{\n\t\t\t\tJsObject\tobj;\n\n\t\t\t\tif (v.type != jbvBinary ||\n\t\t\t\t\t!JsonContainerIsObject(v.val.binary.data))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t\t\t\tfuncname)));\n\n\t\t\t\tobj.is_json = false;\n\t\t\t\tobj.val.jsonb_cont = v.val.binary.data;\n\n\t\t\t\tpopulate_recordset_record(state, &obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Note: we must copy the cached tupdesc because the executor will free\n\t * the passed-back setDesc, but we want to hang onto the cache in case\n\t * we're called again in the same query.\n\t */\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = CreateTupleDescCopy(cache->c.io.composite.tupdesc);\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_populate_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"jsonb_populate_recordset\",\n\t\t\t\t\t\t\t\t\t false, true);\n}"
  },
  {
    "function_name": "hash_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3465-3481",
    "snippet": "static void\nhash_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\", _state->function_name)));\n\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t_state->saved_scalar = token;\n\t\t/* saved_token_type must already be set in hash_object_field_start() */\n\t\tAssert(_state->saved_token_type == tokentype);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "_state->saved_token_type == tokentype"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\", _state->function_name))"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on a scalar\"",
            "_state->function_name"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nhash_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\", _state->function_name)));\n\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t_state->saved_scalar = token;\n\t\t/* saved_token_type must already be set in hash_object_field_start() */\n\t\tAssert(_state->saved_token_type == tokentype);\n\t}\n}"
  },
  {
    "function_name": "hash_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3454-3463",
    "snippet": "static void\nhash_array_start(void *state)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\", _state->function_name)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\", _state->function_name))"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on an array\"",
            "_state->function_name"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nhash_array_start(void *state)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\", _state->function_name)));\n}"
  },
  {
    "function_name": "hash_object_field_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3405-3452",
    "snippet": "static void\nhash_object_field_end(void *state, char *fname, bool isnull)\n{\n\tJHashState *_state = (JHashState *) state;\n\tJsonHashEntry *hashentry;\n\tbool\t\tfound;\n\n\t/*\n\t * Ignore nested fields.\n\t */\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\t/*\n\t * Ignore field names >= NAMEDATALEN - they can't match a record field.\n\t * (Note: without this test, the hash code would truncate the string at\n\t * NAMEDATALEN-1, and could then match against a similarly-truncated\n\t * record field name.  That would be a reasonable behavior, but this code\n\t * has previously insisted on exact equality, so we keep this behavior.)\n\t */\n\tif (strlen(fname) >= NAMEDATALEN)\n\t\treturn;\n\n\thashentry = hash_search(_state->hash, fname, HASH_ENTER, &found);\n\n\t/*\n\t * found being true indicates a duplicate. We don't do anything about\n\t * that, a later field with the same name overrides the earlier field.\n\t */\n\n\thashentry->type = _state->saved_token_type;\n\tAssert(isnull == (hashentry->type == JSON_TOKEN_NULL));\n\n\tif (_state->save_json_start != NULL)\n\t{\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - _state->save_json_start;\n\t\tchar\t   *val = palloc((len + 1) * sizeof(char));\n\n\t\tmemcpy(val, _state->save_json_start, len);\n\t\tval[len] = '\\0';\n\t\thashentry->val = val;\n\t}\n\telse\n\t{\n\t\t/* must have had a scalar instead */\n\t\thashentry->val = _state->saved_scalar;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "_state->save_json_start",
            "len"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len + 1) * sizeof(char)"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "isnull == (hashentry->type == JSON_TOKEN_NULL)"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "_state->hash",
            "fname",
            "HASH_ENTER",
            "&found"
          ],
          "line": 3428
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nhash_object_field_end(void *state, char *fname, bool isnull)\n{\n\tJHashState *_state = (JHashState *) state;\n\tJsonHashEntry *hashentry;\n\tbool\t\tfound;\n\n\t/*\n\t * Ignore nested fields.\n\t */\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\t/*\n\t * Ignore field names >= NAMEDATALEN - they can't match a record field.\n\t * (Note: without this test, the hash code would truncate the string at\n\t * NAMEDATALEN-1, and could then match against a similarly-truncated\n\t * record field name.  That would be a reasonable behavior, but this code\n\t * has previously insisted on exact equality, so we keep this behavior.)\n\t */\n\tif (strlen(fname) >= NAMEDATALEN)\n\t\treturn;\n\n\thashentry = hash_search(_state->hash, fname, HASH_ENTER, &found);\n\n\t/*\n\t * found being true indicates a duplicate. We don't do anything about\n\t * that, a later field with the same name overrides the earlier field.\n\t */\n\n\thashentry->type = _state->saved_token_type;\n\tAssert(isnull == (hashentry->type == JSON_TOKEN_NULL));\n\n\tif (_state->save_json_start != NULL)\n\t{\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - _state->save_json_start;\n\t\tchar\t   *val = palloc((len + 1) * sizeof(char));\n\n\t\tmemcpy(val, _state->save_json_start, len);\n\t\tval[len] = '\\0';\n\t\thashentry->val = val;\n\t}\n\telse\n\t{\n\t\t/* must have had a scalar instead */\n\t\thashentry->val = _state->saved_scalar;\n\t}\n}"
  },
  {
    "function_name": "hash_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3381-3403",
    "snippet": "static void\nhash_object_field_start(void *state, char *fname, bool isnull)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\t/* remember token type */\n\t_state->saved_token_type = _state->lex->token_type;\n\n\tif (_state->lex->token_type == JSON_TOKEN_ARRAY_START ||\n\t\t_state->lex->token_type == JSON_TOKEN_OBJECT_START)\n\t{\n\t\t/* remember start position of the whole text of the subobject */\n\t\t_state->save_json_start = _state->lex->token_start;\n\t}\n\telse\n\t{\n\t\t/* must be a scalar */\n\t\t_state->save_json_start = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nhash_object_field_start(void *state, char *fname, bool isnull)\n{\n\tJHashState *_state = (JHashState *) state;\n\n\tif (_state->lex->lex_level > 1)\n\t\treturn;\n\n\t/* remember token type */\n\t_state->saved_token_type = _state->lex->token_type;\n\n\tif (_state->lex->token_type == JSON_TOKEN_ARRAY_START ||\n\t\t_state->lex->token_type == JSON_TOKEN_OBJECT_START)\n\t{\n\t\t/* remember start position of the whole text of the subobject */\n\t\t_state->save_json_start = _state->lex->token_start;\n\t}\n\telse\n\t{\n\t\t/* must be a scalar */\n\t\t_state->save_json_start = NULL;\n\t}\n}"
  },
  {
    "function_name": "get_json_object_as_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3345-3379",
    "snippet": "static HTAB *\nget_json_object_as_hash(char *json, int len, const char *funcname)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *tab;\n\tJHashState *state;\n\tJsonLexContext *lex = makeJsonLexContextCstringLen(json, len, true);\n\tJsonSemAction *sem;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\ttab = hash_create(\"json object hashtable\",\n\t\t\t\t\t  100,\n\t\t\t\t\t  &ctl,\n\t\t\t\t\t  HASH_ELEM | HASH_CONTEXT);\n\n\tstate = palloc0(sizeof(JHashState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->function_name = funcname;\n\tstate->hash = tab;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = hash_array_start;\n\tsem->scalar = hash_scalar;\n\tsem->object_field_start = hash_object_field_start;\n\tsem->object_field_end = hash_object_field_end;\n\n\tpg_parse_json(lex, sem);\n\n\treturn tab;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"json object hashtable\"",
            "100",
            "&ctl",
            "HASH_ELEM | HASH_CONTEXT"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeJsonLexContextCstringLen",
          "args": [
            "json",
            "len",
            "true"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContextCstringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "308-319",
          "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic HTAB *\nget_json_object_as_hash(char *json, int len, const char *funcname)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *tab;\n\tJHashState *state;\n\tJsonLexContext *lex = makeJsonLexContextCstringLen(json, len, true);\n\tJsonSemAction *sem;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\ttab = hash_create(\"json object hashtable\",\n\t\t\t\t\t  100,\n\t\t\t\t\t  &ctl,\n\t\t\t\t\t  HASH_ELEM | HASH_CONTEXT);\n\n\tstate = palloc0(sizeof(JHashState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->function_name = funcname;\n\tstate->hash = tab;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = hash_array_start;\n\tsem->scalar = hash_scalar;\n\tsem->object_field_start = hash_object_field_start;\n\tsem->object_field_end = hash_object_field_end;\n\n\tpg_parse_json(lex, sem);\n\n\treturn tab;\n}"
  },
  {
    "function_name": "populate_record_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3214-3338",
    "snippet": "static Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
      "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "rettuple"
          ],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_composite",
          "args": [
            "&cache->c.io.composite",
            "cache->argtype",
            "NULL",
            "fnmcxt",
            "rec",
            "&jsv",
            "false"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "populate_composite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2749-2790",
          "snippet": "static Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static void JsValueToJsObject(JsValue *jsv, JsObject *jso);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic void JsValueToJsObject(JsValue *jsv, JsObject *jso);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jb"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "json_arg_num"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "json"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "json"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "json_arg_num"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rec"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "json_arg_num"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "rec"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "rec"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_HEAPTUPLEHEADER",
          "args": [
            "0"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "fnmcxt"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupdesc"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\"))"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\""
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\""
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_call_result_type",
          "args": [
            "fcinfo",
            "NULL",
            "&tupdesc"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "210-220",
          "snippet": "TypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname))"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_column_cache",
          "args": [
            "&cache->c",
            "cache->argtype",
            "-1",
            "fnmcxt",
            "false"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_column_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2906-2990",
          "snippet": "static void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);\n\nstatic void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "fnmcxt",
            "sizeof(*cache)"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}"
  },
  {
    "function_name": "populate_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3102-3208",
    "snippet": "static HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
      "static RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);",
      "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_record_field",
          "args": [
            "&record->columns[i]",
            "att->atttypid",
            "att->atttypmod",
            "colname",
            "mcxt",
            "nulls[i] ? (Datum) 0 : values[i]",
            "&field",
            "&nulls[i]"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2993-3056",
          "snippet": "static Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsObjectGetField",
          "args": [
            "obj",
            "colname",
            "&field"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "JsObjectGetField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3074-3099",
          "snippet": "static bool\nJsObjectGetField(JsObject *obj, char *field, JsValue *jsv)\n{\n\tjsv->is_json = obj->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\tJsonHashEntry *hashentry = hash_search(obj->val.json_hash, field,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND, NULL);\n\n\t\tjsv->val.json.type = hashentry ? hashentry->type : JSON_TOKEN_NULL;\n\t\tjsv->val.json.str = jsv->val.json.type == JSON_TOKEN_NULL ? NULL :\n\t\t\thashentry->val;\n\t\tjsv->val.json.len = jsv->val.json.str ? -1 : 0; /* null-terminated */\n\n\t\treturn hashentry != NULL;\n\t}\n\telse\n\t{\n\t\tjsv->val.jsonb = !obj->val.jsonb_cont ? NULL :\n\t\t\tfindJsonbValueFromContainerLen(obj->val.jsonb_cont, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t   field, strlen(field));\n\n\t\treturn jsv->val.jsonb != NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic bool\nJsObjectGetField(JsObject *obj, char *field, JsValue *jsv)\n{\n\tjsv->is_json = obj->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\tJsonHashEntry *hashentry = hash_search(obj->val.json_hash, field,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND, NULL);\n\n\t\tjsv->val.json.type = hashentry ? hashentry->type : JSON_TOKEN_NULL;\n\t\tjsv->val.json.str = jsv->val.json.type == JSON_TOKEN_NULL ? NULL :\n\t\t\thashentry->val;\n\t\tjsv->val.json.len = jsv->val.json.str ? -1 : 0; /* null-terminated */\n\n\t\treturn hashentry != NULL;\n\t}\n\telse\n\t{\n\t\tjsv->val.jsonb = !obj->val.jsonb_cont ? NULL :\n\t\t\tfindJsonbValueFromContainerLen(obj->val.jsonb_cont, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t   field, strlen(field));\n\n\t\treturn jsv->val.jsonb != NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_deform_tuple",
          "args": [
            "&tuple",
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerSetInvalid",
          "args": [
            "&(tuple.t_self)"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "defaultval"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ncolumns * sizeof(bool)"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "record",
            "0",
            "offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_record_info",
          "args": [
            "mcxt",
            "ncolumns"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_record_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3058-3072",
          "snippet": "static RecordIOData *\nallocate_record_info(MemoryContext mcxt, int ncolumns)\n{\n\tRecordIOData *data = (RecordIOData *)\n\tMemoryContextAlloc(mcxt,\n\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\n\tdata->record_type = InvalidOid;\n\tdata->record_typmod = 0;\n\tdata->ncolumns = ncolumns;\n\tMemSet(data->columns, 0, sizeof(ColumnIOData) * ncolumns);\n\n\treturn data;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);\n\nstatic RecordIOData *\nallocate_record_info(MemoryContext mcxt, int ncolumns)\n{\n\tRecordIOData *data = (RecordIOData *)\n\tMemoryContextAlloc(mcxt,\n\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\n\tdata->record_type = InvalidOid;\n\tdata->record_typmod = 0;\n\tdata->ncolumns = ncolumns;\n\tMemSet(data->columns, 0, sizeof(ColumnIOData) * ncolumns);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsObjectIsEmpty",
          "args": [
            "obj"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\n\nstatic HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}"
  },
  {
    "function_name": "JsObjectGetField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3074-3099",
    "snippet": "static bool\nJsObjectGetField(JsObject *obj, char *field, JsValue *jsv)\n{\n\tjsv->is_json = obj->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\tJsonHashEntry *hashentry = hash_search(obj->val.json_hash, field,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND, NULL);\n\n\t\tjsv->val.json.type = hashentry ? hashentry->type : JSON_TOKEN_NULL;\n\t\tjsv->val.json.str = jsv->val.json.type == JSON_TOKEN_NULL ? NULL :\n\t\t\thashentry->val;\n\t\tjsv->val.json.len = jsv->val.json.str ? -1 : 0; /* null-terminated */\n\n\t\treturn hashentry != NULL;\n\t}\n\telse\n\t{\n\t\tjsv->val.jsonb = !obj->val.jsonb_cont ? NULL :\n\t\t\tfindJsonbValueFromContainerLen(obj->val.jsonb_cont, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t   field, strlen(field));\n\n\t\treturn jsv->val.jsonb != NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "findJsonbValueFromContainerLen",
          "args": [
            "obj->val.jsonb_cont",
            "JB_FOBJECT",
            "field",
            "strlen(field)"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainerLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3910-3921",
          "snippet": "static JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\n\nstatic JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "obj->val.json_hash",
            "field",
            "HASH_FIND",
            "NULL"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic bool\nJsObjectGetField(JsObject *obj, char *field, JsValue *jsv)\n{\n\tjsv->is_json = obj->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\tJsonHashEntry *hashentry = hash_search(obj->val.json_hash, field,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND, NULL);\n\n\t\tjsv->val.json.type = hashentry ? hashentry->type : JSON_TOKEN_NULL;\n\t\tjsv->val.json.str = jsv->val.json.type == JSON_TOKEN_NULL ? NULL :\n\t\t\thashentry->val;\n\t\tjsv->val.json.len = jsv->val.json.str ? -1 : 0; /* null-terminated */\n\n\t\treturn hashentry != NULL;\n\t}\n\telse\n\t{\n\t\tjsv->val.jsonb = !obj->val.jsonb_cont ? NULL :\n\t\t\tfindJsonbValueFromContainerLen(obj->val.jsonb_cont, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t   field, strlen(field));\n\n\t\treturn jsv->val.jsonb != NULL;\n\t}\n}"
  },
  {
    "function_name": "allocate_record_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "3058-3072",
    "snippet": "static RecordIOData *\nallocate_record_info(MemoryContext mcxt, int ncolumns)\n{\n\tRecordIOData *data = (RecordIOData *)\n\tMemoryContextAlloc(mcxt,\n\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\n\tdata->record_type = InvalidOid;\n\tdata->record_typmod = 0;\n\tdata->ncolumns = ncolumns;\n\tMemSet(data->columns, 0, sizeof(ColumnIOData) * ncolumns);\n\n\treturn data;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "data->columns",
            "0",
            "sizeof(ColumnIOData) * ncolumns"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "mcxt",
            "offsetof(RecordIOData, columns) +\n\t\t\t\t\t   ncolumns * sizeof(ColumnIOData)"
          ],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);\n\nstatic RecordIOData *\nallocate_record_info(MemoryContext mcxt, int ncolumns)\n{\n\tRecordIOData *data = (RecordIOData *)\n\tMemoryContextAlloc(mcxt,\n\t\t\t\t\t   offsetof(RecordIOData, columns) +\n\t\t\t\t\t   ncolumns * sizeof(ColumnIOData));\n\n\tdata->record_type = InvalidOid;\n\tdata->record_typmod = 0;\n\tdata->ncolumns = ncolumns;\n\tMemSet(data->columns, 0, sizeof(ColumnIOData) * ncolumns);\n\n\treturn data;\n}"
  },
  {
    "function_name": "populate_record_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2993-3056",
    "snippet": "static Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized type category '%c'\"",
            "typcat"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_domain",
          "args": [
            "&col->io.domain",
            "typid",
            "colname",
            "mcxt",
            "jsv",
            "*isnull"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "populate_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2879-2903",
          "snippet": "static Datum\npopulate_domain(DomainIOData *io,\n\t\t\t\tOid typid,\n\t\t\t\tconst char *colname,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsValue *jsv,\n\t\t\t\tbool isnull)\n{\n\tDatum\t\tres;\n\n\tif (isnull)\n\t\tres = (Datum) 0;\n\telse\n\t{\n\t\tres = populate_record_field(io->base_io,\n\t\t\t\t\t\t\t\t\tio->base_typid, io->base_typmod,\n\t\t\t\t\t\t\t\t\tcolname, mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &isnull);\n\t\tAssert(!isnull);\n\t}\n\n\tdomain_check(res, isnull, typid, &io->domain_info, mcxt);\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_domain(DomainIOData *io,\n\t\t\t\tOid typid,\n\t\t\t\tconst char *colname,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsValue *jsv,\n\t\t\t\tbool isnull)\n{\n\tDatum\t\tres;\n\n\tif (isnull)\n\t\tres = (Datum) 0;\n\telse\n\t{\n\t\tres = populate_record_field(io->base_io,\n\t\t\t\t\t\t\t\t\tio->base_typid, io->base_typmod,\n\t\t\t\t\t\t\t\t\tcolname, mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &isnull);\n\t\tAssert(!isnull);\n\t}\n\n\tdomain_check(res, isnull, typid, &io->domain_info, mcxt);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_composite",
          "args": [
            "&col->io.composite",
            "typid",
            "colname",
            "mcxt",
            "DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL",
            "jsv",
            "*isnull"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "populate_composite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2749-2790",
          "snippet": "static Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static void JsValueToJsObject(JsValue *jsv, JsObject *jso);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic void JsValueToJsObject(JsValue *jsv, JsObject *jso);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetHeapTupleHeader",
          "args": [
            "defaultval"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "defaultval"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array",
          "args": [
            "&col->io.array",
            "colname",
            "mcxt",
            "jsv"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2635-2680",
          "snippet": "static Datum\npopulate_array(ArrayIOData *aio,\n\t\t\t   const char *colname,\n\t\t\t   MemoryContext mcxt,\n\t\t\t   JsValue *jsv)\n{\n\tPopulateArrayContext ctx;\n\tDatum\t\tresult;\n\tint\t\t   *lbs;\n\tint\t\t\ti;\n\n\tctx.aio = aio;\n\tctx.mcxt = mcxt;\n\tctx.acxt = CurrentMemoryContext;\n\tctx.astate = initArrayResult(aio->element_type, ctx.acxt, true);\n\tctx.colname = colname;\n\tctx.ndims = 0;\t\t\t\t/* unknown yet */\n\tctx.dims = NULL;\n\tctx.sizes = NULL;\n\n\tif (jsv->is_json)\n\t\tpopulate_array_json(&ctx, jsv->val.json.str,\n\t\t\t\t\t\t\tjsv->val.json.len >= 0 ? jsv->val.json.len\n\t\t\t\t\t\t\t: strlen(jsv->val.json.str));\n\telse\n\t{\n\t\tpopulate_array_dim_jsonb(&ctx, jsv->val.jsonb, 1);\n\t\tctx.dims[0] = ctx.sizes[0];\n\t}\n\n\tAssert(ctx.ndims > 0);\n\n\tlbs = palloc(sizeof(int) * ctx.ndims);\n\n\tfor (i = 0; i < ctx.ndims; i++)\n\t\tlbs[i] = 1;\n\n\tresult = makeMdArrayResult(ctx.astate, ctx.ndims, ctx.dims, lbs,\n\t\t\t\t\t\t\t   ctx.acxt, true);\n\n\tpfree(ctx.dims);\n\tpfree(ctx.sizes);\n\tpfree(lbs);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic Datum\npopulate_array(ArrayIOData *aio,\n\t\t\t   const char *colname,\n\t\t\t   MemoryContext mcxt,\n\t\t\t   JsValue *jsv)\n{\n\tPopulateArrayContext ctx;\n\tDatum\t\tresult;\n\tint\t\t   *lbs;\n\tint\t\t\ti;\n\n\tctx.aio = aio;\n\tctx.mcxt = mcxt;\n\tctx.acxt = CurrentMemoryContext;\n\tctx.astate = initArrayResult(aio->element_type, ctx.acxt, true);\n\tctx.colname = colname;\n\tctx.ndims = 0;\t\t\t\t/* unknown yet */\n\tctx.dims = NULL;\n\tctx.sizes = NULL;\n\n\tif (jsv->is_json)\n\t\tpopulate_array_json(&ctx, jsv->val.json.str,\n\t\t\t\t\t\t\tjsv->val.json.len >= 0 ? jsv->val.json.len\n\t\t\t\t\t\t\t: strlen(jsv->val.json.str));\n\telse\n\t{\n\t\tpopulate_array_dim_jsonb(&ctx, jsv->val.jsonb, 1);\n\t\tctx.dims[0] = ctx.sizes[0];\n\t}\n\n\tAssert(ctx.ndims > 0);\n\n\tlbs = palloc(sizeof(int) * ctx.ndims);\n\n\tfor (i = 0; i < ctx.ndims; i++)\n\t\tlbs[i] = 1;\n\n\tresult = makeMdArrayResult(ctx.astate, ctx.ndims, ctx.dims, lbs,\n\t\t\t\t\t\t\t   ctx.acxt, true);\n\n\tpfree(ctx.dims);\n\tpfree(ctx.sizes);\n\tpfree(lbs);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_scalar",
          "args": [
            "&col->scalar_io",
            "typid",
            "typmod",
            "jsv"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "populate_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2793-2877",
          "snippet": "static Datum\npopulate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv)\n{\n\tDatum\t\tres;\n\tchar\t   *str = NULL;\n\tchar\t   *json = NULL;\n\n\tif (jsv->is_json)\n\t{\n\t\tint\t\t\tlen = jsv->val.json.len;\n\n\t\tjson = jsv->val.json.str;\n\t\tAssert(json);\n\n\t\t/* already done the hard work in the json case */\n\t\tif ((typid == JSONOID || typid == JSONBOID) &&\n\t\t\tjsv->val.json.type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/*\n\t\t\t * Add quotes around string value (should be already escaped) if\n\t\t\t * converting to json/jsonb.\n\t\t\t */\n\n\t\t\tif (len < 0)\n\t\t\t\tlen = strlen(json);\n\n\t\t\tstr = palloc(len + sizeof(char) * 3);\n\t\t\tstr[0] = '\"';\n\t\t\tmemcpy(&str[1], json, len);\n\t\t\tstr[len + 1] = '\"';\n\t\t\tstr[len + 2] = '\\0';\n\t\t}\n\t\telse if (len >= 0)\n\t\t{\n\t\t\t/* Need to copy non-null-terminated string */\n\t\t\tstr = palloc(len + 1 * sizeof(char));\n\t\t\tmemcpy(str, json, len);\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\telse\n\t\t\tstr = json;\t\t\t/* null-terminated string */\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (typid == JSONBOID)\n\t\t{\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv); /* directly use jsonb */\n\n\t\t\treturn JsonbPGetDatum(jsonb);\n\t\t}\n\t\t/* convert jsonb to string for typio call */\n\t\telse if (typid == JSONOID && jbv->type != jbvBinary)\n\t\t{\n\t\t\t/*\n\t\t\t * Convert scalar jsonb (non-scalars are passed here as jbvBinary)\n\t\t\t * to json string, preserving quotes around top-level strings.\n\t\t\t */\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv);\n\n\t\t\tstr = JsonbToCString(NULL, &jsonb->root, VARSIZE(jsonb));\n\t\t}\n\t\telse if (jbv->type == jbvString)\t/* quotes are stripped */\n\t\t\tstr = pnstrdup(jbv->val.string.val, jbv->val.string.len);\n\t\telse if (jbv->type == jbvBool)\n\t\t\tstr = pstrdup(jbv->val.boolean ? \"true\" : \"false\");\n\t\telse if (jbv->type == jbvNumeric)\n\t\t\tstr = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(jbv->val.numeric)));\n\t\telse if (jbv->type == jbvBinary)\n\t\t\tstr = JsonbToCString(NULL, jbv->val.binary.data,\n\t\t\t\t\t\t\t\t jbv->val.binary.len);\n\t\telse\n\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) jbv->type);\n\t}\n\n\tres = InputFunctionCall(&io->typiofunc, str, io->typioparam, typmod);\n\n\t/* free temporary buffer */\n\tif (str != json)\n\t\tpfree(str);\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic Datum\npopulate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv)\n{\n\tDatum\t\tres;\n\tchar\t   *str = NULL;\n\tchar\t   *json = NULL;\n\n\tif (jsv->is_json)\n\t{\n\t\tint\t\t\tlen = jsv->val.json.len;\n\n\t\tjson = jsv->val.json.str;\n\t\tAssert(json);\n\n\t\t/* already done the hard work in the json case */\n\t\tif ((typid == JSONOID || typid == JSONBOID) &&\n\t\t\tjsv->val.json.type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/*\n\t\t\t * Add quotes around string value (should be already escaped) if\n\t\t\t * converting to json/jsonb.\n\t\t\t */\n\n\t\t\tif (len < 0)\n\t\t\t\tlen = strlen(json);\n\n\t\t\tstr = palloc(len + sizeof(char) * 3);\n\t\t\tstr[0] = '\"';\n\t\t\tmemcpy(&str[1], json, len);\n\t\t\tstr[len + 1] = '\"';\n\t\t\tstr[len + 2] = '\\0';\n\t\t}\n\t\telse if (len >= 0)\n\t\t{\n\t\t\t/* Need to copy non-null-terminated string */\n\t\t\tstr = palloc(len + 1 * sizeof(char));\n\t\t\tmemcpy(str, json, len);\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\telse\n\t\t\tstr = json;\t\t\t/* null-terminated string */\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (typid == JSONBOID)\n\t\t{\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv); /* directly use jsonb */\n\n\t\t\treturn JsonbPGetDatum(jsonb);\n\t\t}\n\t\t/* convert jsonb to string for typio call */\n\t\telse if (typid == JSONOID && jbv->type != jbvBinary)\n\t\t{\n\t\t\t/*\n\t\t\t * Convert scalar jsonb (non-scalars are passed here as jbvBinary)\n\t\t\t * to json string, preserving quotes around top-level strings.\n\t\t\t */\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv);\n\n\t\t\tstr = JsonbToCString(NULL, &jsonb->root, VARSIZE(jsonb));\n\t\t}\n\t\telse if (jbv->type == jbvString)\t/* quotes are stripped */\n\t\t\tstr = pnstrdup(jbv->val.string.val, jbv->val.string.len);\n\t\telse if (jbv->type == jbvBool)\n\t\t\tstr = pstrdup(jbv->val.boolean ? \"true\" : \"false\");\n\t\telse if (jbv->type == jbvNumeric)\n\t\t\tstr = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(jbv->val.numeric)));\n\t\telse if (jbv->type == jbvBinary)\n\t\t\tstr = JsonbToCString(NULL, jbv->val.binary.data,\n\t\t\t\t\t\t\t\t jbv->val.binary.len);\n\t\telse\n\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) jbv->type);\n\t}\n\n\tres = InputFunctionCall(&io->typiofunc, str, io->typioparam, typmod);\n\n\t/* free temporary buffer */\n\tif (str != json)\n\t\tpfree(str);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsValueIsString",
          "args": [
            "jsv"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsValueIsNull",
          "args": [
            "jsv"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_column_cache",
          "args": [
            "col",
            "typid",
            "typmod",
            "mcxt",
            "true"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_column_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2906-2990",
          "snippet": "static void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);\n\nstatic void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}"
  },
  {
    "function_name": "prepare_column_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2906-2990",
    "snippet": "static void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "typioproc",
            "&column->scalar_io.typiofunc",
            "mcxt"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeInputInfo",
          "args": [
            "typid",
            "&typioproc",
            "&column->scalar_io.typioparam"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeInputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2640-2666",
          "snippet": "void\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "mcxt",
            "sizeof(ColumnIOData)"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "type->typelem"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typtype",
          "args": [
            "base_typid"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "get_typtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2406-2423",
          "snippet": "char\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseTypeAndTypmod",
          "args": [
            "typid",
            "&base_typmod"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseTypeAndTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2315-2345",
          "snippet": "Oid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseTypeAndTypmod(Oid typid, int32 *typmod)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so done */\n\t\t\tReleaseSysCache(tup);\n\t\t\tbreak;\n\t\t}\n\n\t\tAssert(*typmod == -1);\n\t\ttypid = typTup->typbasetype;\n\t\t*typmod = typTup->typtypmod;\n\n\t\tReleaseSysCache(tup);\n\t}\n\n\treturn typid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for type %u\"",
            "typid"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(typid)"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typid"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void prepare_column_cache(ColumnIOData *column, Oid typid, int32 typmod,\n\t\t\t\t\t MemoryContext mcxt, bool need_scalar);\n\nstatic void\nprepare_column_cache(ColumnIOData *column,\n\t\t\t\t\t Oid typid,\n\t\t\t\t\t int32 typmod,\n\t\t\t\t\t MemoryContext mcxt,\n\t\t\t\t\t bool need_scalar)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type type;\n\n\tcolumn->typid = typid;\n\tcolumn->typmod = typmod;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\n\ttype = (Form_pg_type) GETSTRUCT(tup);\n\n\tif (type->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\t/*\n\t\t * We can move directly to the bottom base type; domain_check() will\n\t\t * take care of checking all constraints for a stack of domains.\n\t\t */\n\t\tOid\t\t\tbase_typid;\n\t\tint32\t\tbase_typmod = typmod;\n\n\t\tbase_typid = getBaseTypeAndTypmod(typid, &base_typmod);\n\t\tif (get_typtype(base_typid) == TYPTYPE_COMPOSITE)\n\t\t{\n\t\t\t/* domain over composite has its own code path */\n\t\t\tcolumn->typcat = TYPECAT_COMPOSITE_DOMAIN;\n\t\t\tcolumn->io.composite.record_io = NULL;\n\t\t\tcolumn->io.composite.tupdesc = NULL;\n\t\t\tcolumn->io.composite.base_typid = base_typid;\n\t\t\tcolumn->io.composite.base_typmod = base_typmod;\n\t\t\tcolumn->io.composite.domain_info = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* domain over anything else */\n\t\t\tcolumn->typcat = TYPECAT_DOMAIN;\n\t\t\tcolumn->io.domain.base_typid = base_typid;\n\t\t\tcolumn->io.domain.base_typmod = base_typmod;\n\t\t\tcolumn->io.domain.base_io =\n\t\t\t\tMemoryContextAllocZero(mcxt, sizeof(ColumnIOData));\n\t\t\tcolumn->io.domain.domain_info = NULL;\n\t\t}\n\t}\n\telse if (type->typtype == TYPTYPE_COMPOSITE || typid == RECORDOID)\n\t{\n\t\tcolumn->typcat = TYPECAT_COMPOSITE;\n\t\tcolumn->io.composite.record_io = NULL;\n\t\tcolumn->io.composite.tupdesc = NULL;\n\t\tcolumn->io.composite.base_typid = typid;\n\t\tcolumn->io.composite.base_typmod = typmod;\n\t\tcolumn->io.composite.domain_info = NULL;\n\t}\n\telse if (type->typlen == -1 && OidIsValid(type->typelem))\n\t{\n\t\tcolumn->typcat = TYPECAT_ARRAY;\n\t\tcolumn->io.array.element_info = MemoryContextAllocZero(mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ColumnIOData));\n\t\tcolumn->io.array.element_type = type->typelem;\n\t\t/* array element typemod stored in attribute's typmod */\n\t\tcolumn->io.array.element_typmod = typmod;\n\t}\n\telse\n\t{\n\t\tcolumn->typcat = TYPECAT_SCALAR;\n\t\tneed_scalar = true;\n\t}\n\n\t/* caller can force us to look up scalar_io info even for non-scalars */\n\tif (need_scalar)\n\t{\n\t\tOid\t\t\ttypioproc;\n\n\t\tgetTypeInputInfo(typid, &typioproc, &column->scalar_io.typioparam);\n\t\tfmgr_info_cxt(typioproc, &column->scalar_io.typiofunc, mcxt);\n\t}\n\n\tReleaseSysCache(tup);\n}"
  },
  {
    "function_name": "populate_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2879-2903",
    "snippet": "static Datum\npopulate_domain(DomainIOData *io,\n\t\t\t\tOid typid,\n\t\t\t\tconst char *colname,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsValue *jsv,\n\t\t\t\tbool isnull)\n{\n\tDatum\t\tres;\n\n\tif (isnull)\n\t\tres = (Datum) 0;\n\telse\n\t{\n\t\tres = populate_record_field(io->base_io,\n\t\t\t\t\t\t\t\t\tio->base_typid, io->base_typmod,\n\t\t\t\t\t\t\t\t\tcolname, mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &isnull);\n\t\tAssert(!isnull);\n\t}\n\n\tdomain_check(res, isnull, typid, &io->domain_info, mcxt);\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "res",
            "isnull",
            "typid",
            "&io->domain_info",
            "mcxt"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_record_field",
          "args": [
            "io->base_io",
            "io->base_typid",
            "io->base_typmod",
            "colname",
            "mcxt",
            "PointerGetDatum(NULL)",
            "jsv",
            "&isnull"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2993-3056",
          "snippet": "static Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_domain(DomainIOData *io,\n\t\t\t\tOid typid,\n\t\t\t\tconst char *colname,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsValue *jsv,\n\t\t\t\tbool isnull)\n{\n\tDatum\t\tres;\n\n\tif (isnull)\n\t\tres = (Datum) 0;\n\telse\n\t{\n\t\tres = populate_record_field(io->base_io,\n\t\t\t\t\t\t\t\t\tio->base_typid, io->base_typmod,\n\t\t\t\t\t\t\t\t\tcolname, mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &isnull);\n\t\tAssert(!isnull);\n\t}\n\n\tdomain_check(res, isnull, typid, &io->domain_info, mcxt);\n\n\treturn res;\n}"
  },
  {
    "function_name": "populate_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2793-2877",
    "snippet": "static Datum\npopulate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv)\n{\n\tDatum\t\tres;\n\tchar\t   *str = NULL;\n\tchar\t   *json = NULL;\n\n\tif (jsv->is_json)\n\t{\n\t\tint\t\t\tlen = jsv->val.json.len;\n\n\t\tjson = jsv->val.json.str;\n\t\tAssert(json);\n\n\t\t/* already done the hard work in the json case */\n\t\tif ((typid == JSONOID || typid == JSONBOID) &&\n\t\t\tjsv->val.json.type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/*\n\t\t\t * Add quotes around string value (should be already escaped) if\n\t\t\t * converting to json/jsonb.\n\t\t\t */\n\n\t\t\tif (len < 0)\n\t\t\t\tlen = strlen(json);\n\n\t\t\tstr = palloc(len + sizeof(char) * 3);\n\t\t\tstr[0] = '\"';\n\t\t\tmemcpy(&str[1], json, len);\n\t\t\tstr[len + 1] = '\"';\n\t\t\tstr[len + 2] = '\\0';\n\t\t}\n\t\telse if (len >= 0)\n\t\t{\n\t\t\t/* Need to copy non-null-terminated string */\n\t\t\tstr = palloc(len + 1 * sizeof(char));\n\t\t\tmemcpy(str, json, len);\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\telse\n\t\t\tstr = json;\t\t\t/* null-terminated string */\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (typid == JSONBOID)\n\t\t{\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv); /* directly use jsonb */\n\n\t\t\treturn JsonbPGetDatum(jsonb);\n\t\t}\n\t\t/* convert jsonb to string for typio call */\n\t\telse if (typid == JSONOID && jbv->type != jbvBinary)\n\t\t{\n\t\t\t/*\n\t\t\t * Convert scalar jsonb (non-scalars are passed here as jbvBinary)\n\t\t\t * to json string, preserving quotes around top-level strings.\n\t\t\t */\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv);\n\n\t\t\tstr = JsonbToCString(NULL, &jsonb->root, VARSIZE(jsonb));\n\t\t}\n\t\telse if (jbv->type == jbvString)\t/* quotes are stripped */\n\t\t\tstr = pnstrdup(jbv->val.string.val, jbv->val.string.len);\n\t\telse if (jbv->type == jbvBool)\n\t\t\tstr = pstrdup(jbv->val.boolean ? \"true\" : \"false\");\n\t\telse if (jbv->type == jbvNumeric)\n\t\t\tstr = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(jbv->val.numeric)));\n\t\telse if (jbv->type == jbvBinary)\n\t\t\tstr = JsonbToCString(NULL, jbv->val.binary.data,\n\t\t\t\t\t\t\t\t jbv->val.binary.len);\n\t\telse\n\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) jbv->type);\n\t}\n\n\tres = InputFunctionCall(&io->typiofunc, str, io->typioparam, typmod);\n\n\t/* free temporary buffer */\n\tif (str != json)\n\t\tpfree(str);\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&io->typiofunc",
            "str",
            "io->typioparam",
            "typmod"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized jsonb type: %d\"",
            "(int) jbv->type"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "NULL",
            "jbv->val.binary.data",
            "jbv->val.binary.len"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(jbv->val.numeric))"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "PointerGetDatum(jbv->val.numeric)"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "jbv->val.numeric"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "jbv->val.boolean ? \"true\" : \"false\""
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "jbv->val.string.val",
            "jbv->val.string.len"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jsonb"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "jbv"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbPGetDatum",
          "args": [
            "jsonb"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "json",
            "len"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1 * sizeof(char)"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&str[1]",
            "json",
            "len"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "json"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "json"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic Datum\npopulate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv)\n{\n\tDatum\t\tres;\n\tchar\t   *str = NULL;\n\tchar\t   *json = NULL;\n\n\tif (jsv->is_json)\n\t{\n\t\tint\t\t\tlen = jsv->val.json.len;\n\n\t\tjson = jsv->val.json.str;\n\t\tAssert(json);\n\n\t\t/* already done the hard work in the json case */\n\t\tif ((typid == JSONOID || typid == JSONBOID) &&\n\t\t\tjsv->val.json.type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/*\n\t\t\t * Add quotes around string value (should be already escaped) if\n\t\t\t * converting to json/jsonb.\n\t\t\t */\n\n\t\t\tif (len < 0)\n\t\t\t\tlen = strlen(json);\n\n\t\t\tstr = palloc(len + sizeof(char) * 3);\n\t\t\tstr[0] = '\"';\n\t\t\tmemcpy(&str[1], json, len);\n\t\t\tstr[len + 1] = '\"';\n\t\t\tstr[len + 2] = '\\0';\n\t\t}\n\t\telse if (len >= 0)\n\t\t{\n\t\t\t/* Need to copy non-null-terminated string */\n\t\t\tstr = palloc(len + 1 * sizeof(char));\n\t\t\tmemcpy(str, json, len);\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\telse\n\t\t\tstr = json;\t\t\t/* null-terminated string */\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (typid == JSONBOID)\n\t\t{\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv); /* directly use jsonb */\n\n\t\t\treturn JsonbPGetDatum(jsonb);\n\t\t}\n\t\t/* convert jsonb to string for typio call */\n\t\telse if (typid == JSONOID && jbv->type != jbvBinary)\n\t\t{\n\t\t\t/*\n\t\t\t * Convert scalar jsonb (non-scalars are passed here as jbvBinary)\n\t\t\t * to json string, preserving quotes around top-level strings.\n\t\t\t */\n\t\t\tJsonb\t   *jsonb = JsonbValueToJsonb(jbv);\n\n\t\t\tstr = JsonbToCString(NULL, &jsonb->root, VARSIZE(jsonb));\n\t\t}\n\t\telse if (jbv->type == jbvString)\t/* quotes are stripped */\n\t\t\tstr = pnstrdup(jbv->val.string.val, jbv->val.string.len);\n\t\telse if (jbv->type == jbvBool)\n\t\t\tstr = pstrdup(jbv->val.boolean ? \"true\" : \"false\");\n\t\telse if (jbv->type == jbvNumeric)\n\t\t\tstr = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(jbv->val.numeric)));\n\t\telse if (jbv->type == jbvBinary)\n\t\t\tstr = JsonbToCString(NULL, jbv->val.binary.data,\n\t\t\t\t\t\t\t\t jbv->val.binary.len);\n\t\telse\n\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) jbv->type);\n\t}\n\n\tres = InputFunctionCall(&io->typiofunc, str, io->typioparam, typmod);\n\n\t/* free temporary buffer */\n\tif (str != json)\n\t\tpfree(str);\n\n\treturn res;\n}"
  },
  {
    "function_name": "populate_composite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2749-2790",
    "snippet": "static Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static void JsValueToJsObject(JsValue *jsv, JsObject *jso);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain_check",
          "args": [
            "result",
            "isnull",
            "typid",
            "&io->domain_info",
            "mcxt"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "326-353",
          "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsObjectFree",
          "args": [
            "&jso"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatum",
          "args": [
            "tuple"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_record",
          "args": [
            "io->tupdesc",
            "&io->record_io",
            "defaultval",
            "mcxt",
            "&jso"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3102-3208",
          "snippet": "static HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);",
            "static RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);",
            "static void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HeapTupleHeader populate_record(TupleDesc tupdesc, RecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval, MemoryContext mcxt,\n\t\t\t\tJsObject *obj);\nstatic RecordIOData *allocate_record_info(MemoryContext mcxt, int ncolumns);\nstatic void populate_recordset_record(PopulateRecordsetState *state, JsObject *obj);\n\nstatic HeapTupleHeader\npopulate_record(TupleDesc tupdesc,\n\t\t\t\tRecordIOData **record_p,\n\t\t\t\tHeapTupleHeader defaultval,\n\t\t\t\tMemoryContext mcxt,\n\t\t\t\tJsObject *obj)\n{\n\tRecordIOData *record = *record_p;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tHeapTuple\tres;\n\tint\t\t\tncolumns = tupdesc->natts;\n\tint\t\t\ti;\n\n\t/*\n\t * if the input json is empty, we can only skip the rest if we were passed\n\t * in a non-null record, since otherwise there may be issues with domain\n\t * nulls.\n\t */\n\tif (defaultval && JsObjectIsEmpty(obj))\n\t\treturn defaultval;\n\n\t/* (re)allocate metadata cache */\n\tif (record == NULL ||\n\t\trecord->ncolumns != ncolumns)\n\t\t*record_p = record = allocate_record_info(mcxt, ncolumns);\n\n\t/* invalidate metadata cache if the record type has changed */\n\tif (record->record_type != tupdesc->tdtypeid ||\n\t\trecord->record_typmod != tupdesc->tdtypmod)\n\t{\n\t\tMemSet(record, 0, offsetof(RecordIOData, columns) +\n\t\t\t   ncolumns * sizeof(ColumnIOData));\n\t\trecord->record_type = tupdesc->tdtypeid;\n\t\trecord->record_typmod = tupdesc->tdtypmod;\n\t\trecord->ncolumns = ncolumns;\n\t}\n\n\tvalues = (Datum *) palloc(ncolumns * sizeof(Datum));\n\tnulls = (bool *) palloc(ncolumns * sizeof(bool));\n\n\tif (defaultval)\n\t{\n\t\tHeapTupleData tuple;\n\n\t\t/* Build a temporary HeapTuple control structure */\n\t\ttuple.t_len = HeapTupleHeaderGetDatumLength(defaultval);\n\t\tItemPointerSetInvalid(&(tuple.t_self));\n\t\ttuple.t_tableOid = InvalidOid;\n\t\ttuple.t_data = defaultval;\n\n\t\t/* Break down the tuple into fields */\n\t\theap_deform_tuple(&tuple, tupdesc, values, nulls);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < ncolumns; ++i)\n\t\t{\n\t\t\tvalues[i] = (Datum) 0;\n\t\t\tnulls[i] = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ncolumns; ++i)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\t\tchar\t   *colname = NameStr(att->attname);\n\t\tJsValue\t\tfield = {0};\n\t\tbool\t\tfound;\n\n\t\t/* Ignore dropped columns in datatype */\n\t\tif (att->attisdropped)\n\t\t{\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = JsObjectGetField(obj, colname, &field);\n\n\t\t/*\n\t\t * we can't just skip here if the key wasn't found since we might have\n\t\t * a domain to deal with. If we were passed in a non-null record\n\t\t * datum, we assume that the existing values are valid (if they're\n\t\t * not, then it's not our fault), but if we were passed in a null,\n\t\t * then every field which we don't populate needs to be run through\n\t\t * the input function just in case it's a domain type.\n\t\t */\n\t\tif (defaultval && !found)\n\t\t\tcontinue;\n\n\t\tvalues[i] = populate_record_field(&record->columns[i],\n\t\t\t\t\t\t\t\t\t\t  att->atttypid,\n\t\t\t\t\t\t\t\t\t\t  att->atttypmod,\n\t\t\t\t\t\t\t\t\t\t  colname,\n\t\t\t\t\t\t\t\t\t\t  mcxt,\n\t\t\t\t\t\t\t\t\t\t  nulls[i] ? (Datum) 0 : values[i],\n\t\t\t\t\t\t\t\t\t\t  &field,\n\t\t\t\t\t\t\t\t\t\t  &nulls[i]);\n\t}\n\n\tres = heap_form_tuple(tupdesc, values, nulls);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn res->t_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsValueToJsObject",
          "args": [
            "jsv",
            "&jso"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "JsValueToJsObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2682-2722",
          "snippet": "static void\nJsValueToJsObject(JsValue *jsv, JsObject *jso)\n{\n\tjso->is_json = jsv->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\t/* convert plain-text json into a hash table */\n\t\tjso->val.json_hash =\n\t\t\tget_json_object_as_hash(jsv->val.json.str,\n\t\t\t\t\t\t\t\t\tjsv->val.json.len >= 0\n\t\t\t\t\t\t\t\t\t? jsv->val.json.len\n\t\t\t\t\t\t\t\t\t: strlen(jsv->val.json.str),\n\t\t\t\t\t\t\t\t\t\"populate_composite\");\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (jbv->type == jbvBinary &&\n\t\t\tJsonContainerIsObject(jbv->val.binary.data))\n\t\t{\n\t\t\tjso->val.jsonb_cont = jbv->val.binary.data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool\t\tis_scalar;\n\n\t\t\tis_scalar = IsAJsonbScalar(jbv) ||\n\t\t\t\t(jbv->type == jbvBinary &&\n\t\t\t\t JsonContainerIsScalar(jbv->val.binary.data));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t is_scalar\n\t\t\t\t\t ? errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t  \"populate_composite\")\n\t\t\t\t\t : errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t  \"populate_composite\")));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void JsValueToJsObject(JsValue *jsv, JsObject *jso);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void JsValueToJsObject(JsValue *jsv, JsObject *jso);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\nJsValueToJsObject(JsValue *jsv, JsObject *jso)\n{\n\tjso->is_json = jsv->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\t/* convert plain-text json into a hash table */\n\t\tjso->val.json_hash =\n\t\t\tget_json_object_as_hash(jsv->val.json.str,\n\t\t\t\t\t\t\t\t\tjsv->val.json.len >= 0\n\t\t\t\t\t\t\t\t\t? jsv->val.json.len\n\t\t\t\t\t\t\t\t\t: strlen(jsv->val.json.str),\n\t\t\t\t\t\t\t\t\t\"populate_composite\");\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (jbv->type == jbvBinary &&\n\t\t\tJsonContainerIsObject(jbv->val.binary.data))\n\t\t{\n\t\t\tjso->val.jsonb_cont = jbv->val.binary.data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool\t\tis_scalar;\n\n\t\t\tis_scalar = IsAJsonbScalar(jbv) ||\n\t\t\t\t(jbv->type == jbvBinary &&\n\t\t\t\t JsonContainerIsScalar(jbv->val.binary.data));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t is_scalar\n\t\t\t\t\t ? errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t  \"populate_composite\")\n\t\t\t\t\t : errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t  \"populate_composite\")));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cached_tupdesc",
          "args": [
            "io",
            "mcxt"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "update_cached_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2725-2746",
          "snippet": "static void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic void JsValueToJsObject(JsValue *jsv, JsObject *jso);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_composite(CompositeIOData *io,\n\t\t\t\t   Oid typid,\n\t\t\t\t   const char *colname,\n\t\t\t\t   MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval,\n\t\t\t\t   JsValue *jsv,\n\t\t\t\t   bool isnull)\n{\n\tDatum\t\tresult;\n\n\t/* acquire/update cached tuple descriptor */\n\tupdate_cached_tupdesc(io, mcxt);\n\n\tif (isnull)\n\t\tresult = (Datum) 0;\n\telse\n\t{\n\t\tHeapTupleHeader tuple;\n\t\tJsObject\tjso;\n\n\t\t/* prepare input value */\n\t\tJsValueToJsObject(jsv, &jso);\n\n\t\t/* populate resulting record tuple */\n\t\ttuple = populate_record(io->tupdesc, &io->record_io,\n\t\t\t\t\t\t\t\tdefaultval, mcxt, &jso);\n\t\tresult = HeapTupleHeaderGetDatum(tuple);\n\n\t\tJsObjectFree(&jso);\n\t}\n\n\t/*\n\t * If it's domain over composite, check domain constraints.  (This should\n\t * probably get refactored so that we can see the TYPECAT value, but for\n\t * now, we can tell by comparing typid to base_typid.)\n\t */\n\tif (typid != io->base_typid && typid != RECORDOID)\n\t\tdomain_check(result, isnull, typid, &io->domain_info, mcxt);\n\n\treturn result;\n}"
  },
  {
    "function_name": "update_cached_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2725-2746",
    "snippet": "static void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "mcxt"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "io->tupdesc"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "io->base_typid",
            "io->base_typmod"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nupdate_cached_tupdesc(CompositeIOData *io, MemoryContext mcxt)\n{\n\tif (!io->tupdesc ||\n\t\tio->tupdesc->tdtypeid != io->base_typid ||\n\t\tio->tupdesc->tdtypmod != io->base_typmod)\n\t{\n\t\tTupleDesc\ttupdesc = lookup_rowtype_tupdesc(io->base_typid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t io->base_typmod);\n\t\tMemoryContext oldcxt;\n\n\t\tif (io->tupdesc)\n\t\t\tFreeTupleDesc(io->tupdesc);\n\n\t\t/* copy tuple desc without constraints into cache memory context */\n\t\toldcxt = MemoryContextSwitchTo(mcxt);\n\t\tio->tupdesc = CreateTupleDescCopy(tupdesc);\n\t\tMemoryContextSwitchTo(oldcxt);\n\n\t\tReleaseTupleDesc(tupdesc);\n\t}\n}"
  },
  {
    "function_name": "JsValueToJsObject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2682-2722",
    "snippet": "static void\nJsValueToJsObject(JsValue *jsv, JsObject *jso)\n{\n\tjso->is_json = jsv->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\t/* convert plain-text json into a hash table */\n\t\tjso->val.json_hash =\n\t\t\tget_json_object_as_hash(jsv->val.json.str,\n\t\t\t\t\t\t\t\t\tjsv->val.json.len >= 0\n\t\t\t\t\t\t\t\t\t? jsv->val.json.len\n\t\t\t\t\t\t\t\t\t: strlen(jsv->val.json.str),\n\t\t\t\t\t\t\t\t\t\"populate_composite\");\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (jbv->type == jbvBinary &&\n\t\t\tJsonContainerIsObject(jbv->val.binary.data))\n\t\t{\n\t\t\tjso->val.jsonb_cont = jbv->val.binary.data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool\t\tis_scalar;\n\n\t\t\tis_scalar = IsAJsonbScalar(jbv) ||\n\t\t\t\t(jbv->type == jbvBinary &&\n\t\t\t\t JsonContainerIsScalar(jbv->val.binary.data));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t is_scalar\n\t\t\t\t\t ? errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t  \"populate_composite\")\n\t\t\t\t\t : errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t  \"populate_composite\")));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void JsValueToJsObject(JsValue *jsv, JsObject *jso);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t is_scalar\n\t\t\t\t\t ? errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t  \"populate_composite\")\n\t\t\t\t\t : errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t  \"populate_composite\"))"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on an array\"",
            "\"populate_composite\""
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsScalar",
          "args": [
            "jbv->val.binary.data"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "jbv"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsObject",
          "args": [
            "jbv->val.binary.data"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_json_object_as_hash",
          "args": [
            "jsv->val.json.str",
            "jsv->val.json.len >= 0\n\t\t\t\t\t\t\t\t\t? jsv->val.json.len\n\t\t\t\t\t\t\t\t\t: strlen(jsv->val.json.str)",
            "\"populate_composite\""
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "get_json_object_as_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3345-3379",
          "snippet": "static HTAB *\nget_json_object_as_hash(char *json, int len, const char *funcname)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *tab;\n\tJHashState *state;\n\tJsonLexContext *lex = makeJsonLexContextCstringLen(json, len, true);\n\tJsonSemAction *sem;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\ttab = hash_create(\"json object hashtable\",\n\t\t\t\t\t  100,\n\t\t\t\t\t  &ctl,\n\t\t\t\t\t  HASH_ELEM | HASH_CONTEXT);\n\n\tstate = palloc0(sizeof(JHashState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->function_name = funcname;\n\tstate->hash = tab;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = hash_array_start;\n\tsem->scalar = hash_scalar;\n\tsem->object_field_start = hash_object_field_start;\n\tsem->object_field_end = hash_object_field_end;\n\n\tpg_parse_json(lex, sem);\n\n\treturn tab;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic HTAB *\nget_json_object_as_hash(char *json, int len, const char *funcname)\n{\n\tHASHCTL\t\tctl;\n\tHTAB\t   *tab;\n\tJHashState *state;\n\tJsonLexContext *lex = makeJsonLexContextCstringLen(json, len, true);\n\tJsonSemAction *sem;\n\n\tmemset(&ctl, 0, sizeof(ctl));\n\tctl.keysize = NAMEDATALEN;\n\tctl.entrysize = sizeof(JsonHashEntry);\n\tctl.hcxt = CurrentMemoryContext;\n\ttab = hash_create(\"json object hashtable\",\n\t\t\t\t\t  100,\n\t\t\t\t\t  &ctl,\n\t\t\t\t\t  HASH_ELEM | HASH_CONTEXT);\n\n\tstate = palloc0(sizeof(JHashState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\tstate->function_name = funcname;\n\tstate->hash = tab;\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = hash_array_start;\n\tsem->scalar = hash_scalar;\n\tsem->object_field_start = hash_object_field_start;\n\tsem->object_field_end = hash_object_field_end;\n\n\tpg_parse_json(lex, sem);\n\n\treturn tab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "jsv->val.json.str"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void JsValueToJsObject(JsValue *jsv, JsObject *jso);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\nJsValueToJsObject(JsValue *jsv, JsObject *jso)\n{\n\tjso->is_json = jsv->is_json;\n\n\tif (jsv->is_json)\n\t{\n\t\t/* convert plain-text json into a hash table */\n\t\tjso->val.json_hash =\n\t\t\tget_json_object_as_hash(jsv->val.json.str,\n\t\t\t\t\t\t\t\t\tjsv->val.json.len >= 0\n\t\t\t\t\t\t\t\t\t? jsv->val.json.len\n\t\t\t\t\t\t\t\t\t: strlen(jsv->val.json.str),\n\t\t\t\t\t\t\t\t\t\"populate_composite\");\n\t}\n\telse\n\t{\n\t\tJsonbValue *jbv = jsv->val.jsonb;\n\n\t\tif (jbv->type == jbvBinary &&\n\t\t\tJsonContainerIsObject(jbv->val.binary.data))\n\t\t{\n\t\t\tjso->val.jsonb_cont = jbv->val.binary.data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool\t\tis_scalar;\n\n\t\t\tis_scalar = IsAJsonbScalar(jbv) ||\n\t\t\t\t(jbv->type == jbvBinary &&\n\t\t\t\t JsonContainerIsScalar(jbv->val.binary.data));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t is_scalar\n\t\t\t\t\t ? errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t  \"populate_composite\")\n\t\t\t\t\t : errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t  \"populate_composite\")));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "populate_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2635-2680",
    "snippet": "static Datum\npopulate_array(ArrayIOData *aio,\n\t\t\t   const char *colname,\n\t\t\t   MemoryContext mcxt,\n\t\t\t   JsValue *jsv)\n{\n\tPopulateArrayContext ctx;\n\tDatum\t\tresult;\n\tint\t\t   *lbs;\n\tint\t\t\ti;\n\n\tctx.aio = aio;\n\tctx.mcxt = mcxt;\n\tctx.acxt = CurrentMemoryContext;\n\tctx.astate = initArrayResult(aio->element_type, ctx.acxt, true);\n\tctx.colname = colname;\n\tctx.ndims = 0;\t\t\t\t/* unknown yet */\n\tctx.dims = NULL;\n\tctx.sizes = NULL;\n\n\tif (jsv->is_json)\n\t\tpopulate_array_json(&ctx, jsv->val.json.str,\n\t\t\t\t\t\t\tjsv->val.json.len >= 0 ? jsv->val.json.len\n\t\t\t\t\t\t\t: strlen(jsv->val.json.str));\n\telse\n\t{\n\t\tpopulate_array_dim_jsonb(&ctx, jsv->val.jsonb, 1);\n\t\tctx.dims[0] = ctx.sizes[0];\n\t}\n\n\tAssert(ctx.ndims > 0);\n\n\tlbs = palloc(sizeof(int) * ctx.ndims);\n\n\tfor (i = 0; i < ctx.ndims; i++)\n\t\tlbs[i] = 1;\n\n\tresult = makeMdArrayResult(ctx.astate, ctx.ndims, ctx.dims, lbs,\n\t\t\t\t\t\t\t   ctx.acxt, true);\n\n\tpfree(ctx.dims);\n\tpfree(ctx.sizes);\n\tpfree(lbs);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "lbs"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeMdArrayResult",
          "args": [
            "ctx.astate",
            "ctx.ndims",
            "ctx.dims",
            "lbs",
            "ctx.acxt",
            "true"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "makeMdArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5149-5183",
          "snippet": "Datum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nDatum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(int) * ctx.ndims"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx.ndims > 0"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array_dim_jsonb",
          "args": [
            "&ctx",
            "jsv->val.jsonb",
            "1"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_dim_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2564-2632",
          "snippet": "static void\npopulate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */\n\t\t\t\t\t\t JsonbValue *jbv,\t/* jsonb sub-array */\n\t\t\t\t\t\t int ndim)\t/* current dimension */\n{\n\tJsonbContainer *jbc = jbv->val.binary.data;\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok;\n\tJsonbValue\tval;\n\tJsValue\t\tjsv;\n\n\tcheck_stack_depth();\n\n\tif (jbv->type != jbvBinary || !JsonContainerIsArray(jbc))\n\t\tpopulate_array_report_expected_array(ctx, ndim - 1);\n\n\tAssert(!JsonContainerIsScalar(jbc));\n\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\n\t/*\n\t * If the number of dimensions is not yet known and we have found end of\n\t * the array, or the first child element is not an array, then assign the\n\t * number of dimensions now.\n\t */\n\tif (ctx->ndims <= 0 &&\n\t\t(tok == WJB_END_ARRAY ||\n\t\t (tok == WJB_ELEM &&\n\t\t  (val.type != jbvBinary ||\n\t\t   !JsonContainerIsArray(val.val.binary.data)))))\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\n\tjsv.is_json = false;\n\tjsv.val.jsonb = &val;\n\n\t/* process all the array elements */\n\twhile (tok == WJB_ELEM)\n\t{\n\t\t/*\n\t\t * Recurse only if the dimensions of dimensions is still unknown or if\n\t\t * it is not the innermost dimension.\n\t\t */\n\t\tif (ctx->ndims > 0 && ndim >= ctx->ndims)\n\t\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t\telse\n\t\t{\n\t\t\t/* populate child sub-array */\n\t\t\tpopulate_array_dim_jsonb(ctx, &val, ndim + 1);\n\n\t\t\t/* number of dimensions should be already known */\n\t\t\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\t\t\tpopulate_array_check_dimension(ctx, ndim);\n\t\t}\n\n\t\ttok = JsonbIteratorNext(&it, &val, true);\n\t}\n\n\tAssert(tok == WJB_END_ARRAY);\n\n\t/* free iterator, iterating until WJB_DONE */\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_DONE && !it);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\npopulate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */\n\t\t\t\t\t\t JsonbValue *jbv,\t/* jsonb sub-array */\n\t\t\t\t\t\t int ndim)\t/* current dimension */\n{\n\tJsonbContainer *jbc = jbv->val.binary.data;\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok;\n\tJsonbValue\tval;\n\tJsValue\t\tjsv;\n\n\tcheck_stack_depth();\n\n\tif (jbv->type != jbvBinary || !JsonContainerIsArray(jbc))\n\t\tpopulate_array_report_expected_array(ctx, ndim - 1);\n\n\tAssert(!JsonContainerIsScalar(jbc));\n\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\n\t/*\n\t * If the number of dimensions is not yet known and we have found end of\n\t * the array, or the first child element is not an array, then assign the\n\t * number of dimensions now.\n\t */\n\tif (ctx->ndims <= 0 &&\n\t\t(tok == WJB_END_ARRAY ||\n\t\t (tok == WJB_ELEM &&\n\t\t  (val.type != jbvBinary ||\n\t\t   !JsonContainerIsArray(val.val.binary.data)))))\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\n\tjsv.is_json = false;\n\tjsv.val.jsonb = &val;\n\n\t/* process all the array elements */\n\twhile (tok == WJB_ELEM)\n\t{\n\t\t/*\n\t\t * Recurse only if the dimensions of dimensions is still unknown or if\n\t\t * it is not the innermost dimension.\n\t\t */\n\t\tif (ctx->ndims > 0 && ndim >= ctx->ndims)\n\t\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t\telse\n\t\t{\n\t\t\t/* populate child sub-array */\n\t\t\tpopulate_array_dim_jsonb(ctx, &val, ndim + 1);\n\n\t\t\t/* number of dimensions should be already known */\n\t\t\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\t\t\tpopulate_array_check_dimension(ctx, ndim);\n\t\t}\n\n\t\ttok = JsonbIteratorNext(&it, &val, true);\n\t}\n\n\tAssert(tok == WJB_END_ARRAY);\n\n\t/* free iterator, iterating until WJB_DONE */\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_DONE && !it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_json",
          "args": [
            "&ctx",
            "jsv->val.json.str",
            "jsv->val.json.len >= 0 ? jsv->val.json.len\n\t\t\t\t\t\t\t: strlen(jsv->val.json.str)"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2535-2558",
          "snippet": "static void\npopulate_array_json(PopulateArrayContext *ctx, char *json, int len)\n{\n\tPopulateArrayState state;\n\tJsonSemAction sem;\n\n\tstate.lex = makeJsonLexContextCstringLen(json, len, true);\n\tstate.ctx = ctx;\n\n\tmemset(&sem, 0, sizeof(sem));\n\tsem.semstate = (void *) &state;\n\tsem.object_start = populate_array_object_start;\n\tsem.array_end = populate_array_array_end;\n\tsem.array_element_start = populate_array_element_start;\n\tsem.array_element_end = populate_array_element_end;\n\tsem.scalar = populate_array_scalar;\n\n\tpg_parse_json(state.lex, &sem);\n\n\t/* number of dimensions should be already known */\n\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\tpfree(state.lex);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_array_json(PopulateArrayContext *ctx, char *json, int len)\n{\n\tPopulateArrayState state;\n\tJsonSemAction sem;\n\n\tstate.lex = makeJsonLexContextCstringLen(json, len, true);\n\tstate.ctx = ctx;\n\n\tmemset(&sem, 0, sizeof(sem));\n\tsem.semstate = (void *) &state;\n\tsem.object_start = populate_array_object_start;\n\tsem.array_end = populate_array_array_end;\n\tsem.array_element_start = populate_array_element_start;\n\tsem.array_element_end = populate_array_element_end;\n\tsem.scalar = populate_array_scalar;\n\n\tpg_parse_json(state.lex, &sem);\n\n\t/* number of dimensions should be already known */\n\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\tpfree(state.lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "jsv->val.json.str"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "aio->element_type",
            "ctx.acxt",
            "true"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic Datum\npopulate_array(ArrayIOData *aio,\n\t\t\t   const char *colname,\n\t\t\t   MemoryContext mcxt,\n\t\t\t   JsValue *jsv)\n{\n\tPopulateArrayContext ctx;\n\tDatum\t\tresult;\n\tint\t\t   *lbs;\n\tint\t\t\ti;\n\n\tctx.aio = aio;\n\tctx.mcxt = mcxt;\n\tctx.acxt = CurrentMemoryContext;\n\tctx.astate = initArrayResult(aio->element_type, ctx.acxt, true);\n\tctx.colname = colname;\n\tctx.ndims = 0;\t\t\t\t/* unknown yet */\n\tctx.dims = NULL;\n\tctx.sizes = NULL;\n\n\tif (jsv->is_json)\n\t\tpopulate_array_json(&ctx, jsv->val.json.str,\n\t\t\t\t\t\t\tjsv->val.json.len >= 0 ? jsv->val.json.len\n\t\t\t\t\t\t\t: strlen(jsv->val.json.str));\n\telse\n\t{\n\t\tpopulate_array_dim_jsonb(&ctx, jsv->val.jsonb, 1);\n\t\tctx.dims[0] = ctx.sizes[0];\n\t}\n\n\tAssert(ctx.ndims > 0);\n\n\tlbs = palloc(sizeof(int) * ctx.ndims);\n\n\tfor (i = 0; i < ctx.ndims; i++)\n\t\tlbs[i] = 1;\n\n\tresult = makeMdArrayResult(ctx.astate, ctx.ndims, ctx.dims, lbs,\n\t\t\t\t\t\t\t   ctx.acxt, true);\n\n\tpfree(ctx.dims);\n\tpfree(ctx.sizes);\n\tpfree(lbs);\n\n\treturn result;\n}"
  },
  {
    "function_name": "populate_array_dim_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2564-2632",
    "snippet": "static void\npopulate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */\n\t\t\t\t\t\t JsonbValue *jbv,\t/* jsonb sub-array */\n\t\t\t\t\t\t int ndim)\t/* current dimension */\n{\n\tJsonbContainer *jbc = jbv->val.binary.data;\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok;\n\tJsonbValue\tval;\n\tJsValue\t\tjsv;\n\n\tcheck_stack_depth();\n\n\tif (jbv->type != jbvBinary || !JsonContainerIsArray(jbc))\n\t\tpopulate_array_report_expected_array(ctx, ndim - 1);\n\n\tAssert(!JsonContainerIsScalar(jbc));\n\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\n\t/*\n\t * If the number of dimensions is not yet known and we have found end of\n\t * the array, or the first child element is not an array, then assign the\n\t * number of dimensions now.\n\t */\n\tif (ctx->ndims <= 0 &&\n\t\t(tok == WJB_END_ARRAY ||\n\t\t (tok == WJB_ELEM &&\n\t\t  (val.type != jbvBinary ||\n\t\t   !JsonContainerIsArray(val.val.binary.data)))))\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\n\tjsv.is_json = false;\n\tjsv.val.jsonb = &val;\n\n\t/* process all the array elements */\n\twhile (tok == WJB_ELEM)\n\t{\n\t\t/*\n\t\t * Recurse only if the dimensions of dimensions is still unknown or if\n\t\t * it is not the innermost dimension.\n\t\t */\n\t\tif (ctx->ndims > 0 && ndim >= ctx->ndims)\n\t\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t\telse\n\t\t{\n\t\t\t/* populate child sub-array */\n\t\t\tpopulate_array_dim_jsonb(ctx, &val, ndim + 1);\n\n\t\t\t/* number of dimensions should be already known */\n\t\t\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\t\t\tpopulate_array_check_dimension(ctx, ndim);\n\t\t}\n\n\t\ttok = JsonbIteratorNext(&it, &val, true);\n\t}\n\n\tAssert(tok == WJB_END_ARRAY);\n\n\t/* free iterator, iterating until WJB_DONE */\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_DONE && !it);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_DONE && !it"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&val",
            "true"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_END_ARRAY"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array_check_dimension",
          "args": [
            "ctx",
            "ndim"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_check_dimension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2387-2407",
          "snippet": "static void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx->ndims > 0 && ctx->dims"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array_dim_jsonb",
          "args": [
            "ctx",
            "&val",
            "ndim + 1"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_dim_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2564-2632",
          "snippet": "static void\npopulate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */\n\t\t\t\t\t\t JsonbValue *jbv,\t/* jsonb sub-array */\n\t\t\t\t\t\t int ndim)\t/* current dimension */\n{\n\tJsonbContainer *jbc = jbv->val.binary.data;\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok;\n\tJsonbValue\tval;\n\tJsValue\t\tjsv;\n\n\tcheck_stack_depth();\n\n\tif (jbv->type != jbvBinary || !JsonContainerIsArray(jbc))\n\t\tpopulate_array_report_expected_array(ctx, ndim - 1);\n\n\tAssert(!JsonContainerIsScalar(jbc));\n\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\n\t/*\n\t * If the number of dimensions is not yet known and we have found end of\n\t * the array, or the first child element is not an array, then assign the\n\t * number of dimensions now.\n\t */\n\tif (ctx->ndims <= 0 &&\n\t\t(tok == WJB_END_ARRAY ||\n\t\t (tok == WJB_ELEM &&\n\t\t  (val.type != jbvBinary ||\n\t\t   !JsonContainerIsArray(val.val.binary.data)))))\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\n\tjsv.is_json = false;\n\tjsv.val.jsonb = &val;\n\n\t/* process all the array elements */\n\twhile (tok == WJB_ELEM)\n\t{\n\t\t/*\n\t\t * Recurse only if the dimensions of dimensions is still unknown or if\n\t\t * it is not the innermost dimension.\n\t\t */\n\t\tif (ctx->ndims > 0 && ndim >= ctx->ndims)\n\t\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t\telse\n\t\t{\n\t\t\t/* populate child sub-array */\n\t\t\tpopulate_array_dim_jsonb(ctx, &val, ndim + 1);\n\n\t\t\t/* number of dimensions should be already known */\n\t\t\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\t\t\tpopulate_array_check_dimension(ctx, ndim);\n\t\t}\n\n\t\ttok = JsonbIteratorNext(&it, &val, true);\n\t}\n\n\tAssert(tok == WJB_END_ARRAY);\n\n\t/* free iterator, iterating until WJB_DONE */\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_DONE && !it);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_element",
          "args": [
            "ctx",
            "ndim",
            "&jsv"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2409-2427",
          "snippet": "static void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_assign_ndims",
          "args": [
            "ctx",
            "ndim"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_assign_ndims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2368-2384",
          "snippet": "static void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\n\nstatic void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "val.val.binary.data"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_BEGIN_ARRAY"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "jbc"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!JsonContainerIsScalar(jbc)"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsScalar",
          "args": [
            "jbc"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array_report_expected_array",
          "args": [
            "ctx",
            "ndim - 1"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_report_expected_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2325-2365",
          "snippet": "static void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "jbc"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\npopulate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */\n\t\t\t\t\t\t JsonbValue *jbv,\t/* jsonb sub-array */\n\t\t\t\t\t\t int ndim)\t/* current dimension */\n{\n\tJsonbContainer *jbc = jbv->val.binary.data;\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok;\n\tJsonbValue\tval;\n\tJsValue\t\tjsv;\n\n\tcheck_stack_depth();\n\n\tif (jbv->type != jbvBinary || !JsonContainerIsArray(jbc))\n\t\tpopulate_array_report_expected_array(ctx, ndim - 1);\n\n\tAssert(!JsonContainerIsScalar(jbc));\n\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &val, true);\n\n\t/*\n\t * If the number of dimensions is not yet known and we have found end of\n\t * the array, or the first child element is not an array, then assign the\n\t * number of dimensions now.\n\t */\n\tif (ctx->ndims <= 0 &&\n\t\t(tok == WJB_END_ARRAY ||\n\t\t (tok == WJB_ELEM &&\n\t\t  (val.type != jbvBinary ||\n\t\t   !JsonContainerIsArray(val.val.binary.data)))))\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\n\tjsv.is_json = false;\n\tjsv.val.jsonb = &val;\n\n\t/* process all the array elements */\n\twhile (tok == WJB_ELEM)\n\t{\n\t\t/*\n\t\t * Recurse only if the dimensions of dimensions is still unknown or if\n\t\t * it is not the innermost dimension.\n\t\t */\n\t\tif (ctx->ndims > 0 && ndim >= ctx->ndims)\n\t\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t\telse\n\t\t{\n\t\t\t/* populate child sub-array */\n\t\t\tpopulate_array_dim_jsonb(ctx, &val, ndim + 1);\n\n\t\t\t/* number of dimensions should be already known */\n\t\t\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\t\t\tpopulate_array_check_dimension(ctx, ndim);\n\t\t}\n\n\t\ttok = JsonbIteratorNext(&it, &val, true);\n\t}\n\n\tAssert(tok == WJB_END_ARRAY);\n\n\t/* free iterator, iterating until WJB_DONE */\n\ttok = JsonbIteratorNext(&it, &val, true);\n\tAssert(tok == WJB_DONE && !it);\n}"
  },
  {
    "function_name": "populate_array_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2535-2558",
    "snippet": "static void\npopulate_array_json(PopulateArrayContext *ctx, char *json, int len)\n{\n\tPopulateArrayState state;\n\tJsonSemAction sem;\n\n\tstate.lex = makeJsonLexContextCstringLen(json, len, true);\n\tstate.ctx = ctx;\n\n\tmemset(&sem, 0, sizeof(sem));\n\tsem.semstate = (void *) &state;\n\tsem.object_start = populate_array_object_start;\n\tsem.array_end = populate_array_array_end;\n\tsem.array_element_start = populate_array_element_start;\n\tsem.array_element_end = populate_array_element_end;\n\tsem.scalar = populate_array_scalar;\n\n\tpg_parse_json(state.lex, &sem);\n\n\t/* number of dimensions should be already known */\n\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\tpfree(state.lex);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state.lex"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx->ndims > 0 && ctx->dims"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "state.lex",
            "&sem"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sem",
            "0",
            "sizeof(sem)"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeJsonLexContextCstringLen",
          "args": [
            "json",
            "len",
            "true"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContextCstringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "308-319",
          "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_array_json(PopulateArrayContext *ctx, char *json, int len)\n{\n\tPopulateArrayState state;\n\tJsonSemAction sem;\n\n\tstate.lex = makeJsonLexContextCstringLen(json, len, true);\n\tstate.ctx = ctx;\n\n\tmemset(&sem, 0, sizeof(sem));\n\tsem.semstate = (void *) &state;\n\tsem.object_start = populate_array_object_start;\n\tsem.array_end = populate_array_array_end;\n\tsem.array_element_start = populate_array_element_start;\n\tsem.array_element_end = populate_array_element_end;\n\tsem.scalar = populate_array_scalar;\n\n\tpg_parse_json(state.lex, &sem);\n\n\t/* number of dimensions should be already known */\n\tAssert(ctx->ndims > 0 && ctx->dims);\n\n\tpfree(state.lex);\n}"
  },
  {
    "function_name": "populate_array_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2513-2532",
    "snippet": "static void\npopulate_array_scalar(void *_state, char *token, JsonTokenType tokentype)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\telse if (ndim < ctx->ndims)\n\t\tpopulate_array_report_expected_array(ctx, ndim);\n\n\tif (ndim == ctx->ndims)\n\t{\n\t\t/* remember the scalar element token */\n\t\tstate->element_scalar = token;\n\t\t/* element_type must already be set in populate_array_element_start() */\n\t\tAssert(state->element_type == tokentype);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->element_type == tokentype"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_array_report_expected_array",
          "args": [
            "ctx",
            "ndim"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_report_expected_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2325-2365",
          "snippet": "static void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_assign_ndims",
          "args": [
            "ctx",
            "ndim"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_assign_ndims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2368-2384",
          "snippet": "static void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\n\nstatic void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\npopulate_array_scalar(void *_state, char *token, JsonTokenType tokentype)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(ctx, ndim);\n\telse if (ndim < ctx->ndims)\n\t\tpopulate_array_report_expected_array(ctx, ndim);\n\n\tif (ndim == ctx->ndims)\n\t{\n\t\t/* remember the scalar element token */\n\t\tstate->element_scalar = token;\n\t\t/* element_type must already be set in populate_array_element_start() */\n\t\tAssert(state->element_type == tokentype);\n\t}\n}"
  },
  {
    "function_name": "populate_array_element_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2474-2510",
    "snippet": "static void\npopulate_array_element_end(void *_state, bool isnull)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tAssert(ctx->ndims > 0);\n\n\tif (ndim == ctx->ndims)\n\t{\n\t\tJsValue\t\tjsv;\n\n\t\tjsv.is_json = true;\n\t\tjsv.val.json.type = state->element_type;\n\n\t\tif (isnull)\n\t\t{\n\t\t\tAssert(jsv.val.json.type == JSON_TOKEN_NULL);\n\t\t\tjsv.val.json.str = NULL;\n\t\t\tjsv.val.json.len = 0;\n\t\t}\n\t\telse if (state->element_scalar)\n\t\t{\n\t\t\tjsv.val.json.str = state->element_scalar;\n\t\t\tjsv.val.json.len = -1;\t/* null-terminated */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsv.val.json.str = state->element_start;\n\t\t\tjsv.val.json.len = (state->lex->prev_token_terminator -\n\t\t\t\t\t\t\t\tstate->element_start) * sizeof(char);\n\t\t}\n\n\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_array_element",
          "args": [
            "ctx",
            "ndim",
            "&jsv"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2409-2427",
          "snippet": "static void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "jsv.val.json.type == JSON_TOKEN_NULL"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx->ndims > 0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\npopulate_array_element_end(void *_state, bool isnull)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tAssert(ctx->ndims > 0);\n\n\tif (ndim == ctx->ndims)\n\t{\n\t\tJsValue\t\tjsv;\n\n\t\tjsv.is_json = true;\n\t\tjsv.val.json.type = state->element_type;\n\n\t\tif (isnull)\n\t\t{\n\t\t\tAssert(jsv.val.json.type == JSON_TOKEN_NULL);\n\t\t\tjsv.val.json.str = NULL;\n\t\t\tjsv.val.json.len = 0;\n\t\t}\n\t\telse if (state->element_scalar)\n\t\t{\n\t\t\tjsv.val.json.str = state->element_scalar;\n\t\t\tjsv.val.json.len = -1;\t/* null-terminated */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsv.val.json.str = state->element_start;\n\t\t\tjsv.val.json.len = (state->lex->prev_token_terminator -\n\t\t\t\t\t\t\t\tstate->element_start) * sizeof(char);\n\t\t}\n\n\t\tpopulate_array_element(ctx, ndim, &jsv);\n\t}\n}"
  },
  {
    "function_name": "populate_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2458-2471",
    "snippet": "static void\npopulate_array_element_start(void *_state, bool isnull)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (state->ctx->ndims <= 0 || ndim == state->ctx->ndims)\n\t{\n\t\t/* remember current array element start */\n\t\tstate->element_start = state->lex->token_start;\n\t\tstate->element_type = state->lex->token_type;\n\t\tstate->element_scalar = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\npopulate_array_element_start(void *_state, bool isnull)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (state->ctx->ndims <= 0 || ndim == state->ctx->ndims)\n\t{\n\t\t/* remember current array element start */\n\t\tstate->element_start = state->lex->token_start;\n\t\tstate->element_type = state->lex->token_type;\n\t\tstate->element_scalar = NULL;\n\t}\n}"
  },
  {
    "function_name": "populate_array_array_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2443-2455",
    "snippet": "static void\npopulate_array_array_end(void *_state)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(ctx, ndim + 1);\n\n\tif (ndim < ctx->ndims)\n\t\tpopulate_array_check_dimension(ctx, ndim);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_array_check_dimension",
          "args": [
            "ctx",
            "ndim"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_check_dimension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2387-2407",
          "snippet": "static void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_assign_ndims",
          "args": [
            "ctx",
            "ndim + 1"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_assign_ndims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2368-2384",
          "snippet": "static void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\n\nstatic void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_array_array_end(void *_state)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tPopulateArrayContext *ctx = state->ctx;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(ctx, ndim + 1);\n\n\tif (ndim < ctx->ndims)\n\t\tpopulate_array_check_dimension(ctx, ndim);\n}"
  },
  {
    "function_name": "populate_array_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2430-2440",
    "snippet": "static void\npopulate_array_object_start(void *_state)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (state->ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(state->ctx, ndim);\n\telse if (ndim < state->ctx->ndims)\n\t\tpopulate_array_report_expected_array(state->ctx, ndim);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_array_report_expected_array",
          "args": [
            "state->ctx",
            "ndim"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_report_expected_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2325-2365",
          "snippet": "static void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_assign_ndims",
          "args": [
            "state->ctx",
            "ndim"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_assign_ndims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2368-2384",
          "snippet": "static void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\n\nstatic void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\npopulate_array_object_start(void *_state)\n{\n\tPopulateArrayState *state = (PopulateArrayState *) _state;\n\tint\t\t\tndim = state->lex->lex_level;\n\n\tif (state->ctx->ndims <= 0)\n\t\tpopulate_array_assign_ndims(state->ctx, ndim);\n\telse if (ndim < state->ctx->ndims)\n\t\tpopulate_array_report_expected_array(state->ctx, ndim);\n}"
  },
  {
    "function_name": "populate_array_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2409-2427",
    "snippet": "static void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
      "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
      "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ndim > 0"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "ctx->astate",
            "element",
            "element_isnull",
            "ctx->aio->element_type",
            "ctx->acxt"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_record_field",
          "args": [
            "ctx->aio->element_info",
            "ctx->aio->element_type",
            "ctx->aio->element_typmod",
            "NULL",
            "ctx->mcxt",
            "PointerGetDatum(NULL)",
            "jsv",
            "&element_isnull"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2993-3056",
          "snippet": "static Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_start(void *state, char *fname, bool isnull);",
            "static void get_object_field_end(void *state, char *fname, bool isnull);",
            "static void get_array_element_start(void *state, bool isnull);",
            "static void get_array_element_end(void *state, bool isnull);",
            "static void alen_array_element_start(void *state, bool isnull);",
            "static void each_object_field_start(void *state, char *fname, bool isnull);",
            "static void each_object_field_end(void *state, char *fname, bool isnull);",
            "static void elements_array_element_start(void *state, bool isnull);",
            "static void elements_array_element_end(void *state, bool isnull);",
            "static void populate_array_element_start(void *_state, bool isnull);",
            "static void populate_array_element_end(void *_state, bool isnull);",
            "static void hash_object_field_start(void *state, char *fname, bool isnull);",
            "static void hash_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
            "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
            "static void populate_recordset_array_element_start(void *state, bool isnull);",
            "static void sn_object_field_start(void *state, char *fname, bool isnull);",
            "static void sn_array_element_start(void *state, bool isnull);",
            "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
            "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
            "static void transform_string_values_array_element_start(void *state, bool isnull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic Datum\npopulate_record_field(ColumnIOData *col,\n\t\t\t\t\t  Oid typid,\n\t\t\t\t\t  int32 typmod,\n\t\t\t\t\t  const char *colname,\n\t\t\t\t\t  MemoryContext mcxt,\n\t\t\t\t\t  Datum defaultval,\n\t\t\t\t\t  JsValue *jsv,\n\t\t\t\t\t  bool *isnull)\n{\n\tTypeCat\t\ttypcat;\n\n\tcheck_stack_depth();\n\n\t/*\n\t * Prepare column metadata cache for the given type.  Force lookup of the\n\t * scalar_io data so that the json string hack below will work.\n\t */\n\tif (col->typid != typid || col->typmod != typmod)\n\t\tprepare_column_cache(col, typid, typmod, mcxt, true);\n\n\t*isnull = JsValueIsNull(jsv);\n\n\ttypcat = col->typcat;\n\n\t/* try to convert json string to a non-scalar type through input function */\n\tif (JsValueIsString(jsv) &&\n\t\t(typcat == TYPECAT_ARRAY ||\n\t\t typcat == TYPECAT_COMPOSITE ||\n\t\t typcat == TYPECAT_COMPOSITE_DOMAIN))\n\t\ttypcat = TYPECAT_SCALAR;\n\n\t/* we must perform domain checks for NULLs, otherwise exit immediately */\n\tif (*isnull &&\n\t\ttypcat != TYPECAT_DOMAIN &&\n\t\ttypcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\treturn (Datum) 0;\n\n\tswitch (typcat)\n\t{\n\t\tcase TYPECAT_SCALAR:\n\t\t\treturn populate_scalar(&col->scalar_io, typid, typmod, jsv);\n\n\t\tcase TYPECAT_ARRAY:\n\t\t\treturn populate_array(&col->io.array, colname, mcxt, jsv);\n\n\t\tcase TYPECAT_COMPOSITE:\n\t\tcase TYPECAT_COMPOSITE_DOMAIN:\n\t\t\treturn populate_composite(&col->io.composite, typid,\n\t\t\t\t\t\t\t\t\t  colname, mcxt,\n\t\t\t\t\t\t\t\t\t  DatumGetPointer(defaultval)\n\t\t\t\t\t\t\t\t\t  ? DatumGetHeapTupleHeader(defaultval)\n\t\t\t\t\t\t\t\t\t  : NULL,\n\t\t\t\t\t\t\t\t\t  jsv, *isnull);\n\n\t\tcase TYPECAT_DOMAIN:\n\t\t\treturn populate_domain(&col->io.domain, typid, colname, mcxt,\n\t\t\t\t\t\t\t\t   jsv, *isnull);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized type category '%c'\", typcat);\n\t\t\treturn (Datum) 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\n\nstatic void\npopulate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)\n{\n\tDatum\t\telement;\n\tbool\t\telement_isnull;\n\n\t/* populate the array element */\n\telement = populate_record_field(ctx->aio->element_info,\n\t\t\t\t\t\t\t\t\tctx->aio->element_type,\n\t\t\t\t\t\t\t\t\tctx->aio->element_typmod,\n\t\t\t\t\t\t\t\t\tNULL, ctx->mcxt, PointerGetDatum(NULL),\n\t\t\t\t\t\t\t\t\tjsv, &element_isnull);\n\n\taccumArrayResult(ctx->astate, element, element_isnull,\n\t\t\t\t\t ctx->aio->element_type, ctx->acxt);\n\n\tAssert(ndim > 0);\n\tctx->sizes[ndim - 1]++;\t\t/* increment current dimension counter */\n}"
  },
  {
    "function_name": "populate_array_check_dimension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2387-2407",
    "snippet": "static void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\"))"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\""
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed JSON array\""
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_check_dimension(PopulateArrayContext *ctx, int ndim)\n{\n\tint\t\t\tdim = ctx->sizes[ndim]; /* current dimension counter */\n\n\tif (ctx->dims[ndim] == -1)\n\t\tctx->dims[ndim] = dim;\t/* assign dimension if not yet known */\n\telse if (ctx->dims[ndim] != dim)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"malformed JSON array\"),\n\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t   \"sub-arrays with matching dimensions.\")));\n\n\t/* reset the current array dimension size counter */\n\tctx->sizes[ndim] = 0;\n\n\t/* increment the parent dimension counter if it is a nested sub-array */\n\tif (ndim > 0)\n\t\tctx->sizes[ndim - 1]++;\n}"
  },
  {
    "function_name": "populate_array_assign_ndims",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2368-2384",
    "snippet": "static void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(int) * ndims"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(int) * ndims"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_array_report_expected_array",
          "args": [
            "ctx",
            "ndims"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "populate_array_report_expected_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2325-2365",
          "snippet": "static void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
            "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
            "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
            "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx->ndims <= 0"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\n\nstatic void\npopulate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)\n{\n\tint\t\t\ti;\n\n\tAssert(ctx->ndims <= 0);\n\n\tif (ndims <= 0)\n\t\tpopulate_array_report_expected_array(ctx, ndims);\n\n\tctx->ndims = ndims;\n\tctx->dims = palloc(sizeof(int) * ndims);\n\tctx->sizes = palloc0(sizeof(int) * ndims);\n\n\tfor (i = 0; i < ndims; i++)\n\t\tctx->dims[i] = -1;\t\t/* dimensions are unknown yet */\n}"
  },
  {
    "function_name": "populate_array_report_expected_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2325-2365",
    "snippet": "static void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);",
      "static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);",
      "static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);",
      "static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data))"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"See the array element %s.\"",
            "indices.data"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"expected JSON array\""
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname))"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&indices",
            "\"[%d]\"",
            "ctx->sizes[i]"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ctx->ndims > 0 && ndim < ctx->ndims"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&indices"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"))"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname))"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,\n\t\t\t\t\t\t int ndim);\nstatic void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);\nstatic void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);\nstatic void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);\n\nstatic void\npopulate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)\n{\n\tif (ndim <= 0)\n\t{\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the value of key \\\"%s\\\".\", ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\")));\n\t}\n\telse\n\t{\n\t\tStringInfoData indices;\n\t\tint\t\t\ti;\n\n\t\tinitStringInfo(&indices);\n\n\t\tAssert(ctx->ndims > 0 && ndim < ctx->ndims);\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tappendStringInfo(&indices, \"[%d]\", ctx->sizes[i]);\n\n\t\tif (ctx->colname)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s of key \\\"%s\\\".\",\n\t\t\t\t\t\t\t indices.data, ctx->colname)));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"expected JSON array\"),\n\t\t\t\t\t errhint(\"See the array element %s.\",\n\t\t\t\t\t\t\t indices.data)));\n\t}\n}"
  },
  {
    "function_name": "json_to_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2317-2322",
    "snippet": "Datum\njson_to_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"json_to_record\",\n\t\t\t\t\t\t\t\t  true, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_record_worker",
          "args": [
            "fcinfo",
            "\"json_to_record\"",
            "true",
            "false"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3214-3338",
          "snippet": "static Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_to_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"json_to_record\",\n\t\t\t\t\t\t\t\t  true, false);\n}"
  },
  {
    "function_name": "json_populate_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2310-2315",
    "snippet": "Datum\njson_populate_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"json_populate_record\",\n\t\t\t\t\t\t\t\t  true, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_record_worker",
          "args": [
            "fcinfo",
            "\"json_populate_record\"",
            "true",
            "true"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3214-3338",
          "snippet": "static Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_populate_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"json_populate_record\",\n\t\t\t\t\t\t\t\t  true, true);\n}"
  },
  {
    "function_name": "jsonb_to_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2303-2308",
    "snippet": "Datum\njsonb_to_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"jsonb_to_record\",\n\t\t\t\t\t\t\t\t  false, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_record_worker",
          "args": [
            "fcinfo",
            "\"jsonb_to_record\"",
            "false",
            "false"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3214-3338",
          "snippet": "static Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_to_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"jsonb_to_record\",\n\t\t\t\t\t\t\t\t  false, false);\n}"
  },
  {
    "function_name": "jsonb_populate_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2296-2301",
    "snippet": "Datum\njsonb_populate_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"jsonb_populate_record\",\n\t\t\t\t\t\t\t\t  false, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_record_worker",
          "args": [
            "fcinfo",
            "\"jsonb_populate_record\"",
            "false",
            "true"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "populate_record_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3214-3338",
          "snippet": "static Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);",
            "static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);",
            "static Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);",
            "static bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);",
            "static Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic Datum populate_recordset_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t\t  bool is_json, bool have_record_arg);\nstatic Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg);\nstatic Datum populate_scalar(ScalarIOData *io, Oid typid, int32 typmod, JsValue *jsv);\nstatic bool JsObjectGetField(JsObject *obj, char *field, JsValue *jsv);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);\nstatic Datum populate_array(ArrayIOData *aio, const char *colname,\n\t\t\t   MemoryContext mcxt, JsValue *jsv);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\npopulate_record_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t   bool is_json, bool have_record_arg)\n{\n\tint\t\t\tjson_arg_num = have_record_arg ? 1 : 0;\n\tJsValue\t\tjsv = {0};\n\tHeapTupleHeader rec;\n\tDatum\t\trettuple;\n\tJsonbValue\tjbv;\n\tMemoryContext fnmcxt = fcinfo->flinfo->fn_mcxt;\n\tPopulateRecordCache *cache = fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * If first time through, identify input/result record type.  Note that\n\t * this stanza looks only at fcinfo context, which can't change during the\n\t * query; so we may not be able to fully resolve a RECORD input type yet.\n\t */\n\tif (!cache)\n\t{\n\t\tfcinfo->flinfo->fn_extra = cache =\n\t\t\tMemoryContextAllocZero(fnmcxt, sizeof(*cache));\n\n\t\tif (have_record_arg)\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_populate_record case: result type will be same as first\n\t\t\t * argument's.\n\t\t\t */\n\t\t\tcache->argtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\t\t\tprepare_column_cache(&cache->c,\n\t\t\t\t\t\t\t\t cache->argtype, -1,\n\t\t\t\t\t\t\t\t fnmcxt, false);\n\t\t\tif (cache->c.typcat != TYPECAT_COMPOSITE &&\n\t\t\t\tcache->c.typcat != TYPECAT_COMPOSITE_DOMAIN)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"first argument of %s must be a row type\",\n\t\t\t\t\t\t\t\tfuncname)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * json{b}_to_record case: result type is specified by calling\n\t\t\t * query.  Here it is syntactically impossible to specify the\n\t\t\t * target type as domain-over-composite.\n\t\t\t */\n\t\t\tTupleDesc\ttupdesc;\n\t\t\tMemoryContext old_cxt;\n\n\t\t\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\t\t\"that cannot accept type record\"),\n\t\t\t\t\t\t errhint(\"Try calling the function in the FROM clause \"\n\t\t\t\t\t\t\t\t \"using a column definition list.\")));\n\n\t\t\tAssert(tupdesc);\n\t\t\tcache->argtype = tupdesc->tdtypeid;\n\n\t\t\t/* Save identified tupdesc */\n\t\t\told_cxt = MemoryContextSwitchTo(fnmcxt);\n\t\t\tcache->c.io.composite.tupdesc = CreateTupleDescCopy(tupdesc);\n\t\t\tcache->c.io.composite.base_typid = tupdesc->tdtypeid;\n\t\t\tcache->c.io.composite.base_typmod = tupdesc->tdtypmod;\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t}\n\t}\n\n\t/* Collect record arg if we have one */\n\tif (have_record_arg && !PG_ARGISNULL(0))\n\t{\n\t\trec = PG_GETARG_HEAPTUPLEHEADER(0);\n\n\t\t/*\n\t\t * When declared arg type is RECORD, identify actual record type from\n\t\t * the tuple itself.  Note the lookup_rowtype_tupdesc call in\n\t\t * update_cached_tupdesc will fail if we're unable to do this.\n\t\t */\n\t\tif (cache->argtype == RECORDOID)\n\t\t{\n\t\t\tcache->c.io.composite.base_typid = HeapTupleHeaderGetTypeId(rec);\n\t\t\tcache->c.io.composite.base_typmod = HeapTupleHeaderGetTypMod(rec);\n\t\t}\n\t}\n\telse\n\t\trec = NULL;\n\n\t/* If no JSON argument, just return the record (if any) unchanged */\n\tif (PG_ARGISNULL(json_arg_num))\n\t{\n\t\tif (rec)\n\t\t\tPG_RETURN_POINTER(rec);\n\t\telse\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tjsv.is_json = is_json;\n\n\tif (is_json)\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(json_arg_num);\n\n\t\tjsv.val.json.str = VARDATA_ANY(json);\n\t\tjsv.val.json.len = VARSIZE_ANY_EXHDR(json);\n\t\tjsv.val.json.type = JSON_TOKEN_INVALID; /* not used in\n\t\t\t\t\t\t\t\t\t\t\t\t * populate_composite() */\n\t}\n\telse\n\t{\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(json_arg_num);\n\n\t\tjsv.val.jsonb = &jbv;\n\n\t\t/* fill binary jsonb value pointing to jb */\n\t\tjbv.type = jbvBinary;\n\t\tjbv.val.binary.data = &jb->root;\n\t\tjbv.val.binary.len = VARSIZE(jb) - VARHDRSZ;\n\t}\n\n\trettuple = populate_composite(&cache->c.io.composite, cache->argtype,\n\t\t\t\t\t\t\t\t  NULL, fnmcxt, rec, &jsv, false);\n\n\tPG_RETURN_DATUM(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_populate_record(PG_FUNCTION_ARGS)\n{\n\treturn populate_record_worker(fcinfo, \"jsonb_populate_record\",\n\t\t\t\t\t\t\t\t  false, true);\n}"
  },
  {
    "function_name": "elements_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2267-2282",
    "snippet": "static void\nelements_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name)));\n\n\t/* supply de-escaped value if required */\n\tif (_state->next_scalar)\n\t\t_state->normalized_scalar = token;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name))"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on a scalar\"",
            "_state->function_name"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nelements_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t_state->function_name)));\n\n\t/* supply de-escaped value if required */\n\tif (_state->next_scalar)\n\t\t_state->normalized_scalar = token;\n}"
  },
  {
    "function_name": "elements_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2254-2265",
    "snippet": "static void\nelements_object_start(void *state)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t_state->function_name)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t_state->function_name))"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on a non-array\"",
            "_state->function_name"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nelements_object_start(void *state)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-array\",\n\t\t\t\t\t\t_state->function_name)));\n}"
  },
  {
    "function_name": "elements_array_element_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2210-2252",
    "snippet": "static void\nelements_array_element_end(void *state, bool isnull)\n{\n\tElementsState *_state = (ElementsState *) state;\n\tMemoryContext old_cxt;\n\tint\t\t\tlen;\n\ttext\t   *val;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[1];\n\tbool\t\tnulls[1] = {false};\n\n\t/* skip over nested objects */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* use the tmp context so we can clean up after each tuple is done */\n\told_cxt = MemoryContextSwitchTo(_state->tmp_cxt);\n\n\tif (isnull && _state->normalize_results)\n\t{\n\t\tnulls[0] = true;\n\t\tvalues[0] = (Datum) NULL;\n\t}\n\telse if (_state->next_scalar)\n\t{\n\t\tvalues[0] = CStringGetTextDatum(_state->normalized_scalar);\n\t\t_state->next_scalar = false;\n\t}\n\telse\n\t{\n\t\tlen = _state->lex->prev_token_terminator - _state->result_start;\n\t\tval = cstring_to_text_with_len(_state->result_start, len);\n\t\tvalues[0] = PointerGetDatum(val);\n\t}\n\n\ttuple = heap_form_tuple(_state->ret_tdesc, values, nulls);\n\n\ttuplestore_puttuple(_state->tuple_store, tuple);\n\n\t/* clean up and switch back */\n\tMemoryContextSwitchTo(old_cxt);\n\tMemoryContextReset(_state->tmp_cxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "_state->tmp_cxt"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "_state->tuple_store",
            "tuple"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "_state->ret_tdesc",
            "values",
            "nulls"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "val"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "_state->result_start",
            "len"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "_state->normalized_scalar"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "_state->tmp_cxt"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nelements_array_element_end(void *state, bool isnull)\n{\n\tElementsState *_state = (ElementsState *) state;\n\tMemoryContext old_cxt;\n\tint\t\t\tlen;\n\ttext\t   *val;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[1];\n\tbool\t\tnulls[1] = {false};\n\n\t/* skip over nested objects */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* use the tmp context so we can clean up after each tuple is done */\n\told_cxt = MemoryContextSwitchTo(_state->tmp_cxt);\n\n\tif (isnull && _state->normalize_results)\n\t{\n\t\tnulls[0] = true;\n\t\tvalues[0] = (Datum) NULL;\n\t}\n\telse if (_state->next_scalar)\n\t{\n\t\tvalues[0] = CStringGetTextDatum(_state->normalized_scalar);\n\t\t_state->next_scalar = false;\n\t}\n\telse\n\t{\n\t\tlen = _state->lex->prev_token_terminator - _state->result_start;\n\t\tval = cstring_to_text_with_len(_state->result_start, len);\n\t\tvalues[0] = PointerGetDatum(val);\n\t}\n\n\ttuple = heap_form_tuple(_state->ret_tdesc, values, nulls);\n\n\ttuplestore_puttuple(_state->tuple_store, tuple);\n\n\t/* clean up and switch back */\n\tMemoryContextSwitchTo(old_cxt);\n\tMemoryContextReset(_state->tmp_cxt);\n}"
  },
  {
    "function_name": "elements_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2190-2208",
    "snippet": "static void\nelements_array_element_start(void *state, bool isnull)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* save a pointer to where the value starts */\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t/*\n\t\t * next_scalar will be reset in the array_element_end handler, and\n\t\t * since we know the value is a scalar there is no danger of it being\n\t\t * on while recursing down the tree.\n\t\t */\n\t\tif (_state->normalize_results && _state->lex->token_type == JSON_TOKEN_STRING)\n\t\t\t_state->next_scalar = true;\n\t\telse\n\t\t\t_state->result_start = _state->lex->token_start;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nelements_array_element_start(void *state, bool isnull)\n{\n\tElementsState *_state = (ElementsState *) state;\n\n\t/* save a pointer to where the value starts */\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t/*\n\t\t * next_scalar will be reset in the array_element_end handler, and\n\t\t * since we know the value is a scalar there is no danger of it being\n\t\t * on while recursing down the tree.\n\t\t */\n\t\tif (_state->normalize_results && _state->lex->token_type == JSON_TOKEN_STRING)\n\t\t\t_state->next_scalar = true;\n\t\telse\n\t\t\t_state->result_start = _state->lex->token_start;\n\t}\n}"
  },
  {
    "function_name": "elements_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2124-2188",
    "snippet": "static Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static void alen_object_start(void *state);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static void each_array_start(void *state);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static void elements_object_start(void *state);",
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "state->tmp_cxt"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"json_array_elements temporary cxt\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsi->allowedModes & SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "state->ret_tdesc"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rsi->econtext->ecxt_per_query_memory"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\"))"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\""
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsi",
            "ReturnSetInfo"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "as_text"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_array_elements_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2118-2122",
    "snippet": "Datum\njson_array_elements_text(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker(fcinfo, \"json_array_elements_text\", true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elements_worker",
          "args": [
            "fcinfo",
            "\"json_array_elements_text\"",
            "true"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "elements_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2124-2188",
          "snippet": "static Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static void alen_object_start(void *state);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static void each_array_start(void *state);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_array_elements_text(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker(fcinfo, \"json_array_elements_text\", true);\n}"
  },
  {
    "function_name": "json_array_elements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "2112-2116",
    "snippet": "Datum\njson_array_elements(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker(fcinfo, \"json_array_elements\", false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elements_worker",
          "args": [
            "fcinfo",
            "\"json_array_elements\"",
            "false"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "elements_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "2124-2188",
          "snippet": "static Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static void alen_object_start(void *state);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static void each_array_start(void *state);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void elements_object_start(void *state);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\nelements_worker(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\n\t/* elements only needs escaped strings when as_text */\n\tJsonLexContext *lex = makeJsonLexContext(json, as_text);\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tElementsState *state;\n\n\tstate = palloc0(sizeof(ElementsState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = elements_object_start;\n\tsem->scalar = elements_scalar;\n\tsem->array_element_start = elements_array_element_start;\n\tsem->array_element_end = elements_array_element_end;\n\n\tstate->function_name = funcname;\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_array_elements(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker(fcinfo, \"json_array_elements\", false);\n}"
  },
  {
    "function_name": "elements_worker_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1988-2110",
    "snippet": "static Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "tmp_cxt"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "tmp_cxt"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "tuple_store",
            "tuple"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "ret_tdesc",
            "values",
            "nulls"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sv"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "jtext->data",
            "jtext->len"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "jtext",
            "&jb->root",
            "0"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "&v"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "val"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmp_cxt"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "skipNested"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"jsonb_array_elements temporary cxt\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsi->allowedModes & SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "ret_tdesc"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rsi->econtext->ecxt_per_query_memory"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\"))"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\""
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsi",
            "ReturnSetInfo"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\"))"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\"))"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "jsonb_array_elements_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1982-1986",
    "snippet": "Datum\njsonb_array_elements_text(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker_jsonb(fcinfo, \"jsonb_array_elements_text\", true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elements_worker_jsonb",
          "args": [
            "fcinfo",
            "\"jsonb_array_elements_text\"",
            "true"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "elements_worker_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1988-2110",
          "snippet": "static Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_array_elements_text(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker_jsonb(fcinfo, \"jsonb_array_elements_text\", true);\n}"
  },
  {
    "function_name": "jsonb_array_elements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1976-1980",
    "snippet": "Datum\njsonb_array_elements(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker_jsonb(fcinfo, \"jsonb_array_elements\", false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elements_worker_jsonb",
          "args": [
            "fcinfo",
            "\"jsonb_array_elements\"",
            "false"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "elements_worker_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1988-2110",
          "snippet": "static Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nelements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot extract elements from an object\")));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t/* it's a simple type, so don't use get_call_result_type() */\n\ttupdesc = rsi->expectedDesc;\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_array_elements temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[1];\n\t\t\tbool\t\tnulls[1] = {false};\n\n\t\t\t/* use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tif (!as_text)\n\t\t\t{\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[0] = PointerGetDatum(val);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[0] = true;\n\t\t\t\t\tvalues[0] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* in text mode scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[0] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_array_elements(PG_FUNCTION_ARGS)\n{\n\treturn elements_worker_jsonb(fcinfo, \"jsonb_array_elements\", false);\n}"
  },
  {
    "function_name": "each_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1952-1966",
    "snippet": "static void\neach_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct a scalar\")));\n\n\t/* supply de-escaped value if required */\n\tif (_state->next_scalar)\n\t\t_state->normalized_scalar = token;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct a scalar\"))"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot deconstruct a scalar\""
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\neach_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct a scalar\")));\n\n\t/* supply de-escaped value if required */\n\tif (_state->next_scalar)\n\t\t_state->normalized_scalar = token;\n}"
  },
  {
    "function_name": "each_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1940-1950",
    "snippet": "static void\neach_array_start(void *state)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct an array as an object\")));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct an array as an object\"))"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot deconstruct an array as an object\""
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\neach_array_start(void *state)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct an array as an object\")));\n}"
  },
  {
    "function_name": "each_object_field_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1894-1938",
    "snippet": "static void\neach_object_field_end(void *state, char *fname, bool isnull)\n{\n\tEachState  *_state = (EachState *) state;\n\tMemoryContext old_cxt;\n\tint\t\t\tlen;\n\ttext\t   *val;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[2];\n\tbool\t\tnulls[2] = {false, false};\n\n\t/* skip over nested objects */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* use the tmp context so we can clean up after each tuple is done */\n\told_cxt = MemoryContextSwitchTo(_state->tmp_cxt);\n\n\tvalues[0] = CStringGetTextDatum(fname);\n\n\tif (isnull && _state->normalize_results)\n\t{\n\t\tnulls[1] = true;\n\t\tvalues[1] = (Datum) 0;\n\t}\n\telse if (_state->next_scalar)\n\t{\n\t\tvalues[1] = CStringGetTextDatum(_state->normalized_scalar);\n\t\t_state->next_scalar = false;\n\t}\n\telse\n\t{\n\t\tlen = _state->lex->prev_token_terminator - _state->result_start;\n\t\tval = cstring_to_text_with_len(_state->result_start, len);\n\t\tvalues[1] = PointerGetDatum(val);\n\t}\n\n\ttuple = heap_form_tuple(_state->ret_tdesc, values, nulls);\n\n\ttuplestore_puttuple(_state->tuple_store, tuple);\n\n\t/* clean up and switch back */\n\tMemoryContextSwitchTo(old_cxt);\n\tMemoryContextReset(_state->tmp_cxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "_state->tmp_cxt"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "_state->tuple_store",
            "tuple"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "_state->ret_tdesc",
            "values",
            "nulls"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "val"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "_state->result_start",
            "len"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "_state->normalized_scalar"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "fname"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "_state->tmp_cxt"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\neach_object_field_end(void *state, char *fname, bool isnull)\n{\n\tEachState  *_state = (EachState *) state;\n\tMemoryContext old_cxt;\n\tint\t\t\tlen;\n\ttext\t   *val;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[2];\n\tbool\t\tnulls[2] = {false, false};\n\n\t/* skip over nested objects */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* use the tmp context so we can clean up after each tuple is done */\n\told_cxt = MemoryContextSwitchTo(_state->tmp_cxt);\n\n\tvalues[0] = CStringGetTextDatum(fname);\n\n\tif (isnull && _state->normalize_results)\n\t{\n\t\tnulls[1] = true;\n\t\tvalues[1] = (Datum) 0;\n\t}\n\telse if (_state->next_scalar)\n\t{\n\t\tvalues[1] = CStringGetTextDatum(_state->normalized_scalar);\n\t\t_state->next_scalar = false;\n\t}\n\telse\n\t{\n\t\tlen = _state->lex->prev_token_terminator - _state->result_start;\n\t\tval = cstring_to_text_with_len(_state->result_start, len);\n\t\tvalues[1] = PointerGetDatum(val);\n\t}\n\n\ttuple = heap_form_tuple(_state->ret_tdesc, values, nulls);\n\n\ttuplestore_puttuple(_state->tuple_store, tuple);\n\n\t/* clean up and switch back */\n\tMemoryContextSwitchTo(old_cxt);\n\tMemoryContextReset(_state->tmp_cxt);\n}"
  },
  {
    "function_name": "each_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1874-1892",
    "snippet": "static void\neach_object_field_start(void *state, char *fname, bool isnull)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* save a pointer to where the value starts */\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t/*\n\t\t * next_scalar will be reset in the object_field_end handler, and\n\t\t * since we know the value is a scalar there is no danger of it being\n\t\t * on while recursing down the tree.\n\t\t */\n\t\tif (_state->normalize_results && _state->lex->token_type == JSON_TOKEN_STRING)\n\t\t\t_state->next_scalar = true;\n\t\telse\n\t\t\t_state->result_start = _state->lex->token_start;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\neach_object_field_start(void *state, char *fname, bool isnull)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* save a pointer to where the value starts */\n\tif (_state->lex->lex_level == 1)\n\t{\n\t\t/*\n\t\t * next_scalar will be reset in the object_field_end handler, and\n\t\t * since we know the value is a scalar there is no danger of it being\n\t\t * on while recursing down the tree.\n\t\t */\n\t\tif (_state->normalize_results && _state->lex->token_type == JSON_TOKEN_STRING)\n\t\t\t_state->next_scalar = true;\n\t\telse\n\t\t\t_state->result_start = _state->lex->token_start;\n\t}\n}"
  },
  {
    "function_name": "each_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1810-1871",
    "snippet": "static Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static void alen_object_start(void *state);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static void each_array_start(void *state);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "state->tmp_cxt"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"json_each temporary cxt\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsi->allowedModes & SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "state->ret_tdesc"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rsi->econtext->ecxt_per_query_memory"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_call_result_type",
          "args": [
            "fcinfo",
            "NULL",
            "&tupdesc"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "210-220",
          "snippet": "TypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\"))"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\""
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsi",
            "ReturnSetInfo"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "each_worker_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1673-1807",
    "snippet": "static Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "tmp_cxt"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "tmp_cxt"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "tuple_store",
            "tuple"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "ret_tdesc",
            "values",
            "nulls"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "val"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "&v"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sv"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "jtext->data",
            "jtext->len"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "jtext",
            "&jb->root",
            "0"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "key"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "r != WJB_DONE"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "skipNested"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmp_cxt"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"jsonb_each temporary cxt\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "old_cxt"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsi->allowedModes & SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "ret_tdesc"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupdesc"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rsi->econtext->ecxt_per_query_memory"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\"))"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\""
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_call_result_type",
          "args": [
            "fcinfo",
            "NULL",
            "&tupdesc"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "210-220",
          "snippet": "TypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\"))"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsi",
            "ReturnSetInfo"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname))"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "jsonb_each_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1667-1671",
    "snippet": "Datum\njsonb_each_text(PG_FUNCTION_ARGS)\n{\n\treturn each_worker_jsonb(fcinfo, \"jsonb_each_text\", true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "each_worker_jsonb",
          "args": [
            "fcinfo",
            "\"jsonb_each_text\"",
            "true"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "each_worker_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1673-1807",
          "snippet": "static Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_each_text(PG_FUNCTION_ARGS)\n{\n\treturn each_worker_jsonb(fcinfo, \"jsonb_each_text\", true);\n}"
  },
  {
    "function_name": "json_each_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1661-1665",
    "snippet": "Datum\njson_each_text(PG_FUNCTION_ARGS)\n{\n\treturn each_worker(fcinfo, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "each_worker",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "each_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1810-1871",
          "snippet": "static Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static void alen_object_start(void *state);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static void each_array_start(void *state);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_each_text(PG_FUNCTION_ARGS)\n{\n\treturn each_worker(fcinfo, true);\n}"
  },
  {
    "function_name": "jsonb_each",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1655-1659",
    "snippet": "Datum\njsonb_each(PG_FUNCTION_ARGS)\n{\n\treturn each_worker_jsonb(fcinfo, \"jsonb_each\", false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "each_worker_jsonb",
          "args": [
            "fcinfo",
            "\"jsonb_each\"",
            "false"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "each_worker_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1673-1807",
          "snippet": "static Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic HTAB *get_json_object_as_hash(char *json, int len, const char *funcname);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\neach_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tReturnSetInfo *rsi;\n\tTuplestorestate *tuple_store;\n\tTupleDesc\ttupdesc;\n\tTupleDesc\tret_tdesc;\n\tMemoryContext old_cxt,\n\t\t\t\ttmp_cxt;\n\tbool\t\tskipNested = false;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a non-object\",\n\t\t\t\t\t\tfuncname)));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\tif (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"function returning record called in context \"\n\t\t\t\t\t\t\"that cannot accept type record\")));\n\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(ret_tdesc);\n\ttuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\ttmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\"jsonb_each temporary cxt\",\n\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t{\n\t\tskipNested = true;\n\n\t\tif (r == WJB_KEY)\n\t\t{\n\t\t\ttext\t   *key;\n\t\t\tHeapTuple\ttuple;\n\t\t\tDatum\t\tvalues[2];\n\t\t\tbool\t\tnulls[2] = {false, false};\n\n\t\t\t/* Use the tmp context so we can clean up after each tuple is done */\n\t\t\told_cxt = MemoryContextSwitchTo(tmp_cxt);\n\n\t\t\tkey = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\n\t\t\t/*\n\t\t\t * The next thing the iterator fetches should be the value, no\n\t\t\t * matter what shape it is.\n\t\t\t */\n\t\t\tr = JsonbIteratorNext(&it, &v, skipNested);\n\t\t\tAssert(r != WJB_DONE);\n\n\t\t\tvalues[0] = PointerGetDatum(key);\n\n\t\t\tif (as_text)\n\t\t\t{\n\t\t\t\tif (v.type == jbvNull)\n\t\t\t\t{\n\t\t\t\t\t/* a json null is an sql null in text mode */\n\t\t\t\t\tnulls[1] = true;\n\t\t\t\t\tvalues[1] = (Datum) NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttext\t   *sv;\n\n\t\t\t\t\tif (v.type == jbvString)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* In text mode, scalar strings should be dequoted */\n\t\t\t\t\t\tsv = cstring_to_text_with_len(v.val.string.val, v.val.string.len);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Turn anything else into a json string */\n\t\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\t\t\t\t\t\tJsonb\t   *jb = JsonbValueToJsonb(&v);\n\n\t\t\t\t\t\t(void) JsonbToCString(jtext, &jb->root, 0);\n\t\t\t\t\t\tsv = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t\t}\n\n\t\t\t\t\tvalues[1] = PointerGetDatum(sv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Not in text mode, just return the Jsonb */\n\t\t\t\tJsonb\t   *val = JsonbValueToJsonb(&v);\n\n\t\t\t\tvalues[1] = PointerGetDatum(val);\n\t\t\t}\n\n\t\t\ttuple = heap_form_tuple(ret_tdesc, values, nulls);\n\n\t\t\ttuplestore_puttuple(tuple_store, tuple);\n\n\t\t\t/* clean up and switch back */\n\t\t\tMemoryContextSwitchTo(old_cxt);\n\t\t\tMemoryContextReset(tmp_cxt);\n\t\t}\n\t}\n\n\tMemoryContextDelete(tmp_cxt);\n\n\trsi->setResult = tuple_store;\n\trsi->setDesc = ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_each(PG_FUNCTION_ARGS)\n{\n\treturn each_worker_jsonb(fcinfo, \"jsonb_each\", false);\n}"
  },
  {
    "function_name": "json_each",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1649-1653",
    "snippet": "Datum\njson_each(PG_FUNCTION_ARGS)\n{\n\treturn each_worker(fcinfo, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "each_worker",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "each_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1810-1871",
          "snippet": "static Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static void alen_object_start(void *state);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static void each_array_start(void *state);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic Datum\neach_worker(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\tReturnSetInfo *rsi;\n\tMemoryContext old_cxt;\n\tTupleDesc\ttupdesc;\n\tEachState  *state;\n\n\tlex = makeJsonLexContext(json, true);\n\tstate = palloc0(sizeof(EachState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\trsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\tif (!rsi || !IsA(rsi, ReturnSetInfo) ||\n\t\t(rsi->allowedModes & SFRM_Materialize) == 0 ||\n\t\trsi->expectedDesc == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that \"\n\t\t\t\t\t\t\"cannot accept a set\")));\n\n\trsi->returnMode = SFRM_Materialize;\n\n\t(void) get_call_result_type(fcinfo, NULL, &tupdesc);\n\n\t/* make these in a sufficiently long-lived memory context */\n\told_cxt = MemoryContextSwitchTo(rsi->econtext->ecxt_per_query_memory);\n\n\tstate->ret_tdesc = CreateTupleDescCopy(tupdesc);\n\tBlessTupleDesc(state->ret_tdesc);\n\tstate->tuple_store =\n\t\ttuplestore_begin_heap(rsi->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\tMemoryContextSwitchTo(old_cxt);\n\n\tsem->semstate = (void *) state;\n\tsem->array_start = each_array_start;\n\tsem->scalar = each_scalar;\n\tsem->object_field_start = each_object_field_start;\n\tsem->object_field_end = each_object_field_end;\n\n\tstate->normalize_results = as_text;\n\tstate->next_scalar = false;\n\tstate->lex = lex;\n\tstate->tmp_cxt = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"json_each temporary cxt\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tpg_parse_json(lex, sem);\n\n\tMemoryContextDelete(state->tmp_cxt);\n\n\trsi->setResult = state->tuple_store;\n\trsi->setDesc = state->ret_tdesc;\n\n\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_each(PG_FUNCTION_ARGS)\n{\n\treturn each_worker(fcinfo, false);\n}"
  },
  {
    "function_name": "alen_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1629-1637",
    "snippet": "static void\nalen_array_element_start(void *state, bool isnull)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* just count up all the level 1 elements */\n\tif (_state->lex->lex_level == 1)\n\t\t_state->count++;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nalen_array_element_start(void *state, bool isnull)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* just count up all the level 1 elements */\n\tif (_state->lex->lex_level == 1)\n\t\t_state->count++;\n}"
  },
  {
    "function_name": "alen_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1617-1627",
    "snippet": "static void\nalen_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\")));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\"))"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot get array length of a scalar\""
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nalen_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\")));\n}"
  },
  {
    "function_name": "alen_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1605-1615",
    "snippet": "static void\nalen_object_start(void *state)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\")));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\"))"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot get array length of a non-array\""
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nalen_object_start(void *state)\n{\n\tAlenState  *_state = (AlenState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\")));\n}"
  },
  {
    "function_name": "jsonb_array_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1583-1598",
    "snippet": "Datum\njsonb_array_length(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\")));\n\n\tPG_RETURN_INT32(JB_ROOT_COUNT(jb));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "JB_ROOT_COUNT(jb)"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\"))"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot get array length of a non-array\""
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\"))"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_array_length(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\n\tif (JB_ROOT_IS_SCALAR(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a scalar\")));\n\telse if (!JB_ROOT_IS_ARRAY(jb))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot get array length of a non-array\")));\n\n\tPG_RETURN_INT32(JB_ROOT_COUNT(jb));\n}"
  },
  {
    "function_name": "json_array_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1555-1581",
    "snippet": "Datum\njson_array_length(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tAlenState  *state;\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\n\tlex = makeJsonLexContext(json, false);\n\tstate = palloc0(sizeof(AlenState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\t/* palloc0 does this for us */\n#if 0\n\tstate->count = 0;\n#endif\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = alen_object_start;\n\tsem->scalar = alen_scalar;\n\tsem->array_element_start = alen_array_element_start;\n\n\tpg_parse_json(lex, sem);\n\n\tPG_RETURN_INT32(state->count);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "state->count"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "false"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njson_array_length(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tAlenState  *state;\n\tJsonLexContext *lex;\n\tJsonSemAction *sem;\n\n\tlex = makeJsonLexContext(json, false);\n\tstate = palloc0(sizeof(AlenState));\n\tsem = palloc0(sizeof(JsonSemAction));\n\n\t/* palloc0 does this for us */\n#if 0\n\tstate->count = 0;\n#endif\n\tstate->lex = lex;\n\n\tsem->semstate = (void *) state;\n\tsem->object_start = alen_object_start;\n\tsem->scalar = alen_scalar;\n\tsem->array_element_start = alen_array_element_start;\n\n\tpg_parse_json(lex, sem);\n\n\tPG_RETURN_INT32(state->count);\n}"
  },
  {
    "function_name": "get_jsonb_path_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1387-1550",
    "snippet": "static Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "res"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res)))"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "NULL",
            "&res->root",
            "VARSIZE(res)"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "res"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "jbvp"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len)"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "jbvp->val.string.val",
            "jbvp->val.string.len"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&tv",
            "true"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "(JsonbContainer *) jbvp->val.binary.data"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getIthJsonbValueFromContainer",
          "args": [
            "container",
            "index"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "getIthJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "418-441",
          "snippet": "JsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\n\nJsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerSize",
          "args": [
            "container"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"not a jsonb array\""
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "container"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "indextext",
            "&endptr",
            "10"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "pathtext[i]"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainerLen",
          "args": [
            "container",
            "JB_FOBJECT",
            "VARDATA(pathtext[i])",
            "VARSIZE(pathtext[i]) - VARHDRSZ"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainerLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3910-3921",
          "snippet": "static JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\n\nstatic JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "pathtext[i]"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "pathtext[i]"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "jb"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb)))"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jb"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb)"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "path",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&pathtext",
            "&pathnulls",
            "&npath"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "path"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}"
  },
  {
    "function_name": "jsonb_extract_path_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1381-1385",
    "snippet": "Datum\njsonb_extract_path_text(PG_FUNCTION_ARGS)\n{\n\treturn get_jsonb_path_all(fcinfo, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_jsonb_path_all",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "get_jsonb_path_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1387-1550",
          "snippet": "static Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_extract_path_text(PG_FUNCTION_ARGS)\n{\n\treturn get_jsonb_path_all(fcinfo, true);\n}"
  },
  {
    "function_name": "jsonb_extract_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1375-1379",
    "snippet": "Datum\njsonb_extract_path(PG_FUNCTION_ARGS)\n{\n\treturn get_jsonb_path_all(fcinfo, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_jsonb_path_all",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "get_jsonb_path_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1387-1550",
          "snippet": "static Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nstatic Datum\nget_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\tJsonb\t   *res;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tint\t\t\ti;\n\tbool\t\thave_object = false,\n\t\t\t\thave_array = false;\n\tJsonbValue *jbvp = NULL;\n\tJsonbValue\ttv;\n\tJsonbContainer *container;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\t/* Identify whether we have object, array, or scalar at top-level */\n\tcontainer = &jb->root;\n\n\tif (JB_ROOT_IS_OBJECT(jb))\n\t\thave_object = true;\n\telse if (JB_ROOT_IS_ARRAY(jb) && !JB_ROOT_IS_SCALAR(jb))\n\t\thave_array = true;\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_ARRAY(jb) && JB_ROOT_IS_SCALAR(jb));\n\t\t/* Extract the scalar value, if it is what we'll return */\n\t\tif (npath <= 0)\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, 0);\n\t}\n\n\t/*\n\t * If the array is empty, return the entire LHS object, on the grounds\n\t * that we should do zero field or element extractions.  For the\n\t * non-scalar case we can just hand back the object without much work. For\n\t * the scalar case, fall through and deal with the value below the loop.\n\t * (This inconsistency arises because there's no easy way to generate a\n\t * JsonbValue directly for root-level containers.)\n\t */\n\tif (npath <= 0 && jbvp == NULL)\n\t{\n\t\tif (as_text)\n\t\t{\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(jb))));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* not text mode - just hand back the jsonb */\n\t\t\tPG_RETURN_JSONB_P(jb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tif (have_object)\n\t\t{\n\t\t\tjbvp = findJsonbValueFromContainerLen(container,\n\t\t\t\t\t\t\t\t\t\t\t\t  JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARDATA(pathtext[i]),\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(pathtext[i]) - VARHDRSZ);\n\t\t}\n\t\telse if (have_array)\n\t\t{\n\t\t\tlong\t\tlindex;\n\t\t\tuint32\t\tindex;\n\t\t\tchar\t   *indextext = TextDatumGetCString(pathtext[i]);\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tlindex = strtol(indextext, &endptr, 10);\n\t\t\tif (endptr == indextext || *endptr != '\\0' || errno != 0 ||\n\t\t\t\tlindex > INT_MAX || lindex < INT_MIN)\n\t\t\t\tPG_RETURN_NULL();\n\n\t\t\tif (lindex >= 0)\n\t\t\t{\n\t\t\t\tindex = (uint32) lindex;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Handle negative subscript */\n\t\t\t\tuint32\t\tnelements;\n\n\t\t\t\t/* Container must be array, but make sure */\n\t\t\t\tif (!JsonContainerIsArray(container))\n\t\t\t\t\telog(ERROR, \"not a jsonb array\");\n\n\t\t\t\tnelements = JsonContainerSize(container);\n\n\t\t\t\tif (-lindex > nelements)\n\t\t\t\t\tPG_RETURN_NULL();\n\t\t\t\telse\n\t\t\t\t\tindex = nelements + lindex;\n\t\t\t}\n\n\t\t\tjbvp = getIthJsonbValueFromContainer(container, index);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* scalar, extraction yields a null */\n\t\t\tPG_RETURN_NULL();\n\t\t}\n\n\t\tif (jbvp == NULL)\n\t\t\tPG_RETURN_NULL();\n\t\telse if (i == npath - 1)\n\t\t\tbreak;\n\n\t\tif (jbvp->type == jbvBinary)\n\t\t{\n\t\t\tJsonbIterator *it = JsonbIteratorInit((JsonbContainer *) jbvp->val.binary.data);\n\t\t\tJsonbIteratorToken r;\n\n\t\t\tr = JsonbIteratorNext(&it, &tv, true);\n\t\t\tcontainer = (JsonbContainer *) jbvp->val.binary.data;\n\t\t\thave_object = r == WJB_BEGIN_OBJECT;\n\t\t\thave_array = r == WJB_BEGIN_ARRAY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thave_object = jbvp->type == jbvObject;\n\t\t\thave_array = jbvp->type == jbvArray;\n\t\t}\n\t}\n\n\tif (as_text)\n\t{\n\t\t/* special-case outputs for string and null values */\n\t\tif (jbvp->type == jbvString)\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(jbvp->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  jbvp->val.string.len));\n\t\tif (jbvp->type == jbvNull)\n\t\t\tPG_RETURN_NULL();\n\t}\n\n\tres = JsonbValueToJsonb(jbvp);\n\n\tif (as_text)\n\t{\n\t\tPG_RETURN_TEXT_P(cstring_to_text(JsonbToCString(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&res->root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVARSIZE(res))));\n\t}\n\telse\n\t{\n\t\t/* not text mode - just hand back the jsonb */\n\t\tPG_RETURN_JSONB_P(res);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njsonb_extract_path(PG_FUNCTION_ARGS)\n{\n\treturn get_jsonb_path_all(fcinfo, false);\n}"
  },
  {
    "function_name": "get_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1334-1373",
    "snippet": "static void\nget_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* Check for whole-object match */\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\tif (_state->normalize_results && tokentype == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/* we want the de-escaped string */\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse if (_state->normalize_results && tokentype == JSON_TOKEN_NULL)\n\t\t{\n\t\t\t_state->tresult = (text *) NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This is a bit hokey: we will suppress whitespace after the\n\t\t\t * scalar token, but not whitespace before it.  Probably not worth\n\t\t\t * doing our own space-skipping to avoid that.\n\t\t\t */\n\t\t\tchar\t   *start = _state->lex->input;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\t}\n\n\tif (_state->next_scalar)\n\t{\n\t\t/* a de-escaped text value is wanted, so supply it */\n\t\t_state->tresult = cstring_to_text(token);\n\t\t/* make sure the next call to get_scalar doesn't overwrite it */\n\t\t_state->next_scalar = false;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "token"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start",
            "len"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nget_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* Check for whole-object match */\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\tif (_state->normalize_results && tokentype == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/* we want the de-escaped string */\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse if (_state->normalize_results && tokentype == JSON_TOKEN_NULL)\n\t\t{\n\t\t\t_state->tresult = (text *) NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * This is a bit hokey: we will suppress whitespace after the\n\t\t\t * scalar token, but not whitespace before it.  Probably not worth\n\t\t\t * doing our own space-skipping to avoid that.\n\t\t\t */\n\t\t\tchar\t   *start = _state->lex->input;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\t}\n\n\tif (_state->next_scalar)\n\t{\n\t\t/* a de-escaped text value is wanted, so supply it */\n\t\t_state->tresult = cstring_to_text(token);\n\t\t/* make sure the next call to get_scalar doesn't overwrite it */\n\t\t_state->next_scalar = false;\n\t}\n}"
  },
  {
    "function_name": "get_array_element_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1292-1332",
    "snippet": "static void\nget_array_element_end(void *state, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_last = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* same tests as in get_array_element_start */\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_indexes != NULL &&\n\t\t_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* done with this element so reset pathok */\n\t\t\t_state->pathok[lex_level] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_last = true;\n\t\t}\n\t}\n\n\t/* same logic as for objects */\n\tif (get_last && _state->result_start != NULL)\n\t{\n\t\tif (isnull && _state->normalize_results)\n\t\t\t_state->tresult = (text *) NULL;\n\t\telse\n\t\t{\n\t\t\tchar\t   *start = _state->result_start;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\n\t\t_state->result_start = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start",
            "len"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nget_array_element_end(void *state, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_last = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* same tests as in get_array_element_start */\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_indexes != NULL &&\n\t\t_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* done with this element so reset pathok */\n\t\t\t_state->pathok[lex_level] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_last = true;\n\t\t}\n\t}\n\n\t/* same logic as for objects */\n\tif (get_last && _state->result_start != NULL)\n\t{\n\t\tif (isnull && _state->normalize_results)\n\t\t\t_state->tresult = (text *) NULL;\n\t\telse\n\t\t{\n\t\t\tchar\t   *start = _state->result_start;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\n\t\t_state->result_start = NULL;\n\t}\n}"
  },
  {
    "function_name": "get_array_element_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1246-1290",
    "snippet": "static void\nget_array_element_start(void *state, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_next = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* Update array element counter */\n\tif (lex_level <= _state->npath)\n\t\t_state->array_cur_index[lex_level - 1]++;\n\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_indexes != NULL &&\n\t\t_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* if not at end of path just mark path ok */\n\t\t\t_state->pathok[lex_level] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_next = true;\n\t\t}\n\t}\n\n\t/* same logic as for objects */\n\tif (get_next)\n\t{\n\t\t_state->tresult = NULL;\n\t\t_state->result_start = NULL;\n\n\t\tif (_state->normalize_results &&\n\t\t\t_state->lex->token_type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_state->result_start = _state->lex->token_start;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nget_array_element_start(void *state, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_next = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* Update array element counter */\n\tif (lex_level <= _state->npath)\n\t\t_state->array_cur_index[lex_level - 1]++;\n\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_indexes != NULL &&\n\t\t_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* if not at end of path just mark path ok */\n\t\t\t_state->pathok[lex_level] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_next = true;\n\t\t}\n\t}\n\n\t/* same logic as for objects */\n\tif (get_next)\n\t{\n\t\t_state->tresult = NULL;\n\t\t_state->result_start = NULL;\n\n\t\tif (_state->normalize_results &&\n\t\t\t_state->lex->token_type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_state->result_start = _state->lex->token_start;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_array_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1230-1244",
    "snippet": "static void\nget_array_end(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/* Special case: return the entire array */\n\t\tchar\t   *start = _state->result_start;\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start",
            "len"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nget_array_end(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/* Special case: return the entire array */\n\t\tchar\t   *start = _state->result_start;\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t}\n}"
  },
  {
    "function_name": "get_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1197-1228",
    "snippet": "static void\nget_array_start(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level < _state->npath)\n\t{\n\t\t/* Initialize counting of elements in this array */\n\t\t_state->array_cur_index[lex_level] = -1;\n\n\t\t/* INT_MIN value is reserved to represent invalid subscript */\n\t\tif (_state->path_indexes[lex_level] < 0 &&\n\t\t\t_state->path_indexes[lex_level] != INT_MIN)\n\t\t{\n\t\t\t/* Negative subscript -- convert to positive-wise subscript */\n\t\t\tint\t\t\tnelements = json_count_array_elements(_state->lex);\n\n\t\t\tif (-_state->path_indexes[lex_level] <= nelements)\n\t\t\t\t_state->path_indexes[lex_level] += nelements;\n\t\t}\n\t}\n\telse if (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/*\n\t\t * Special case: we should match the entire array.  We only need this\n\t\t * at the outermost level because at nested levels the match will have\n\t\t * been started by the outer field or array element callback.\n\t\t */\n\t\t_state->result_start = _state->lex->token_start;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "json_count_array_elements",
          "args": [
            "_state->lex"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "json_count_array_elements",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "366-395",
          "snippet": "int\njson_count_array_elements(JsonLexContext *lex)\n{\n\tJsonLexContext copylex;\n\tint\t\t\tcount;\n\n\t/*\n\t * It's safe to do this with a shallow copy because the lexical routines\n\t * don't scribble on the input. They do scribble on the other pointers\n\t * etc, so doing this with a copy makes that safe.\n\t */\n\tmemcpy(&copylex, lex, sizeof(JsonLexContext));\n\tcopylex.strval = NULL;\t\t/* not interested in values here */\n\tcopylex.lex_level++;\n\n\tcount = 0;\n\tlex_expect(JSON_PARSE_ARRAY_START, &copylex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(&copylex) != JSON_TOKEN_ARRAY_END)\n\t{\n\t\tdo\n\t\t{\n\t\t\tcount++;\n\t\t\tparse_array_element(&copylex, &nullSemAction);\n\t\t}\n\t\twhile (lex_accept(&copylex, JSON_TOKEN_COMMA, NULL));\n\t}\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, &copylex, JSON_TOKEN_ARRAY_END);\n\n\treturn count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);",
            "static JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\nstatic JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};\n\nint\njson_count_array_elements(JsonLexContext *lex)\n{\n\tJsonLexContext copylex;\n\tint\t\t\tcount;\n\n\t/*\n\t * It's safe to do this with a shallow copy because the lexical routines\n\t * don't scribble on the input. They do scribble on the other pointers\n\t * etc, so doing this with a copy makes that safe.\n\t */\n\tmemcpy(&copylex, lex, sizeof(JsonLexContext));\n\tcopylex.strval = NULL;\t\t/* not interested in values here */\n\tcopylex.lex_level++;\n\n\tcount = 0;\n\tlex_expect(JSON_PARSE_ARRAY_START, &copylex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(&copylex) != JSON_TOKEN_ARRAY_END)\n\t{\n\t\tdo\n\t\t{\n\t\t\tcount++;\n\t\t\tparse_array_element(&copylex, &nullSemAction);\n\t\t}\n\t\twhile (lex_accept(&copylex, JSON_TOKEN_COMMA, NULL));\n\t}\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, &copylex, JSON_TOKEN_ARRAY_END);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nget_array_start(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level < _state->npath)\n\t{\n\t\t/* Initialize counting of elements in this array */\n\t\t_state->array_cur_index[lex_level] = -1;\n\n\t\t/* INT_MIN value is reserved to represent invalid subscript */\n\t\tif (_state->path_indexes[lex_level] < 0 &&\n\t\t\t_state->path_indexes[lex_level] != INT_MIN)\n\t\t{\n\t\t\t/* Negative subscript -- convert to positive-wise subscript */\n\t\t\tint\t\t\tnelements = json_count_array_elements(_state->lex);\n\n\t\t\tif (-_state->path_indexes[lex_level] <= nelements)\n\t\t\t\t_state->path_indexes[lex_level] += nelements;\n\t\t}\n\t}\n\telse if (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/*\n\t\t * Special case: we should match the entire array.  We only need this\n\t\t * at the outermost level because at nested levels the match will have\n\t\t * been started by the outer field or array element callback.\n\t\t */\n\t\t_state->result_start = _state->lex->token_start;\n\t}\n}"
  },
  {
    "function_name": "get_object_field_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1148-1195",
    "snippet": "static void\nget_object_field_end(void *state, char *fname, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_last = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* same tests as in get_object_field_start */\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_names != NULL &&\n\t\t_state->path_names[lex_level - 1] != NULL &&\n\t\tstrcmp(fname, _state->path_names[lex_level - 1]) == 0)\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* done with this field so reset pathok */\n\t\t\t_state->pathok[lex_level] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_last = true;\n\t\t}\n\t}\n\n\t/* for as_text scalar case, our work is already done */\n\tif (get_last && _state->result_start != NULL)\n\t{\n\t\t/*\n\t\t * make a text object from the string from the previously noted json\n\t\t * start up to the end of the previous token (the lexer is by now\n\t\t * ahead of us on whatever came after what we're interested in).\n\t\t */\n\t\tif (isnull && _state->normalize_results)\n\t\t\t_state->tresult = (text *) NULL;\n\t\telse\n\t\t{\n\t\t\tchar\t   *start = _state->result_start;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\n\t\t/* this should be unnecessary but let's do it for cleanliness: */\n\t\t_state->result_start = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start",
            "len"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "_state->path_names[lex_level - 1]"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nget_object_field_end(void *state, char *fname, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_last = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\t/* same tests as in get_object_field_start */\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_names != NULL &&\n\t\t_state->path_names[lex_level - 1] != NULL &&\n\t\tstrcmp(fname, _state->path_names[lex_level - 1]) == 0)\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* done with this field so reset pathok */\n\t\t\t_state->pathok[lex_level] = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_last = true;\n\t\t}\n\t}\n\n\t/* for as_text scalar case, our work is already done */\n\tif (get_last && _state->result_start != NULL)\n\t{\n\t\t/*\n\t\t * make a text object from the string from the previously noted json\n\t\t * start up to the end of the previous token (the lexer is by now\n\t\t * ahead of us on whatever came after what we're interested in).\n\t\t */\n\t\tif (isnull && _state->normalize_results)\n\t\t\t_state->tresult = (text *) NULL;\n\t\telse\n\t\t{\n\t\t\tchar\t   *start = _state->result_start;\n\t\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t\t}\n\n\t\t/* this should be unnecessary but let's do it for cleanliness: */\n\t\t_state->result_start = NULL;\n\t}\n}"
  },
  {
    "function_name": "get_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1103-1146",
    "snippet": "static void\nget_object_field_start(void *state, char *fname, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_next = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_names != NULL &&\n\t\t_state->path_names[lex_level - 1] != NULL &&\n\t\tstrcmp(fname, _state->path_names[lex_level - 1]) == 0)\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* if not at end of path just mark path ok */\n\t\t\t_state->pathok[lex_level] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_next = true;\n\t\t}\n\t}\n\n\tif (get_next)\n\t{\n\t\t/* this object overrides any previous matching object */\n\t\t_state->tresult = NULL;\n\t\t_state->result_start = NULL;\n\n\t\tif (_state->normalize_results &&\n\t\t\t_state->lex->token_type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/* for as_text variants, tell get_scalar to set it for us */\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* for non-as_text variants, just note the json starting point */\n\t\t\t_state->result_start = _state->lex->token_start;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "_state->path_names[lex_level - 1]"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nget_object_field_start(void *state, char *fname, bool isnull)\n{\n\tGetState   *_state = (GetState *) state;\n\tbool\t\tget_next = false;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level <= _state->npath &&\n\t\t_state->pathok[lex_level - 1] &&\n\t\t_state->path_names != NULL &&\n\t\t_state->path_names[lex_level - 1] != NULL &&\n\t\tstrcmp(fname, _state->path_names[lex_level - 1]) == 0)\n\t{\n\t\tif (lex_level < _state->npath)\n\t\t{\n\t\t\t/* if not at end of path just mark path ok */\n\t\t\t_state->pathok[lex_level] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* end of path, so we want this value */\n\t\t\tget_next = true;\n\t\t}\n\t}\n\n\tif (get_next)\n\t{\n\t\t/* this object overrides any previous matching object */\n\t\t_state->tresult = NULL;\n\t\t_state->result_start = NULL;\n\n\t\tif (_state->normalize_results &&\n\t\t\t_state->lex->token_type == JSON_TOKEN_STRING)\n\t\t{\n\t\t\t/* for as_text variants, tell get_scalar to set it for us */\n\t\t\t_state->next_scalar = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* for non-as_text variants, just note the json starting point */\n\t\t\t_state->result_start = _state->lex->token_start;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_object_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1087-1101",
    "snippet": "static void\nget_object_end(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/* Special case: return the entire object */\n\t\tchar\t   *start = _state->result_start;\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start",
            "len"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nget_object_end(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/* Special case: return the entire object */\n\t\tchar\t   *start = _state->result_start;\n\t\tint\t\t\tlen = _state->lex->prev_token_terminator - start;\n\n\t\t_state->tresult = cstring_to_text_with_len(start, len);\n\t}\n}"
  },
  {
    "function_name": "get_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1070-1085",
    "snippet": "static void\nget_object_start(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/*\n\t\t * Special case: we should match the entire object.  We only need this\n\t\t * at outermost level because at nested levels the match will have\n\t\t * been started by the outer field or array element callback.\n\t\t */\n\t\t_state->result_start = _state->lex->token_start;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nget_object_start(void *state)\n{\n\tGetState   *_state = (GetState *) state;\n\tint\t\t\tlex_level = _state->lex->lex_level;\n\n\tif (lex_level == 0 && _state->npath == 0)\n\t{\n\t\t/*\n\t\t * Special case: we should match the entire object.  We only need this\n\t\t * at outermost level because at nested levels the match will have\n\t\t * been started by the outer field or array element callback.\n\t\t */\n\t\t_state->result_start = _state->lex->token_start;\n\t}\n}"
  },
  {
    "function_name": "get_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "1014-1068",
    "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(int) * npath"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(bool) * npath"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "npath >= 0"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
  },
  {
    "function_name": "get_path_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "934-995",
    "snippet": "static Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
      "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
      "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
      "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_worker",
          "args": [
            "json",
            "tpath",
            "ipath",
            "npath",
            "as_text"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "get_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1014-1068",
          "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "tpath[i]",
            "&endptr",
            "10"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "pathtext[i]"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!pathnulls[i]"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "npath * sizeof(int)"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "path",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&pathtext",
            "&pathnulls",
            "&npath"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "path"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\n\nstatic Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_extract_path_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "925-929",
    "snippet": "Datum\njson_extract_path_text(PG_FUNCTION_ARGS)\n{\n\treturn get_path_all(fcinfo, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_path_all",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "get_path_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "934-995",
          "snippet": "static Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\n\nstatic Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_extract_path_text(PG_FUNCTION_ARGS)\n{\n\treturn get_path_all(fcinfo, true);\n}"
  },
  {
    "function_name": "json_extract_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "919-923",
    "snippet": "Datum\njson_extract_path(PG_FUNCTION_ARGS)\n{\n\treturn get_path_all(fcinfo, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_path_all",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "get_path_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "934-995",
          "snippet": "static Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker(FunctionCallInfo fcinfo, bool as_text);",
            "static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);",
            "static Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);",
            "static Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum get_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum get_jsonb_path_all(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker(FunctionCallInfo fcinfo, bool as_text);\nstatic Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t  bool as_text);\nstatic Datum elements_worker(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\tbool as_text);\nstatic Datum elements_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname,\n\t\t\t\t\t  bool as_text);\n\nstatic Datum\nget_path_all(FunctionCallInfo fcinfo, bool as_text)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tArrayType  *path = PG_GETARG_ARRAYTYPE_P(1);\n\ttext\t   *result;\n\tDatum\t   *pathtext;\n\tbool\t   *pathnulls;\n\tint\t\t\tnpath;\n\tchar\t  **tpath;\n\tint\t\t   *ipath;\n\tint\t\t\ti;\n\n\t/*\n\t * If the array contains any null elements, return NULL, on the grounds\n\t * that you'd have gotten NULL if any RHS value were NULL in a nested\n\t * series of applications of the -> operator.  (Note: because we also\n\t * return NULL for error cases such as no-such-field, this is true\n\t * regardless of the contents of the rest of the array.)\n\t */\n\tif (array_contains_nulls(path))\n\t\tPG_RETURN_NULL();\n\n\tdeconstruct_array(path, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &pathtext, &pathnulls, &npath);\n\n\ttpath = palloc(npath * sizeof(char *));\n\tipath = palloc(npath * sizeof(int));\n\n\tfor (i = 0; i < npath; i++)\n\t{\n\t\tAssert(!pathnulls[i]);\n\t\ttpath[i] = TextDatumGetCString(pathtext[i]);\n\n\t\t/*\n\t\t * we have no idea at this stage what structure the document is so\n\t\t * just convert anything in the path that we can to an integer and set\n\t\t * all the other integers to INT_MIN which will never match.\n\t\t */\n\t\tif (*tpath[i] != '\\0')\n\t\t{\n\t\t\tlong\t\tind;\n\t\t\tchar\t   *endptr;\n\n\t\t\terrno = 0;\n\t\t\tind = strtol(tpath[i], &endptr, 10);\n\t\t\tif (*endptr == '\\0' && errno == 0 && ind <= INT_MAX && ind >= INT_MIN)\n\t\t\t\tipath[i] = (int) ind;\n\t\t\telse\n\t\t\t\tipath[i] = INT_MIN;\n\t\t}\n\t\telse\n\t\t\tipath[i] = INT_MIN;\n\t}\n\n\tresult = get_worker(json, tpath, ipath, npath, as_text);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_extract_path(PG_FUNCTION_ARGS)\n{\n\treturn get_path_all(fcinfo, false);\n}"
  },
  {
    "function_name": "jsonb_array_element_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "860-917",
    "snippet": "Datum\njsonb_array_element_text(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_ARRAY(jb))\n\t\tPG_RETURN_NULL();\n\n\t/* Handle negative subscript */\n\tif (element < 0)\n\t{\n\t\tuint32\t\tnelements = JB_ROOT_COUNT(jb);\n\n\t\tif (-element > nelements)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\telement += nelements;\n\t}\n\n\tv = getIthJsonbValueFromContainer(&jb->root, element);\n\tif (v != NULL)\n\t{\n\t\ttext\t   *result = NULL;\n\n\t\tswitch (v->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = cstring_to_text(v->val.boolean ? \"true\" : \"false\");\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = cstring_to_text_with_len(v->val.string.val, v->val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = cstring_to_text(DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))));\n\t\t\t\tbreak;\n\t\t\tcase jbvBinary:\n\t\t\t\t{\n\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\n\t\t\t\t\t(void) JsonbToCString(jtext, v->val.binary.data, -1);\n\t\t\t\t\tresult = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) v->type);\n\t\t}\n\n\t\tif (result)\n\t\t\tPG_RETURN_TEXT_P(result);\n\t}\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized jsonb type: %d\"",
            "(int) v->type"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "jtext->data",
            "jtext->len"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "jtext",
            "v->val.binary.data",
            "-1"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric)))"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "PointerGetDatum(v->val.numeric)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "v->val.numeric"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getIthJsonbValueFromContainer",
          "args": [
            "&jb->root",
            "element"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "getIthJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "418-441",
          "snippet": "JsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\n\nJsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_array_element_text(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_ARRAY(jb))\n\t\tPG_RETURN_NULL();\n\n\t/* Handle negative subscript */\n\tif (element < 0)\n\t{\n\t\tuint32\t\tnelements = JB_ROOT_COUNT(jb);\n\n\t\tif (-element > nelements)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\telement += nelements;\n\t}\n\n\tv = getIthJsonbValueFromContainer(&jb->root, element);\n\tif (v != NULL)\n\t{\n\t\ttext\t   *result = NULL;\n\n\t\tswitch (v->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = cstring_to_text(v->val.boolean ? \"true\" : \"false\");\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = cstring_to_text_with_len(v->val.string.val, v->val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = cstring_to_text(DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))));\n\t\t\t\tbreak;\n\t\t\tcase jbvBinary:\n\t\t\t\t{\n\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\n\t\t\t\t\t(void) JsonbToCString(jtext, v->val.binary.data, -1);\n\t\t\t\t\tresult = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) v->type);\n\t\t}\n\n\t\tif (result)\n\t\t\tPG_RETURN_TEXT_P(result);\n\t}\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_array_element_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "845-858",
    "snippet": "Datum\njson_array_element_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\n\tresult = get_worker(json, NULL, &element, 1, true);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_worker",
          "args": [
            "json",
            "NULL",
            "&element",
            "1",
            "true"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "get_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1014-1068",
          "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_array_element_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\n\tresult = get_worker(json, NULL, &element, 1, true);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "jsonb_array_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "817-843",
    "snippet": "Datum\njsonb_array_element(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_ARRAY(jb))\n\t\tPG_RETURN_NULL();\n\n\t/* Handle negative subscript */\n\tif (element < 0)\n\t{\n\t\tuint32\t\tnelements = JB_ROOT_COUNT(jb);\n\n\t\tif (-element > nelements)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\telement += nelements;\n\t}\n\n\tv = getIthJsonbValueFromContainer(&jb->root, element);\n\tif (v != NULL)\n\t\tPG_RETURN_JSONB_P(JsonbValueToJsonb(v));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(v)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "v"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getIthJsonbValueFromContainer",
          "args": [
            "&jb->root",
            "element"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "getIthJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "418-441",
          "snippet": "JsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\n\nJsonbValue *\ngetIthJsonbValueFromContainer(JsonbContainer *container, uint32 i)\n{\n\tJsonbValue *result;\n\tchar\t   *base_addr;\n\tuint32\t\tnelements;\n\n\tif (!JsonContainerIsArray(container))\n\t\telog(ERROR, \"not a jsonb array\");\n\n\tnelements = JsonContainerSize(container);\n\tbase_addr = (char *) &container->children[nelements];\n\n\tif (i >= nelements)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tfillJsonbValue(container, i, base_addr,\n\t\t\t\t   getJsonbOffset(container, i),\n\t\t\t\t   result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_array_element(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_ARRAY(jb))\n\t\tPG_RETURN_NULL();\n\n\t/* Handle negative subscript */\n\tif (element < 0)\n\t{\n\t\tuint32\t\tnelements = JB_ROOT_COUNT(jb);\n\n\t\tif (-element > nelements)\n\t\t\tPG_RETURN_NULL();\n\t\telse\n\t\t\telement += nelements;\n\t}\n\n\tv = getIthJsonbValueFromContainer(&jb->root, element);\n\tif (v != NULL)\n\t\tPG_RETURN_JSONB_P(JsonbValueToJsonb(v));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_array_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "802-815",
    "snippet": "Datum\njson_array_element(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\n\tresult = get_worker(json, NULL, &element, 1, false);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_worker",
          "args": [
            "json",
            "NULL",
            "&element",
            "1",
            "false"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "get_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1014-1068",
          "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_array_element(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\n\tresult = get_worker(json, NULL, &element, 1, false);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "jsonb_object_field_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "751-800",
    "snippet": "Datum\njsonb_object_field_text(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tPG_RETURN_NULL();\n\n\tv = findJsonbValueFromContainerLen(&jb->root, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t   VARDATA_ANY(key),\n\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(key));\n\n\tif (v != NULL)\n\t{\n\t\ttext\t   *result = NULL;\n\n\t\tswitch (v->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = cstring_to_text(v->val.boolean ? \"true\" : \"false\");\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = cstring_to_text_with_len(v->val.string.val, v->val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = cstring_to_text(DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))));\n\t\t\t\tbreak;\n\t\t\tcase jbvBinary:\n\t\t\t\t{\n\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\n\t\t\t\t\t(void) JsonbToCString(jtext, v->val.binary.data, -1);\n\t\t\t\t\tresult = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) v->type);\n\t\t}\n\n\t\tif (result)\n\t\t\tPG_RETURN_TEXT_P(result);\n\t}\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized jsonb type: %d\"",
            "(int) v->type"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "jtext->data",
            "jtext->len"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "jtext",
            "v->val.binary.data",
            "-1"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric)))"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "PointerGetDatum(v->val.numeric)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "v->val.numeric"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainerLen",
          "args": [
            "&jb->root",
            "JB_FOBJECT",
            "VARDATA_ANY(key)",
            "VARSIZE_ANY_EXHDR(key)"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainerLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3910-3921",
          "snippet": "static JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\n\nstatic JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "key"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_object_field_text(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tPG_RETURN_NULL();\n\n\tv = findJsonbValueFromContainerLen(&jb->root, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t   VARDATA_ANY(key),\n\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(key));\n\n\tif (v != NULL)\n\t{\n\t\ttext\t   *result = NULL;\n\n\t\tswitch (v->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = cstring_to_text(v->val.boolean ? \"true\" : \"false\");\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = cstring_to_text_with_len(v->val.string.val, v->val.string.len);\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = cstring_to_text(DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(v->val.numeric))));\n\t\t\t\tbreak;\n\t\t\tcase jbvBinary:\n\t\t\t\t{\n\t\t\t\t\tStringInfo\tjtext = makeStringInfo();\n\n\t\t\t\t\t(void) JsonbToCString(jtext, v->val.binary.data, -1);\n\t\t\t\t\tresult = cstring_to_text_with_len(jtext->data, jtext->len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized jsonb type: %d\", (int) v->type);\n\t\t}\n\n\t\tif (result)\n\t\t\tPG_RETURN_TEXT_P(result);\n\t}\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_object_field_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "735-749",
    "snippet": "Datum\njson_object_field_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fname = PG_GETARG_TEXT_PP(1);\n\tchar\t   *fnamestr = text_to_cstring(fname);\n\ttext\t   *result;\n\n\tresult = get_worker(json, &fnamestr, NULL, 1, true);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_worker",
          "args": [
            "json",
            "&fnamestr",
            "NULL",
            "1",
            "true"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "get_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1014-1068",
          "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "fname"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_object_field_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fname = PG_GETARG_TEXT_PP(1);\n\tchar\t   *fnamestr = text_to_cstring(fname);\n\ttext\t   *result;\n\n\tresult = get_worker(json, &fnamestr, NULL, 1, true);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "jsonb_object_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "715-733",
    "snippet": "Datum\njsonb_object_field(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tPG_RETURN_NULL();\n\n\tv = findJsonbValueFromContainerLen(&jb->root, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t   VARDATA_ANY(key),\n\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(key));\n\n\tif (v != NULL)\n\t\tPG_RETURN_JSONB_P(JsonbValueToJsonb(v));\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_JSONB_P",
          "args": [
            "JsonbValueToJsonb(v)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "v"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainerLen",
          "args": [
            "&jb->root",
            "JB_FOBJECT",
            "VARDATA_ANY(key)",
            "VARSIZE_ANY_EXHDR(key)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainerLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "3910-3921",
          "snippet": "static JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
            "static JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *findJsonbValueFromContainerLen(JsonbContainer *container,\n\t\t\t\t\t\t\t   uint32 flags,\n\t\t\t\t\t\t\t   char *key,\n\t\t\t\t\t\t\t   uint32 keylen);\n\nstatic JsonbValue *\nfindJsonbValueFromContainerLen(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\t   char *key, uint32 keylen)\n{\n\tJsonbValue\tk;\n\n\tk.type = jbvString;\n\tk.val.string.val = key;\n\tk.val.string.len = keylen;\n\n\treturn findJsonbValueFromContainer(container, flags, &k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "key"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "jb"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\n\nDatum\njsonb_object_field(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue *v;\n\n\tif (!JB_ROOT_IS_OBJECT(jb))\n\t\tPG_RETURN_NULL();\n\n\tv = findJsonbValueFromContainerLen(&jb->root, JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t   VARDATA_ANY(key),\n\t\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(key));\n\n\tif (v != NULL)\n\t\tPG_RETURN_JSONB_P(JsonbValueToJsonb(v));\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "json_object_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "699-713",
    "snippet": "Datum\njson_object_field(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fname = PG_GETARG_TEXT_PP(1);\n\tchar\t   *fnamestr = text_to_cstring(fname);\n\ttext\t   *result;\n\n\tresult = get_worker(json, &fnamestr, NULL, 1, false);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_worker",
          "args": [
            "json",
            "&fnamestr",
            "NULL",
            "1",
            "false"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "get_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
          "lines": "1014-1068",
          "snippet": "static text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void okeys_array_start(void *state);",
            "static void get_object_start(void *state);",
            "static void get_object_end(void *state);",
            "static void get_array_start(void *state);",
            "static void get_array_end(void *state);",
            "static text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);",
            "static void alen_object_start(void *state);",
            "static void each_array_start(void *state);",
            "static void elements_object_start(void *state);",
            "static void hash_array_start(void *state);",
            "static void populate_recordset_object_start(void *state);",
            "static void populate_recordset_object_end(void *state);",
            "static void populate_recordset_array_start(void *state);",
            "static void sn_object_start(void *state);",
            "static void sn_object_end(void *state);",
            "static void sn_array_start(void *state);",
            "static void sn_array_end(void *state);",
            "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
            "static void transform_string_values_object_start(void *state);",
            "static void transform_string_values_object_end(void *state);",
            "static void transform_string_values_array_start(void *state);",
            "static void transform_string_values_array_end(void *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic text *get_worker(text *json, char **tpath, int *ipath, int npath,\n\t\t   bool normalize_results);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic text *\nget_worker(text *json,\n\t\t   char **tpath,\n\t\t   int *ipath,\n\t\t   int npath,\n\t\t   bool normalize_results)\n{\n\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\tJsonSemAction *sem = palloc0(sizeof(JsonSemAction));\n\tGetState   *state = palloc0(sizeof(GetState));\n\n\tAssert(npath >= 0);\n\n\tstate->lex = lex;\n\t/* is it \"_as_text\" variant? */\n\tstate->normalize_results = normalize_results;\n\tstate->npath = npath;\n\tstate->path_names = tpath;\n\tstate->path_indexes = ipath;\n\tstate->pathok = palloc0(sizeof(bool) * npath);\n\tstate->array_cur_index = palloc(sizeof(int) * npath);\n\n\tif (npath > 0)\n\t\tstate->pathok[0] = true;\n\n\tsem->semstate = (void *) state;\n\n\t/*\n\t * Not all variants need all the semantic routines. Only set the ones that\n\t * are actually needed for maximum efficiency.\n\t */\n\tsem->scalar = get_scalar;\n\tif (npath == 0)\n\t{\n\t\tsem->object_start = get_object_start;\n\t\tsem->object_end = get_object_end;\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_end = get_array_end;\n\t}\n\tif (tpath != NULL)\n\t{\n\t\tsem->object_field_start = get_object_field_start;\n\t\tsem->object_field_end = get_object_field_end;\n\t}\n\tif (ipath != NULL)\n\t{\n\t\tsem->array_start = get_array_start;\n\t\tsem->array_element_start = get_array_element_start;\n\t\tsem->array_element_end = get_array_element_end;\n\t}\n\n\tpg_parse_json(lex, sem);\n\n\treturn state->tresult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "fname"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\njson_object_field(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fname = PG_GETARG_TEXT_PP(1);\n\tchar\t   *fnamestr = text_to_cstring(fname);\n\ttext\t   *result;\n\n\tresult = get_worker(json, &fnamestr, NULL, 1, false);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "okeys_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "679-690",
    "snippet": "static void\nokeys_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* top level must be a json object */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\"json_object_keys\")));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void okeys_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void alen_object_start(void *state);",
      "static void alen_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void each_array_start(void *state);",
      "static void each_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void elements_object_start(void *state);",
      "static void elements_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);",
      "static void hash_array_start(void *state);",
      "static void hash_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\"json_object_keys\"))"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on a scalar\"",
            "\"json_object_keys\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void okeys_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void alen_object_start(void *state);\nstatic void alen_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void each_array_start(void *state);\nstatic void each_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void elements_object_start(void *state);\nstatic void elements_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);\nstatic void hash_array_start(void *state);\nstatic void hash_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_scalar(void *state, char *token, JsonTokenType tokentype);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_scalar(void *state, char *token, JsonTokenType tokentype);\n\nstatic void\nokeys_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* top level must be a json object */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\"json_object_keys\")));\n}"
  },
  {
    "function_name": "okeys_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "666-677",
    "snippet": "static void\nokeys_array_start(void *state)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* top level must be a json object */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\"json_object_keys\")));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\"json_object_keys\"))"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on an array\"",
            "\"json_object_keys\""
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nstatic void\nokeys_array_start(void *state)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* top level must be a json object */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\"json_object_keys\")));\n}"
  },
  {
    "function_name": "okeys_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "645-664",
    "snippet": "static void\nokeys_object_field_start(void *state, char *fname, bool isnull)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* only collecting keys for the top level object */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* enlarge result array if necessary */\n\tif (_state->result_count >= _state->result_size)\n\t{\n\t\t_state->result_size *= 2;\n\t\t_state->result = (char **)\n\t\t\trepalloc(_state->result, sizeof(char *) * _state->result_size);\n\t}\n\n\t/* save a copy of the field name */\n\t_state->result[_state->result_count++] = pstrdup(fname);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_object_field_start(void *state, char *fname, bool isnull);",
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_object_field_start(void *state, char *fname, bool isnull);",
      "static void get_object_field_end(void *state, char *fname, bool isnull);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void get_array_element_start(void *state, bool isnull);",
      "static void get_array_element_end(void *state, bool isnull);",
      "static void alen_object_start(void *state);",
      "static void alen_array_element_start(void *state, bool isnull);",
      "static void each_object_field_start(void *state, char *fname, bool isnull);",
      "static void each_object_field_end(void *state, char *fname, bool isnull);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void elements_array_element_start(void *state, bool isnull);",
      "static void elements_array_element_end(void *state, bool isnull);",
      "static void populate_array_object_start(void *_state);",
      "static void populate_array_array_end(void *_state);",
      "static void populate_array_element_start(void *_state, bool isnull);",
      "static void populate_array_element_end(void *_state, bool isnull);",
      "static void hash_object_field_start(void *state, char *fname, bool isnull);",
      "static void hash_object_field_end(void *state, char *fname, bool isnull);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_field_start(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_field_end(void *state, char *fname, bool isnull);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void populate_recordset_array_element_start(void *state, bool isnull);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void sn_object_field_start(void *state, char *fname, bool isnull);",
      "static void sn_array_element_start(void *state, bool isnull);",
      "static Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);",
      "static Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);",
      "static Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void iterate_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);",
      "static void transform_string_values_object_field_start(void *state, char *fname, bool isnull);",
      "static void transform_string_values_array_element_start(void *state, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "fname"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "_state->result",
            "sizeof(char *) * _state->result_size"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_object_field_start(void *state, char *fname, bool isnull);\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_object_field_start(void *state, char *fname, bool isnull);\nstatic void get_object_field_end(void *state, char *fname, bool isnull);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void get_array_element_start(void *state, bool isnull);\nstatic void get_array_element_end(void *state, bool isnull);\nstatic void alen_object_start(void *state);\nstatic void alen_array_element_start(void *state, bool isnull);\nstatic void each_object_field_start(void *state, char *fname, bool isnull);\nstatic void each_object_field_end(void *state, char *fname, bool isnull);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void elements_array_element_start(void *state, bool isnull);\nstatic void elements_array_element_end(void *state, bool isnull);\nstatic void populate_array_object_start(void *_state);\nstatic void populate_array_array_end(void *_state);\nstatic void populate_array_element_start(void *_state, bool isnull);\nstatic void populate_array_element_end(void *_state, bool isnull);\nstatic void hash_object_field_start(void *state, char *fname, bool isnull);\nstatic void hash_object_field_end(void *state, char *fname, bool isnull);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_field_start(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_field_end(void *state, char *fname, bool isnull);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void populate_recordset_array_element_start(void *state, bool isnull);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void sn_object_field_start(void *state, char *fname, bool isnull);\nstatic void sn_array_element_start(void *state, bool isnull);\nstatic Datum populate_composite(CompositeIOData *io, Oid typid,\n\t\t\t\t   const char *colname, MemoryContext mcxt,\n\t\t\t\t   HeapTupleHeader defaultval, JsValue *jsv, bool isnull);\nstatic Datum populate_record_field(ColumnIOData *col, Oid typid, int32 typmod,\n\t\t\t\t\t  const char *colname, MemoryContext mcxt, Datum defaultval,\n\t\t\t\t\t  JsValue *jsv, bool *isnull);\nstatic Datum populate_domain(DomainIOData *io, Oid typid, const char *colname,\n\t\t\t\tMemoryContext mcxt, JsValue *jsv, bool isnull);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void iterate_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\nstatic void transform_string_values_object_field_start(void *state, char *fname, bool isnull);\nstatic void transform_string_values_array_element_start(void *state, bool isnull);\n\nstatic void\nokeys_object_field_start(void *state, char *fname, bool isnull)\n{\n\tOkeysState *_state = (OkeysState *) state;\n\n\t/* only collecting keys for the top level object */\n\tif (_state->lex->lex_level != 1)\n\t\treturn;\n\n\t/* enlarge result array if necessary */\n\tif (_state->result_count >= _state->result_size)\n\t{\n\t\t_state->result_size *= 2;\n\t\t_state->result = (char **)\n\t\t\trepalloc(_state->result, sizeof(char *) * _state->result_size);\n\t}\n\n\t/* save a copy of the field name */\n\t_state->result[_state->result_count++] = pstrdup(fname);\n}"
  },
  {
    "function_name": "json_object_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "582-643",
    "snippet": "Datum\njson_object_keys(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tOkeysState *state;\n\tint\t\t\ti;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\t\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\t\tJsonSemAction *sem;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tstate = palloc(sizeof(OkeysState));\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tstate->lex = lex;\n\t\tstate->result_size = 256;\n\t\tstate->result_count = 0;\n\t\tstate->sent_count = 0;\n\t\tstate->result = palloc(256 * sizeof(char *));\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = okeys_array_start;\n\t\tsem->scalar = okeys_scalar;\n\t\tsem->object_field_start = okeys_object_field_start;\n\t\t/* remainder are all NULL, courtesy of palloc0 above */\n\n\t\tpg_parse_json(lex, sem);\n\t\t/* keys are now in state->result */\n\n\t\tpfree(lex->strval->data);\n\t\tpfree(lex->strval);\n\t\tpfree(lex);\n\t\tpfree(sem);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) state;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tstate = (OkeysState *) funcctx->user_fctx;\n\n\tif (state->sent_count < state->result_count)\n\t{\n\t\tchar\t   *nxt = state->result[state->sent_count++];\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));\n\t}\n\n\t/* cleanup to reduce or eliminate memory leaks */\n\tfor (i = 0; i < state->result_count; i++)\n\t\tpfree(state->result[i]);\n\tpfree(state->result);\n\tpfree(state);\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "CStringGetTextDatum(nxt)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "nxt"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "sem"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "256 * sizeof(char *)"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonSemAction)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njson_object_keys(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tOkeysState *state;\n\tint\t\t\ti;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ttext\t   *json = PG_GETARG_TEXT_PP(0);\n\t\tJsonLexContext *lex = makeJsonLexContext(json, true);\n\t\tJsonSemAction *sem;\n\t\tMemoryContext oldcontext;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tstate = palloc(sizeof(OkeysState));\n\t\tsem = palloc0(sizeof(JsonSemAction));\n\n\t\tstate->lex = lex;\n\t\tstate->result_size = 256;\n\t\tstate->result_count = 0;\n\t\tstate->sent_count = 0;\n\t\tstate->result = palloc(256 * sizeof(char *));\n\n\t\tsem->semstate = (void *) state;\n\t\tsem->array_start = okeys_array_start;\n\t\tsem->scalar = okeys_scalar;\n\t\tsem->object_field_start = okeys_object_field_start;\n\t\t/* remainder are all NULL, courtesy of palloc0 above */\n\n\t\tpg_parse_json(lex, sem);\n\t\t/* keys are now in state->result */\n\n\t\tpfree(lex->strval->data);\n\t\tpfree(lex->strval);\n\t\tpfree(lex);\n\t\tpfree(sem);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) state;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tstate = (OkeysState *) funcctx->user_fctx;\n\n\tif (state->sent_count < state->result_count)\n\t{\n\t\tchar\t   *nxt = state->result[state->sent_count++];\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));\n\t}\n\n\t/* cleanup to reduce or eliminate memory leaks */\n\tfor (i = 0; i < state->result_count; i++)\n\t\tpfree(state->result[i]);\n\tpfree(state->result);\n\tpfree(state);\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "jsonb_object_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonfuncs.c",
    "lines": "504-579",
    "snippet": "Datum\njsonb_object_keys(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tOkeysState *state;\n\tint\t\t\ti;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\")));\n\t\telse if (JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\")));\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tstate = palloc(sizeof(OkeysState));\n\n\t\tstate->result_size = JB_ROOT_COUNT(jb);\n\t\tstate->result_count = 0;\n\t\tstate->sent_count = 0;\n\t\tstate->result = palloc(state->result_size * sizeof(char *));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_KEY)\n\t\t\t{\n\t\t\t\tchar\t   *cstr;\n\n\t\t\t\tcstr = palloc(v.val.string.len + 1 * sizeof(char));\n\t\t\t\tmemcpy(cstr, v.val.string.val, v.val.string.len);\n\t\t\t\tcstr[v.val.string.len] = '\\0';\n\t\t\t\tstate->result[state->result_count++] = cstr;\n\t\t\t}\n\t\t}\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) state;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tstate = (OkeysState *) funcctx->user_fctx;\n\n\tif (state->sent_count < state->result_count)\n\t{\n\t\tchar\t   *nxt = state->result[state->sent_count++];\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));\n\t}\n\n\t/* cleanup to reduce or eliminate memory leaks */\n\tfor (i = 0; i < state->result_count; i++)\n\t\tpfree(state->result[i]);\n\tpfree(state->result);\n\tpfree(state);\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"fmgr.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void okeys_array_start(void *state);",
      "static void get_object_start(void *state);",
      "static void get_object_end(void *state);",
      "static void get_array_start(void *state);",
      "static void get_array_end(void *state);",
      "static void alen_object_start(void *state);",
      "static void each_array_start(void *state);",
      "static void elements_object_start(void *state);",
      "static void hash_array_start(void *state);",
      "static void populate_recordset_object_start(void *state);",
      "static void populate_recordset_object_end(void *state);",
      "static void populate_recordset_array_start(void *state);",
      "static void sn_object_start(void *state);",
      "static void sn_object_end(void *state);",
      "static void sn_array_start(void *state);",
      "static void sn_array_end(void *state);",
      "static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);",
      "static JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);",
      "static void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);",
      "static void transform_string_values_object_start(void *state);",
      "static void transform_string_values_object_end(void *state);",
      "static void transform_string_values_array_start(void *state);",
      "static void transform_string_values_array_end(void *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "CStringGetTextDatum(nxt)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "nxt"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cstr",
            "v.val.string.val",
            "v.val.string.len"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "v.val.string.len + 1 * sizeof(char)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "skipNested"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\"))"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot call %s on an array\"",
            "\"jsonb_object_keys\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "jb"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\"))"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jb"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void okeys_array_start(void *state);\nstatic void get_object_start(void *state);\nstatic void get_object_end(void *state);\nstatic void get_array_start(void *state);\nstatic void get_array_end(void *state);\nstatic void alen_object_start(void *state);\nstatic void each_array_start(void *state);\nstatic void elements_object_start(void *state);\nstatic void hash_array_start(void *state);\nstatic void populate_recordset_object_start(void *state);\nstatic void populate_recordset_object_end(void *state);\nstatic void populate_recordset_array_start(void *state);\nstatic void sn_object_start(void *state);\nstatic void sn_object_end(void *state);\nstatic void sn_array_start(void *state);\nstatic void sn_array_end(void *state);\nstatic void populate_array_json(PopulateArrayContext *ctx, char *json, int len);\nstatic JsonbValue *IteratorConcat(JsonbIterator **it1, JsonbIterator **it2,\n\t\t\t   JsonbParseState **state);\nstatic void addJsonbToParseState(JsonbParseState **jbps, Jsonb *jb);\nstatic void transform_string_values_object_start(void *state);\nstatic void transform_string_values_object_end(void *state);\nstatic void transform_string_values_array_start(void *state);\nstatic void transform_string_values_array_end(void *state);\n\nDatum\njsonb_object_keys(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tOkeysState *state;\n\tint\t\t\ti;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\t\tbool\t\tskipNested = false;\n\t\tJsonbIterator *it;\n\t\tJsonbValue\tv;\n\t\tJsonbIteratorToken r;\n\n\t\tif (JB_ROOT_IS_SCALAR(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on a scalar\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\")));\n\t\telse if (JB_ROOT_IS_ARRAY(jb))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"cannot call %s on an array\",\n\t\t\t\t\t\t\t\"jsonb_object_keys\")));\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\tstate = palloc(sizeof(OkeysState));\n\n\t\tstate->result_size = JB_ROOT_COUNT(jb);\n\t\tstate->result_count = 0;\n\t\tstate->sent_count = 0;\n\t\tstate->result = palloc(state->result_size * sizeof(char *));\n\n\t\tit = JsonbIteratorInit(&jb->root);\n\n\t\twhile ((r = JsonbIteratorNext(&it, &v, skipNested)) != WJB_DONE)\n\t\t{\n\t\t\tskipNested = true;\n\n\t\t\tif (r == WJB_KEY)\n\t\t\t{\n\t\t\t\tchar\t   *cstr;\n\n\t\t\t\tcstr = palloc(v.val.string.len + 1 * sizeof(char));\n\t\t\t\tmemcpy(cstr, v.val.string.val, v.val.string.len);\n\t\t\t\tcstr[v.val.string.len] = '\\0';\n\t\t\t\tstate->result[state->result_count++] = cstr;\n\t\t\t}\n\t\t}\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tfuncctx->user_fctx = (void *) state;\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tstate = (OkeysState *) funcctx->user_fctx;\n\n\tif (state->sent_count < state->result_count)\n\t{\n\t\tchar\t   *nxt = state->result[state->sent_count++];\n\n\t\tSRF_RETURN_NEXT(funcctx, CStringGetTextDatum(nxt));\n\t}\n\n\t/* cleanup to reduce or eliminate memory leaks */\n\tfor (i = 0; i < state->result_count; i++)\n\t\tpfree(state->result[i]);\n\tpfree(state->result);\n\tpfree(state);\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  }
]