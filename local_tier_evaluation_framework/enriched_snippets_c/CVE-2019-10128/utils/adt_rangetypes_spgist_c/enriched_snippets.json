[
  {
    "function_name": "spg_range_quad_leaf_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "919-1001",
    "snippet": "Datum\nspg_range_quad_leaf_consistent(PG_FUNCTION_ARGS)\n{\n\tspgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(0);\n\tspgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(1);\n\tRangeType  *leafRange = DatumGetRangeTypeP(in->leafDatum);\n\tTypeCacheEntry *typcache;\n\tbool\t\tres;\n\tint\t\t\ti;\n\n\t/* all tests are exact */\n\tout->recheck = false;\n\n\t/* leafDatum is what it is... */\n\tout->leafValue = in->leafDatum;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(leafRange));\n\n\t/* Perform the required comparison(s) */\n\tres = true;\n\tfor (i = 0; i < in->nkeys; i++)\n\t{\n\t\tDatum\t\tkeyDatum = in->scankeys[i].sk_argument;\n\n\t\t/* Call the function corresponding to the scan strategy */\n\t\tswitch (in->scankeys[i].sk_strategy)\n\t\t{\n\t\t\tcase RANGESTRAT_BEFORE:\n\t\t\t\tres = range_before_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\t\tres = range_overleft_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\t\tres = range_overlaps_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\t\tres = range_overright_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_AFTER:\n\t\t\t\tres = range_after_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\tres = range_adjacent_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINS:\n\t\t\t\tres = range_contains_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\t\tres = range_contained_by_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\t\tres = range_contains_elem_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t\t   keyDatum);\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_EQ:\n\t\t\t\tres = range_eq_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\",\n\t\t\t\t\t in->scankeys[i].sk_strategy);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If leaf datum doesn't match to a query key, no need to check\n\t\t * subsequent keys.\n\t\t */\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized range strategy: %d\"",
            "in->scankeys[i].sk_strategy"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_eq_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "range_eq_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "555-584",
          "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_elem_internal",
          "args": [
            "typcache",
            "leafRange",
            "keyDatum"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_elem_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2340-2376",
          "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_contained_by_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "range_contained_by_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2331-2335",
          "snippet": "bool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2299-2329",
          "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_adjacent_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "range_adjacent_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "780-807",
          "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_after_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "range_after_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "684-706",
          "snippet": "bool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overright_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "range_overright_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "910-935",
          "snippet": "bool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "823-853",
          "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overleft_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "range_overleft_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "869-894",
          "snippet": "bool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_before_internal",
          "args": [
            "typcache",
            "leafRange",
            "DatumGetRangeTypeP(keyDatum)"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "range_before_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "646-668",
          "snippet": "bool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "keyDatum"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(leafRange)"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "leafRange"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->leafDatum"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nDatum\nspg_range_quad_leaf_consistent(PG_FUNCTION_ARGS)\n{\n\tspgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(0);\n\tspgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(1);\n\tRangeType  *leafRange = DatumGetRangeTypeP(in->leafDatum);\n\tTypeCacheEntry *typcache;\n\tbool\t\tres;\n\tint\t\t\ti;\n\n\t/* all tests are exact */\n\tout->recheck = false;\n\n\t/* leafDatum is what it is... */\n\tout->leafValue = in->leafDatum;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(leafRange));\n\n\t/* Perform the required comparison(s) */\n\tres = true;\n\tfor (i = 0; i < in->nkeys; i++)\n\t{\n\t\tDatum\t\tkeyDatum = in->scankeys[i].sk_argument;\n\n\t\t/* Call the function corresponding to the scan strategy */\n\t\tswitch (in->scankeys[i].sk_strategy)\n\t\t{\n\t\t\tcase RANGESTRAT_BEFORE:\n\t\t\t\tres = range_before_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\t\tres = range_overleft_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\t\tres = range_overlaps_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\t\tres = range_overright_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_AFTER:\n\t\t\t\tres = range_after_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\tres = range_adjacent_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINS:\n\t\t\t\tres = range_contains_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\t\tres = range_contained_by_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\t\tres = range_contains_elem_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\t\t\t   keyDatum);\n\t\t\t\tbreak;\n\t\t\tcase RANGESTRAT_EQ:\n\t\t\t\tres = range_eq_internal(typcache, leafRange,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(keyDatum));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\",\n\t\t\t\t\t in->scankeys[i].sk_strategy);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If leaf datum doesn't match to a query key, no need to check\n\t\t * subsequent keys.\n\t\t */\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "adjacent_inner_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "889-913",
    "snippet": "static int\nadjacent_inner_consistent(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\t\t  RangeBound *centroid, RangeBound *prev)\n{\n\tif (prev)\n\t{\n\t\tint\t\t\tprevcmp;\n\t\tint\t\t\tcmp;\n\n\t\t/*\n\t\t * Which direction were we supposed to traverse at previous level,\n\t\t * left or right?\n\t\t */\n\t\tprevcmp = adjacent_cmp_bounds(typcache, arg, prev);\n\n\t\t/* and which direction did we actually go? */\n\t\tcmp = range_cmp_bounds(typcache, centroid, prev);\n\n\t\t/* if the two don't agree, there's nothing to see here */\n\t\tif ((prevcmp < 0 && cmp >= 0) || (prevcmp > 0 && cmp < 0))\n\t\t\treturn 0;\n\t}\n\n\treturn adjacent_cmp_bounds(typcache, arg, centroid);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tbound_cmp(const void *a, const void *b, void *arg);",
      "static int adjacent_inner_consistent(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  RangeBound *arg, RangeBound *centroid,\n\t\t\t\t\t\t  RangeBound *prev);",
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjacent_cmp_bounds",
          "args": [
            "typcache",
            "arg",
            "centroid"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "adjacent_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
          "lines": "787-851",
          "snippet": "static int\nadjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid)\n{\n\tint\t\t\tcmp;\n\n\tAssert(arg->lower != centroid->lower);\n\n\tcmp = range_cmp_bounds(typcache, arg, centroid);\n\n\tif (centroid->lower)\n\t{\n\t\t/*------\n\t\t * The argument is an upper bound, we are searching for adjacent lower\n\t\t * bounds. A matching adjacent lower bound must be *larger* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t * The following table illustrates the desired result with a fixed\n\t\t * argument bound, and different centroids. The CMP column shows\n\t\t * the value of 'cmp' variable, and ADJ shows whether the argument\n\t\t * and centroid are adjacent, per bounds_adjacent(). (N) means we\n\t\t * don't need to check for that case, because it's implied by CMP.\n\t\t * With the argument range [..., 500), the adjacent range we're\n\t\t * searching for is [500, ...):\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[..., 500) [498, ...)\t >\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [499, ...)\t =\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [500, ...)\t <\t   Y\t[500, ...) is to the right\n\t\t *\t[..., 500) [501, ...)\t <\t   N\t[500, ...) is to the left\n\t\t *\n\t\t * So, we must search left when the argument is smaller than, and not\n\t\t * adjacent, to the centroid. Otherwise search right.\n\t\t *------\n\t\t */\n\t\tif (cmp < 0 && !bounds_adjacent(typcache, *arg, *centroid))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t/*------\n\t\t * The argument is a lower bound, we are searching for adjacent upper\n\t\t * bounds. A matching adjacent upper bound must be *smaller* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[500, ...) [..., 499)\t >\t  (N)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 500)\t >\t  (Y)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 501)\t =\t  (N)\t[..., 500) is to the left\n\t\t *\t[500, ...) [..., 502)\t <\t  (N)\t[..., 500) is to the left\n\t\t *\n\t\t * We must search left when the argument is smaller than or equal to\n\t\t * the centroid. Otherwise search right. We don't need to check\n\t\t * whether the argument is adjacent with the centroid, because it\n\t\t * doesn't matter.\n\t\t *------\n\t\t */\n\t\tif (cmp <= 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/spgist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tbound_cmp(const void *a, const void *b, void *arg);",
            "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int\tbound_cmp(const void *a, const void *b, void *arg);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int\nadjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid)\n{\n\tint\t\t\tcmp;\n\n\tAssert(arg->lower != centroid->lower);\n\n\tcmp = range_cmp_bounds(typcache, arg, centroid);\n\n\tif (centroid->lower)\n\t{\n\t\t/*------\n\t\t * The argument is an upper bound, we are searching for adjacent lower\n\t\t * bounds. A matching adjacent lower bound must be *larger* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t * The following table illustrates the desired result with a fixed\n\t\t * argument bound, and different centroids. The CMP column shows\n\t\t * the value of 'cmp' variable, and ADJ shows whether the argument\n\t\t * and centroid are adjacent, per bounds_adjacent(). (N) means we\n\t\t * don't need to check for that case, because it's implied by CMP.\n\t\t * With the argument range [..., 500), the adjacent range we're\n\t\t * searching for is [500, ...):\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[..., 500) [498, ...)\t >\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [499, ...)\t =\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [500, ...)\t <\t   Y\t[500, ...) is to the right\n\t\t *\t[..., 500) [501, ...)\t <\t   N\t[500, ...) is to the left\n\t\t *\n\t\t * So, we must search left when the argument is smaller than, and not\n\t\t * adjacent, to the centroid. Otherwise search right.\n\t\t *------\n\t\t */\n\t\tif (cmp < 0 && !bounds_adjacent(typcache, *arg, *centroid))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t/*------\n\t\t * The argument is a lower bound, we are searching for adjacent upper\n\t\t * bounds. A matching adjacent upper bound must be *smaller* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[500, ...) [..., 499)\t >\t  (N)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 500)\t >\t  (Y)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 501)\t =\t  (N)\t[..., 500) is to the left\n\t\t *\t[500, ...) [..., 502)\t <\t  (N)\t[..., 500) is to the left\n\t\t *\n\t\t * We must search left when the argument is smaller than or equal to\n\t\t * the centroid. Otherwise search right. We don't need to check\n\t\t * whether the argument is adjacent with the centroid, because it\n\t\t * doesn't matter.\n\t\t *------\n\t\t */\n\t\tif (cmp <= 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "centroid",
            "prev"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int\tbound_cmp(const void *a, const void *b, void *arg);\nstatic int adjacent_inner_consistent(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  RangeBound *arg, RangeBound *centroid,\n\t\t\t\t\t\t  RangeBound *prev);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int\nadjacent_inner_consistent(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\t\t  RangeBound *centroid, RangeBound *prev)\n{\n\tif (prev)\n\t{\n\t\tint\t\t\tprevcmp;\n\t\tint\t\t\tcmp;\n\n\t\t/*\n\t\t * Which direction were we supposed to traverse at previous level,\n\t\t * left or right?\n\t\t */\n\t\tprevcmp = adjacent_cmp_bounds(typcache, arg, prev);\n\n\t\t/* and which direction did we actually go? */\n\t\tcmp = range_cmp_bounds(typcache, centroid, prev);\n\n\t\t/* if the two don't agree, there's nothing to see here */\n\t\tif ((prevcmp < 0 && cmp >= 0) || (prevcmp > 0 && cmp < 0))\n\t\t\treturn 0;\n\t}\n\n\treturn adjacent_cmp_bounds(typcache, arg, centroid);\n}"
  },
  {
    "function_name": "adjacent_cmp_bounds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "787-851",
    "snippet": "static int\nadjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid)\n{\n\tint\t\t\tcmp;\n\n\tAssert(arg->lower != centroid->lower);\n\n\tcmp = range_cmp_bounds(typcache, arg, centroid);\n\n\tif (centroid->lower)\n\t{\n\t\t/*------\n\t\t * The argument is an upper bound, we are searching for adjacent lower\n\t\t * bounds. A matching adjacent lower bound must be *larger* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t * The following table illustrates the desired result with a fixed\n\t\t * argument bound, and different centroids. The CMP column shows\n\t\t * the value of 'cmp' variable, and ADJ shows whether the argument\n\t\t * and centroid are adjacent, per bounds_adjacent(). (N) means we\n\t\t * don't need to check for that case, because it's implied by CMP.\n\t\t * With the argument range [..., 500), the adjacent range we're\n\t\t * searching for is [500, ...):\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[..., 500) [498, ...)\t >\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [499, ...)\t =\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [500, ...)\t <\t   Y\t[500, ...) is to the right\n\t\t *\t[..., 500) [501, ...)\t <\t   N\t[500, ...) is to the left\n\t\t *\n\t\t * So, we must search left when the argument is smaller than, and not\n\t\t * adjacent, to the centroid. Otherwise search right.\n\t\t *------\n\t\t */\n\t\tif (cmp < 0 && !bounds_adjacent(typcache, *arg, *centroid))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t/*------\n\t\t * The argument is a lower bound, we are searching for adjacent upper\n\t\t * bounds. A matching adjacent upper bound must be *smaller* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[500, ...) [..., 499)\t >\t  (N)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 500)\t >\t  (Y)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 501)\t =\t  (N)\t[..., 500) is to the left\n\t\t *\t[500, ...) [..., 502)\t <\t  (N)\t[..., 500) is to the left\n\t\t *\n\t\t * We must search left when the argument is smaller than or equal to\n\t\t * the centroid. Otherwise search right. We don't need to check\n\t\t * whether the argument is adjacent with the centroid, because it\n\t\t * doesn't matter.\n\t\t *------\n\t\t */\n\t\tif (cmp <= 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tbound_cmp(const void *a, const void *b, void *arg);",
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bounds_adjacent",
          "args": [
            "typcache",
            "*arg",
            "*centroid"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "bounds_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "739-777",
          "snippet": "bool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nbounds_adjacent(TypeCacheEntry *typcache, RangeBound boundA, RangeBound boundB)\n{\n\tint\t\t\tcmp;\n\n\tAssert(!boundA.lower && boundB.lower);\n\n\tcmp = range_cmp_bound_values(typcache, &boundA, &boundB);\n\tif (cmp < 0)\n\t{\n\t\tRangeType  *r;\n\n\t\t/*\n\t\t * Bounds do not overlap; see if there are points in between.\n\t\t */\n\n\t\t/* in a continuous subtype, there are assumed to be points between */\n\t\tif (!OidIsValid(typcache->rng_canonical_finfo.fn_oid))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * The bounds are of a discrete range type; so make a range A..B and\n\t\t * see if it's empty.\n\t\t */\n\n\t\t/* flip the inclusion flags */\n\t\tboundA.inclusive = !boundA.inclusive;\n\t\tboundB.inclusive = !boundB.inclusive;\n\t\t/* change upper/lower labels to avoid Assert failures */\n\t\tboundA.lower = true;\n\t\tboundB.lower = false;\n\t\tr = make_range(typcache, &boundA, &boundB, false);\n\t\treturn RangeIsEmpty(r);\n\t}\n\telse if (cmp == 0)\n\t\treturn boundA.inclusive != boundB.inclusive;\n\telse\n\t\treturn false;\t\t\t/* bounds overlap */\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "arg",
            "centroid"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "arg->lower != centroid->lower"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int\tbound_cmp(const void *a, const void *b, void *arg);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int\nadjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid)\n{\n\tint\t\t\tcmp;\n\n\tAssert(arg->lower != centroid->lower);\n\n\tcmp = range_cmp_bounds(typcache, arg, centroid);\n\n\tif (centroid->lower)\n\t{\n\t\t/*------\n\t\t * The argument is an upper bound, we are searching for adjacent lower\n\t\t * bounds. A matching adjacent lower bound must be *larger* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t * The following table illustrates the desired result with a fixed\n\t\t * argument bound, and different centroids. The CMP column shows\n\t\t * the value of 'cmp' variable, and ADJ shows whether the argument\n\t\t * and centroid are adjacent, per bounds_adjacent(). (N) means we\n\t\t * don't need to check for that case, because it's implied by CMP.\n\t\t * With the argument range [..., 500), the adjacent range we're\n\t\t * searching for is [500, ...):\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[..., 500) [498, ...)\t >\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [499, ...)\t =\t  (N)\t[500, ...) is to the right\n\t\t *\t[..., 500) [500, ...)\t <\t   Y\t[500, ...) is to the right\n\t\t *\t[..., 500) [501, ...)\t <\t   N\t[500, ...) is to the left\n\t\t *\n\t\t * So, we must search left when the argument is smaller than, and not\n\t\t * adjacent, to the centroid. Otherwise search right.\n\t\t *------\n\t\t */\n\t\tif (cmp < 0 && !bounds_adjacent(typcache, *arg, *centroid))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t/*------\n\t\t * The argument is a lower bound, we are searching for adjacent upper\n\t\t * bounds. A matching adjacent upper bound must be *smaller* than the\n\t\t * argument, but only just.\n\t\t *\n\t\t *\tARGUMENT   CENTROID\t\tCMP   ADJ\n\t\t *\t[500, ...) [..., 499)\t >\t  (N)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 500)\t >\t  (Y)\t[..., 500) is to the right\n\t\t *\t[500, ...) [..., 501)\t =\t  (N)\t[..., 500) is to the left\n\t\t *\t[500, ...) [..., 502)\t <\t  (N)\t[..., 500) is to the left\n\t\t *\n\t\t * We must search left when the argument is smaller than or equal to\n\t\t * the centroid. Otherwise search right. We don't need to check\n\t\t * whether the argument is adjacent with the centroid, because it\n\t\t * doesn't matter.\n\t\t *------\n\t\t */\n\t\tif (cmp <= 0)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "spg_range_quad_inner_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "299-773",
    "snippet": "Datum\nspg_range_quad_inner_consistent(PG_FUNCTION_ARGS)\n{\n\tspgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0);\n\tspgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1);\n\tint\t\t\twhich;\n\tint\t\t\ti;\n\tMemoryContext oldCtx;\n\n\t/*\n\t * For adjacent search we need also previous centroid (if any) to improve\n\t * the precision of the consistent check. In this case needPrevious flag\n\t * is set and centroid is passed into traversalValue.\n\t */\n\tbool\t\tneedPrevious = false;\n\n\tif (in->allTheSame)\n\t{\n\t\t/* Report that all nodes should be visited */\n\t\tout->nNodes = in->nNodes;\n\t\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\t\tfor (i = 0; i < in->nNodes; i++)\n\t\t\tout->nodeNumbers[i] = i;\n\t\tPG_RETURN_VOID();\n\t}\n\n\tif (!in->hasPrefix)\n\t{\n\t\t/*\n\t\t * No centroid on this inner node. Such a node has two child nodes,\n\t\t * the first for empty ranges, and the second for non-empty ones.\n\t\t */\n\t\tAssert(in->nNodes == 2);\n\n\t\t/*\n\t\t * Nth bit of which variable means that (N - 1)th node should be\n\t\t * visited. Initially all bits are set. Bits of nodes which should be\n\t\t * skipped will be unset.\n\t\t */\n\t\twhich = (1 << 1) | (1 << 2);\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy = in->scankeys[i].sk_strategy;\n\t\t\tbool\t\tempty;\n\n\t\t\t/*\n\t\t\t * The only strategy when second argument of operator is not range\n\t\t\t * is RANGESTRAT_CONTAINS_ELEM.\n\t\t\t */\n\t\t\tif (strategy != RANGESTRAT_CONTAINS_ELEM)\n\t\t\t\tempty = RangeIsEmpty(\n\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(in->scankeys[i].sk_argument));\n\t\t\telse\n\t\t\t\tempty = false;\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RANGESTRAT_BEFORE:\n\t\t\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\t\tcase RANGESTRAT_AFTER:\n\t\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\t\t/* These strategies return false if any argument is empty */\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * All ranges contain an empty range. Only non-empty\n\t\t\t\t\t * ranges can contain a non-empty range.\n\t\t\t\t\t */\n\t\t\t\t\tif (!empty)\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Only an empty range is contained by an empty range.\n\t\t\t\t\t * Both empty and non-empty ranges can be contained by a\n\t\t\t\t\t * non-empty range.\n\t\t\t\t\t */\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_EQ:\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (which == 0)\n\t\t\t\tbreak;\t\t\t/* no need to consider remaining conditions */\n\t\t}\n\t}\n\telse\n\t{\n\t\tRangeBound\tcentroidLower,\n\t\t\t\t\tcentroidUpper;\n\t\tbool\t\tcentroidEmpty;\n\t\tTypeCacheEntry *typcache;\n\t\tRangeType  *centroid;\n\n\t\t/* This node has a centroid. Fetch it. */\n\t\tcentroid = DatumGetRangeTypeP(in->prefixDatum);\n\t\ttypcache = range_get_typcache(fcinfo,\n\t\t\t\t\t\t\t\t\t  RangeTypeGetOid(DatumGetRangeTypeP(centroid)));\n\t\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t\t  &centroidEmpty);\n\n\t\tAssert(in->nNodes == 4 || in->nNodes == 5);\n\n\t\t/*\n\t\t * Nth bit of which variable means that (N - 1)th node (Nth quadrant)\n\t\t * should be visited. Initially all bits are set. Bits of nodes which\n\t\t * can be skipped will be unset.\n\t\t */\n\t\twhich = (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5);\n\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy;\n\t\t\tRangeBound\tlower,\n\t\t\t\t\t\tupper;\n\t\t\tbool\t\tempty;\n\t\t\tRangeType  *range = NULL;\n\n\t\t\tRangeType  *prevCentroid = NULL;\n\t\t\tRangeBound\tprevLower,\n\t\t\t\t\t\tprevUpper;\n\t\t\tbool\t\tprevEmpty;\n\n\t\t\t/* Restrictions on range bounds according to scan strategy */\n\t\t\tRangeBound *minLower = NULL,\n\t\t\t\t\t   *maxLower = NULL,\n\t\t\t\t\t   *minUpper = NULL,\n\t\t\t\t\t   *maxUpper = NULL;\n\n\t\t\t/* Are the restrictions on range bounds inclusive? */\n\t\t\tbool\t\tinclusive = true;\n\t\t\tbool\t\tstrictEmpty = true;\n\t\t\tint\t\t\tcmp,\n\t\t\t\t\t\twhich1,\n\t\t\t\t\t\twhich2;\n\n\t\t\tstrategy = in->scankeys[i].sk_strategy;\n\n\t\t\t/*\n\t\t\t * RANGESTRAT_CONTAINS_ELEM is just like RANGESTRAT_CONTAINS, but\n\t\t\t * the argument is a single element. Expand the single element to\n\t\t\t * a range containing only the element, and treat it like\n\t\t\t * RANGESTRAT_CONTAINS.\n\t\t\t */\n\t\t\tif (strategy == RANGESTRAT_CONTAINS_ELEM)\n\t\t\t{\n\t\t\t\tlower.inclusive = true;\n\t\t\t\tlower.infinite = false;\n\t\t\t\tlower.lower = true;\n\t\t\t\tlower.val = in->scankeys[i].sk_argument;\n\n\t\t\t\tupper.inclusive = true;\n\t\t\t\tupper.infinite = false;\n\t\t\t\tupper.lower = false;\n\t\t\t\tupper.val = in->scankeys[i].sk_argument;\n\n\t\t\t\tempty = false;\n\n\t\t\t\tstrategy = RANGESTRAT_CONTAINS;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trange = DatumGetRangeTypeP(in->scankeys[i].sk_argument);\n\t\t\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Most strategies are handled by forming a bounding box from the\n\t\t\t * search key, defined by a minLower, maxLower, minUpper,\n\t\t\t * maxUpper. Some modify 'which' directly, to specify exactly\n\t\t\t * which quadrants need to be visited.\n\t\t\t *\n\t\t\t * For most strategies, nothing matches an empty search key, and\n\t\t\t * an empty range never matches a non-empty key. If a strategy\n\t\t\t * does not behave like that wrt. empty ranges, set strictEmpty to\n\t\t\t * false.\n\t\t\t */\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RANGESTRAT_BEFORE:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is before range B if upper bound of A is lower\n\t\t\t\t\t * than lower bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tmaxUpper = &lower;\n\t\t\t\t\tinclusive = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERLEFT:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is overleft to range B if upper bound of A is\n\t\t\t\t\t * less or equal to upper bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tmaxUpper = &upper;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERLAPS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Non-empty ranges overlap, if lower bound of each range\n\t\t\t\t\t * is lower or equal to upper bound of the other range.\n\t\t\t\t\t */\n\t\t\t\t\tmaxLower = &upper;\n\t\t\t\t\tminUpper = &lower;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERRIGHT:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is overright to range B if lower bound of A is\n\t\t\t\t\t * greater or equal to lower bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tminLower = &lower;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_AFTER:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is after range B if lower bound of A is greater\n\t\t\t\t\t * than upper bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tminLower = &upper;\n\t\t\t\t\tinclusive = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\tbreak;\t/* Skip to strictEmpty check. */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Previously selected quadrant could exclude possibility\n\t\t\t\t\t * for lower or upper bounds to be adjacent. Deserialize\n\t\t\t\t\t * previous centroid range if present for checking this.\n\t\t\t\t\t */\n\t\t\t\t\tif (in->traversalValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tprevCentroid = DatumGetRangeTypeP(in->traversalValue);\n\t\t\t\t\t\trange_deserialize(typcache, prevCentroid,\n\t\t\t\t\t\t\t\t\t\t  &prevLower, &prevUpper, &prevEmpty);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For a range's upper bound to be adjacent to the\n\t\t\t\t\t * argument's lower bound, it will be found along the line\n\t\t\t\t\t * adjacent to (and just below) Y=lower. Therefore, if the\n\t\t\t\t\t * argument's lower bound is less than the centroid's\n\t\t\t\t\t * upper bound, the line falls in quadrants 2 and 3; if\n\t\t\t\t\t * greater, the line falls in quadrants 1 and 4. (see\n\t\t\t\t\t * adjacent_cmp_bounds for description of edge cases).\n\t\t\t\t\t */\n\t\t\t\t\tcmp = adjacent_inner_consistent(typcache, &lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&centroidUpper,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevCentroid ? &prevUpper : NULL);\n\t\t\t\t\tif (cmp > 0)\n\t\t\t\t\t\twhich1 = (1 << 1) | (1 << 4);\n\t\t\t\t\telse if (cmp < 0)\n\t\t\t\t\t\twhich1 = (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich1 = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Also search for ranges's adjacent to argument's upper\n\t\t\t\t\t * bound. They will be found along the line adjacent to\n\t\t\t\t\t * (and just right of) X=upper, which falls in quadrants 3\n\t\t\t\t\t * and 4, or 1 and 2.\n\t\t\t\t\t */\n\t\t\t\t\tcmp = adjacent_inner_consistent(typcache, &upper,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&centroidLower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevCentroid ? &prevLower : NULL);\n\t\t\t\t\tif (cmp > 0)\n\t\t\t\t\t\twhich2 = (1 << 1) | (1 << 2);\n\t\t\t\t\telse if (cmp < 0)\n\t\t\t\t\t\twhich2 = (1 << 3) | (1 << 4);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich2 = 0;\n\n\t\t\t\t\t/* We must chase down ranges adjacent to either bound. */\n\t\t\t\t\twhich &= which1 | which2;\n\n\t\t\t\t\tneedPrevious = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Non-empty range A contains non-empty range B if lower\n\t\t\t\t\t * bound of A is lower or equal to lower bound of range B\n\t\t\t\t\t * and upper bound of range A is greater or equal to upper\n\t\t\t\t\t * bound of range A.\n\t\t\t\t\t *\n\t\t\t\t\t * All non-empty ranges contain an empty range.\n\t\t\t\t\t */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\tif (!empty)\n\t\t\t\t\t{\n\t\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4);\n\t\t\t\t\t\tmaxLower = &lower;\n\t\t\t\t\t\tminUpper = &upper;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\t\t\t/* The opposite of contains. */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\tif (empty)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* An empty range is only contained by an empty range */\n\t\t\t\t\t\twhich &= (1 << 5);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminLower = &lower;\n\t\t\t\t\t\tmaxUpper = &upper;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_EQ:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Equal range can be only in the same quadrant where\n\t\t\t\t\t * argument would be placed to.\n\t\t\t\t\t */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\twhich &= (1 << getQuadrant(typcache, centroid, range));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (strictEmpty)\n\t\t\t{\n\t\t\t\tif (empty)\n\t\t\t\t{\n\t\t\t\t\t/* Scan key is empty, no branches are satisfying */\n\t\t\t\t\twhich = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Shouldn't visit tree branch with empty ranges */\n\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Using the bounding box, see which quadrants we have to descend\n\t\t\t * into.\n\t\t\t */\n\t\t\tif (minLower)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's lower bound is less than or equal to the\n\t\t\t\t * minimum lower bound, anything in the 3rd and 4th quadrants\n\t\t\t\t * will have an even smaller lower bound, and thus can't\n\t\t\t\t * match.\n\t\t\t\t */\n\t\t\t\tif (range_cmp_bounds(typcache, &centroidLower, minLower) <= 0)\n\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 5);\n\t\t\t}\n\t\t\tif (maxLower)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's lower bound is greater than the maximum\n\t\t\t\t * lower bound, anything in the 1st and 2nd quadrants will\n\t\t\t\t * also have a greater than or equal lower bound, and thus\n\t\t\t\t * can't match. If the centroid's lower bound is equal to the\n\t\t\t\t * maximum lower bound, we can still exclude the 1st and 2nd\n\t\t\t\t * quadrants if we're looking for a value strictly greater\n\t\t\t\t * than the maximum.\n\t\t\t\t */\n\t\t\t\tint\t\t\tcmp;\n\n\t\t\t\tcmp = range_cmp_bounds(typcache, &centroidLower, maxLower);\n\t\t\t\tif (cmp > 0 || (!inclusive && cmp == 0))\n\t\t\t\t\twhich &= (1 << 3) | (1 << 4) | (1 << 5);\n\t\t\t}\n\t\t\tif (minUpper)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's upper bound is less than or equal to the\n\t\t\t\t * minimum upper bound, anything in the 2nd and 3rd quadrants\n\t\t\t\t * will have an even smaller upper bound, and thus can't\n\t\t\t\t * match.\n\t\t\t\t */\n\t\t\t\tif (range_cmp_bounds(typcache, &centroidUpper, minUpper) <= 0)\n\t\t\t\t\twhich &= (1 << 1) | (1 << 4) | (1 << 5);\n\t\t\t}\n\t\t\tif (maxUpper)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's upper bound is greater than the maximum\n\t\t\t\t * upper bound, anything in the 1st and 4th quadrants will\n\t\t\t\t * also have a greater than or equal upper bound, and thus\n\t\t\t\t * can't match. If the centroid's upper bound is equal to the\n\t\t\t\t * maximum upper bound, we can still exclude the 1st and 4th\n\t\t\t\t * quadrants if we're looking for a value strictly greater\n\t\t\t\t * than the maximum.\n\t\t\t\t */\n\t\t\t\tint\t\t\tcmp;\n\n\t\t\t\tcmp = range_cmp_bounds(typcache, &centroidUpper, maxUpper);\n\t\t\t\tif (cmp > 0 || (!inclusive && cmp == 0))\n\t\t\t\t\twhich &= (1 << 2) | (1 << 3) | (1 << 5);\n\t\t\t}\n\n\t\t\tif (which == 0)\n\t\t\t\tbreak;\t\t\t/* no need to consider remaining conditions */\n\t\t}\n\t}\n\n\t/* We must descend into the quadrant(s) identified by 'which' */\n\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\tif (needPrevious)\n\t\tout->traversalValues = (void **) palloc(sizeof(void *) * in->nNodes);\n\tout->nNodes = 0;\n\n\t/*\n\t * Elements of traversalValues should be allocated in\n\t * traversalMemoryContext\n\t */\n\toldCtx = MemoryContextSwitchTo(in->traversalMemoryContext);\n\n\tfor (i = 1; i <= in->nNodes; i++)\n\t{\n\t\tif (which & (1 << i))\n\t\t{\n\t\t\t/* Save previous prefix if needed */\n\t\t\tif (needPrevious)\n\t\t\t{\n\t\t\t\tDatum\t\tpreviousCentroid;\n\n\t\t\t\t/*\n\t\t\t\t * We know, that in->prefixDatum in this place is varlena,\n\t\t\t\t * because it's range\n\t\t\t\t */\n\t\t\t\tpreviousCentroid = datumCopy(in->prefixDatum, false, -1);\n\t\t\t\tout->traversalValues[out->nNodes] = (void *) previousCentroid;\n\t\t\t}\n\t\t\tout->nodeNumbers[out->nNodes] = i - 1;\n\t\t\tout->nNodes++;\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldCtx);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldCtx"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "in->prefixDatum",
            "false",
            "-1"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "in->traversalMemoryContext"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(void *) * in->nNodes"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&centroidUpper",
            "maxUpper"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized range strategy: %d\"",
            "strategy"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getQuadrant",
          "args": [
            "typcache",
            "centroid",
            "range"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "getQuadrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
          "lines": "94-125",
          "snippet": "static int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/spgist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);",
            "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjacent_inner_consistent",
          "args": [
            "typcache",
            "&upper",
            "&centroidLower",
            "prevCentroid ? &prevLower : NULL"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "adjacent_inner_consistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
          "lines": "889-913",
          "snippet": "static int\nadjacent_inner_consistent(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\t\t  RangeBound *centroid, RangeBound *prev)\n{\n\tif (prev)\n\t{\n\t\tint\t\t\tprevcmp;\n\t\tint\t\t\tcmp;\n\n\t\t/*\n\t\t * Which direction were we supposed to traverse at previous level,\n\t\t * left or right?\n\t\t */\n\t\tprevcmp = adjacent_cmp_bounds(typcache, arg, prev);\n\n\t\t/* and which direction did we actually go? */\n\t\tcmp = range_cmp_bounds(typcache, centroid, prev);\n\n\t\t/* if the two don't agree, there's nothing to see here */\n\t\tif ((prevcmp < 0 && cmp >= 0) || (prevcmp > 0 && cmp < 0))\n\t\t\treturn 0;\n\t}\n\n\treturn adjacent_cmp_bounds(typcache, arg, centroid);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/spgist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tbound_cmp(const void *a, const void *b, void *arg);",
            "static int adjacent_inner_consistent(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  RangeBound *arg, RangeBound *centroid,\n\t\t\t\t\t\t  RangeBound *prev);",
            "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int\tbound_cmp(const void *a, const void *b, void *arg);\nstatic int adjacent_inner_consistent(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  RangeBound *arg, RangeBound *centroid,\n\t\t\t\t\t\t  RangeBound *prev);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int\nadjacent_inner_consistent(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\t\t  RangeBound *centroid, RangeBound *prev)\n{\n\tif (prev)\n\t{\n\t\tint\t\t\tprevcmp;\n\t\tint\t\t\tcmp;\n\n\t\t/*\n\t\t * Which direction were we supposed to traverse at previous level,\n\t\t * left or right?\n\t\t */\n\t\tprevcmp = adjacent_cmp_bounds(typcache, arg, prev);\n\n\t\t/* and which direction did we actually go? */\n\t\tcmp = range_cmp_bounds(typcache, centroid, prev);\n\n\t\t/* if the two don't agree, there's nothing to see here */\n\t\tif ((prevcmp < 0 && cmp >= 0) || (prevcmp > 0 && cmp < 0))\n\t\t\treturn 0;\n\t}\n\n\treturn adjacent_cmp_bounds(typcache, arg, centroid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "prevCentroid",
            "&prevLower",
            "&prevUpper",
            "&prevEmpty"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->traversalValue"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->scankeys[i].sk_argument"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 4 || in->nNodes == 5"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(DatumGetRangeTypeP(centroid))"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "DatumGetRangeTypeP(centroid)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "centroid"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->prefixDatum"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(in->scankeys[i].sk_argument)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->scankeys[i].sk_argument"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "in->nNodes == 2"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nDatum\nspg_range_quad_inner_consistent(PG_FUNCTION_ARGS)\n{\n\tspgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0);\n\tspgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1);\n\tint\t\t\twhich;\n\tint\t\t\ti;\n\tMemoryContext oldCtx;\n\n\t/*\n\t * For adjacent search we need also previous centroid (if any) to improve\n\t * the precision of the consistent check. In this case needPrevious flag\n\t * is set and centroid is passed into traversalValue.\n\t */\n\tbool\t\tneedPrevious = false;\n\n\tif (in->allTheSame)\n\t{\n\t\t/* Report that all nodes should be visited */\n\t\tout->nNodes = in->nNodes;\n\t\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\t\tfor (i = 0; i < in->nNodes; i++)\n\t\t\tout->nodeNumbers[i] = i;\n\t\tPG_RETURN_VOID();\n\t}\n\n\tif (!in->hasPrefix)\n\t{\n\t\t/*\n\t\t * No centroid on this inner node. Such a node has two child nodes,\n\t\t * the first for empty ranges, and the second for non-empty ones.\n\t\t */\n\t\tAssert(in->nNodes == 2);\n\n\t\t/*\n\t\t * Nth bit of which variable means that (N - 1)th node should be\n\t\t * visited. Initially all bits are set. Bits of nodes which should be\n\t\t * skipped will be unset.\n\t\t */\n\t\twhich = (1 << 1) | (1 << 2);\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy = in->scankeys[i].sk_strategy;\n\t\t\tbool\t\tempty;\n\n\t\t\t/*\n\t\t\t * The only strategy when second argument of operator is not range\n\t\t\t * is RANGESTRAT_CONTAINS_ELEM.\n\t\t\t */\n\t\t\tif (strategy != RANGESTRAT_CONTAINS_ELEM)\n\t\t\t\tempty = RangeIsEmpty(\n\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(in->scankeys[i].sk_argument));\n\t\t\telse\n\t\t\t\tempty = false;\n\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RANGESTRAT_BEFORE:\n\t\t\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\t\tcase RANGESTRAT_AFTER:\n\t\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\t\t/* These strategies return false if any argument is empty */\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * All ranges contain an empty range. Only non-empty\n\t\t\t\t\t * ranges can contain a non-empty range.\n\t\t\t\t\t */\n\t\t\t\t\tif (!empty)\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Only an empty range is contained by an empty range.\n\t\t\t\t\t * Both empty and non-empty ranges can be contained by a\n\t\t\t\t\t * non-empty range.\n\t\t\t\t\t */\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_EQ:\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\twhich &= (1 << 1);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich &= (1 << 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (which == 0)\n\t\t\t\tbreak;\t\t\t/* no need to consider remaining conditions */\n\t\t}\n\t}\n\telse\n\t{\n\t\tRangeBound\tcentroidLower,\n\t\t\t\t\tcentroidUpper;\n\t\tbool\t\tcentroidEmpty;\n\t\tTypeCacheEntry *typcache;\n\t\tRangeType  *centroid;\n\n\t\t/* This node has a centroid. Fetch it. */\n\t\tcentroid = DatumGetRangeTypeP(in->prefixDatum);\n\t\ttypcache = range_get_typcache(fcinfo,\n\t\t\t\t\t\t\t\t\t  RangeTypeGetOid(DatumGetRangeTypeP(centroid)));\n\t\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t\t  &centroidEmpty);\n\n\t\tAssert(in->nNodes == 4 || in->nNodes == 5);\n\n\t\t/*\n\t\t * Nth bit of which variable means that (N - 1)th node (Nth quadrant)\n\t\t * should be visited. Initially all bits are set. Bits of nodes which\n\t\t * can be skipped will be unset.\n\t\t */\n\t\twhich = (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5);\n\n\t\tfor (i = 0; i < in->nkeys; i++)\n\t\t{\n\t\t\tStrategyNumber strategy;\n\t\t\tRangeBound\tlower,\n\t\t\t\t\t\tupper;\n\t\t\tbool\t\tempty;\n\t\t\tRangeType  *range = NULL;\n\n\t\t\tRangeType  *prevCentroid = NULL;\n\t\t\tRangeBound\tprevLower,\n\t\t\t\t\t\tprevUpper;\n\t\t\tbool\t\tprevEmpty;\n\n\t\t\t/* Restrictions on range bounds according to scan strategy */\n\t\t\tRangeBound *minLower = NULL,\n\t\t\t\t\t   *maxLower = NULL,\n\t\t\t\t\t   *minUpper = NULL,\n\t\t\t\t\t   *maxUpper = NULL;\n\n\t\t\t/* Are the restrictions on range bounds inclusive? */\n\t\t\tbool\t\tinclusive = true;\n\t\t\tbool\t\tstrictEmpty = true;\n\t\t\tint\t\t\tcmp,\n\t\t\t\t\t\twhich1,\n\t\t\t\t\t\twhich2;\n\n\t\t\tstrategy = in->scankeys[i].sk_strategy;\n\n\t\t\t/*\n\t\t\t * RANGESTRAT_CONTAINS_ELEM is just like RANGESTRAT_CONTAINS, but\n\t\t\t * the argument is a single element. Expand the single element to\n\t\t\t * a range containing only the element, and treat it like\n\t\t\t * RANGESTRAT_CONTAINS.\n\t\t\t */\n\t\t\tif (strategy == RANGESTRAT_CONTAINS_ELEM)\n\t\t\t{\n\t\t\t\tlower.inclusive = true;\n\t\t\t\tlower.infinite = false;\n\t\t\t\tlower.lower = true;\n\t\t\t\tlower.val = in->scankeys[i].sk_argument;\n\n\t\t\t\tupper.inclusive = true;\n\t\t\t\tupper.infinite = false;\n\t\t\t\tupper.lower = false;\n\t\t\t\tupper.val = in->scankeys[i].sk_argument;\n\n\t\t\t\tempty = false;\n\n\t\t\t\tstrategy = RANGESTRAT_CONTAINS;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trange = DatumGetRangeTypeP(in->scankeys[i].sk_argument);\n\t\t\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Most strategies are handled by forming a bounding box from the\n\t\t\t * search key, defined by a minLower, maxLower, minUpper,\n\t\t\t * maxUpper. Some modify 'which' directly, to specify exactly\n\t\t\t * which quadrants need to be visited.\n\t\t\t *\n\t\t\t * For most strategies, nothing matches an empty search key, and\n\t\t\t * an empty range never matches a non-empty key. If a strategy\n\t\t\t * does not behave like that wrt. empty ranges, set strictEmpty to\n\t\t\t * false.\n\t\t\t */\n\t\t\tswitch (strategy)\n\t\t\t{\n\t\t\t\tcase RANGESTRAT_BEFORE:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is before range B if upper bound of A is lower\n\t\t\t\t\t * than lower bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tmaxUpper = &lower;\n\t\t\t\t\tinclusive = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERLEFT:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is overleft to range B if upper bound of A is\n\t\t\t\t\t * less or equal to upper bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tmaxUpper = &upper;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERLAPS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Non-empty ranges overlap, if lower bound of each range\n\t\t\t\t\t * is lower or equal to upper bound of the other range.\n\t\t\t\t\t */\n\t\t\t\t\tmaxLower = &upper;\n\t\t\t\t\tminUpper = &lower;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_OVERRIGHT:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is overright to range B if lower bound of A is\n\t\t\t\t\t * greater or equal to lower bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tminLower = &lower;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_AFTER:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Range A is after range B if lower bound of A is greater\n\t\t\t\t\t * than upper bound of B.\n\t\t\t\t\t */\n\t\t\t\t\tminLower = &upper;\n\t\t\t\t\tinclusive = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_ADJACENT:\n\t\t\t\t\tif (empty)\n\t\t\t\t\t\tbreak;\t/* Skip to strictEmpty check. */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Previously selected quadrant could exclude possibility\n\t\t\t\t\t * for lower or upper bounds to be adjacent. Deserialize\n\t\t\t\t\t * previous centroid range if present for checking this.\n\t\t\t\t\t */\n\t\t\t\t\tif (in->traversalValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tprevCentroid = DatumGetRangeTypeP(in->traversalValue);\n\t\t\t\t\t\trange_deserialize(typcache, prevCentroid,\n\t\t\t\t\t\t\t\t\t\t  &prevLower, &prevUpper, &prevEmpty);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For a range's upper bound to be adjacent to the\n\t\t\t\t\t * argument's lower bound, it will be found along the line\n\t\t\t\t\t * adjacent to (and just below) Y=lower. Therefore, if the\n\t\t\t\t\t * argument's lower bound is less than the centroid's\n\t\t\t\t\t * upper bound, the line falls in quadrants 2 and 3; if\n\t\t\t\t\t * greater, the line falls in quadrants 1 and 4. (see\n\t\t\t\t\t * adjacent_cmp_bounds for description of edge cases).\n\t\t\t\t\t */\n\t\t\t\t\tcmp = adjacent_inner_consistent(typcache, &lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&centroidUpper,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevCentroid ? &prevUpper : NULL);\n\t\t\t\t\tif (cmp > 0)\n\t\t\t\t\t\twhich1 = (1 << 1) | (1 << 4);\n\t\t\t\t\telse if (cmp < 0)\n\t\t\t\t\t\twhich1 = (1 << 2) | (1 << 3);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich1 = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Also search for ranges's adjacent to argument's upper\n\t\t\t\t\t * bound. They will be found along the line adjacent to\n\t\t\t\t\t * (and just right of) X=upper, which falls in quadrants 3\n\t\t\t\t\t * and 4, or 1 and 2.\n\t\t\t\t\t */\n\t\t\t\t\tcmp = adjacent_inner_consistent(typcache, &upper,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&centroidLower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprevCentroid ? &prevLower : NULL);\n\t\t\t\t\tif (cmp > 0)\n\t\t\t\t\t\twhich2 = (1 << 1) | (1 << 2);\n\t\t\t\t\telse if (cmp < 0)\n\t\t\t\t\t\twhich2 = (1 << 3) | (1 << 4);\n\t\t\t\t\telse\n\t\t\t\t\t\twhich2 = 0;\n\n\t\t\t\t\t/* We must chase down ranges adjacent to either bound. */\n\t\t\t\t\twhich &= which1 | which2;\n\n\t\t\t\t\tneedPrevious = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINS:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Non-empty range A contains non-empty range B if lower\n\t\t\t\t\t * bound of A is lower or equal to lower bound of range B\n\t\t\t\t\t * and upper bound of range A is greater or equal to upper\n\t\t\t\t\t * bound of range A.\n\t\t\t\t\t *\n\t\t\t\t\t * All non-empty ranges contain an empty range.\n\t\t\t\t\t */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\tif (!empty)\n\t\t\t\t\t{\n\t\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4);\n\t\t\t\t\t\tmaxLower = &lower;\n\t\t\t\t\t\tminUpper = &upper;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\t\t\t/* The opposite of contains. */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\tif (empty)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* An empty range is only contained by an empty range */\n\t\t\t\t\t\twhich &= (1 << 5);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminLower = &lower;\n\t\t\t\t\t\tmaxUpper = &upper;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RANGESTRAT_EQ:\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Equal range can be only in the same quadrant where\n\t\t\t\t\t * argument would be placed to.\n\t\t\t\t\t */\n\t\t\t\t\tstrictEmpty = false;\n\t\t\t\t\twhich &= (1 << getQuadrant(typcache, centroid, range));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (strictEmpty)\n\t\t\t{\n\t\t\t\tif (empty)\n\t\t\t\t{\n\t\t\t\t\t/* Scan key is empty, no branches are satisfying */\n\t\t\t\t\twhich = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Shouldn't visit tree branch with empty ranges */\n\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Using the bounding box, see which quadrants we have to descend\n\t\t\t * into.\n\t\t\t */\n\t\t\tif (minLower)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's lower bound is less than or equal to the\n\t\t\t\t * minimum lower bound, anything in the 3rd and 4th quadrants\n\t\t\t\t * will have an even smaller lower bound, and thus can't\n\t\t\t\t * match.\n\t\t\t\t */\n\t\t\t\tif (range_cmp_bounds(typcache, &centroidLower, minLower) <= 0)\n\t\t\t\t\twhich &= (1 << 1) | (1 << 2) | (1 << 5);\n\t\t\t}\n\t\t\tif (maxLower)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's lower bound is greater than the maximum\n\t\t\t\t * lower bound, anything in the 1st and 2nd quadrants will\n\t\t\t\t * also have a greater than or equal lower bound, and thus\n\t\t\t\t * can't match. If the centroid's lower bound is equal to the\n\t\t\t\t * maximum lower bound, we can still exclude the 1st and 2nd\n\t\t\t\t * quadrants if we're looking for a value strictly greater\n\t\t\t\t * than the maximum.\n\t\t\t\t */\n\t\t\t\tint\t\t\tcmp;\n\n\t\t\t\tcmp = range_cmp_bounds(typcache, &centroidLower, maxLower);\n\t\t\t\tif (cmp > 0 || (!inclusive && cmp == 0))\n\t\t\t\t\twhich &= (1 << 3) | (1 << 4) | (1 << 5);\n\t\t\t}\n\t\t\tif (minUpper)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's upper bound is less than or equal to the\n\t\t\t\t * minimum upper bound, anything in the 2nd and 3rd quadrants\n\t\t\t\t * will have an even smaller upper bound, and thus can't\n\t\t\t\t * match.\n\t\t\t\t */\n\t\t\t\tif (range_cmp_bounds(typcache, &centroidUpper, minUpper) <= 0)\n\t\t\t\t\twhich &= (1 << 1) | (1 << 4) | (1 << 5);\n\t\t\t}\n\t\t\tif (maxUpper)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If the centroid's upper bound is greater than the maximum\n\t\t\t\t * upper bound, anything in the 1st and 4th quadrants will\n\t\t\t\t * also have a greater than or equal upper bound, and thus\n\t\t\t\t * can't match. If the centroid's upper bound is equal to the\n\t\t\t\t * maximum upper bound, we can still exclude the 1st and 4th\n\t\t\t\t * quadrants if we're looking for a value strictly greater\n\t\t\t\t * than the maximum.\n\t\t\t\t */\n\t\t\t\tint\t\t\tcmp;\n\n\t\t\t\tcmp = range_cmp_bounds(typcache, &centroidUpper, maxUpper);\n\t\t\t\tif (cmp > 0 || (!inclusive && cmp == 0))\n\t\t\t\t\twhich &= (1 << 2) | (1 << 3) | (1 << 5);\n\t\t\t}\n\n\t\t\tif (which == 0)\n\t\t\t\tbreak;\t\t\t/* no need to consider remaining conditions */\n\t\t}\n\t}\n\n\t/* We must descend into the quadrant(s) identified by 'which' */\n\tout->nodeNumbers = (int *) palloc(sizeof(int) * in->nNodes);\n\tif (needPrevious)\n\t\tout->traversalValues = (void **) palloc(sizeof(void *) * in->nNodes);\n\tout->nNodes = 0;\n\n\t/*\n\t * Elements of traversalValues should be allocated in\n\t * traversalMemoryContext\n\t */\n\toldCtx = MemoryContextSwitchTo(in->traversalMemoryContext);\n\n\tfor (i = 1; i <= in->nNodes; i++)\n\t{\n\t\tif (which & (1 << i))\n\t\t{\n\t\t\t/* Save previous prefix if needed */\n\t\t\tif (needPrevious)\n\t\t\t{\n\t\t\t\tDatum\t\tpreviousCentroid;\n\n\t\t\t\t/*\n\t\t\t\t * We know, that in->prefixDatum in this place is varlena,\n\t\t\t\t * because it's range\n\t\t\t\t */\n\t\t\t\tpreviousCentroid = datumCopy(in->prefixDatum, false, -1);\n\t\t\t\tout->traversalValues[out->nNodes] = (void *) previousCentroid;\n\t\t\t}\n\t\t\tout->nodeNumbers[out->nNodes] = i - 1;\n\t\t\tout->nNodes++;\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldCtx);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "spg_range_quad_picksplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "199-293",
    "snippet": "Datum\nspg_range_quad_picksplit(PG_FUNCTION_ARGS)\n{\n\tspgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(0);\n\tspgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(1);\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tint\t\t\tnonEmptyCount;\n\tRangeType  *centroid;\n\tbool\t\tempty;\n\tTypeCacheEntry *typcache;\n\n\t/* Use the median values of lower and upper bounds as the centroid range */\n\tRangeBound *lowerBounds,\n\t\t\t   *upperBounds;\n\n\ttypcache = range_get_typcache(fcinfo,\n\t\t\t\t\t\t\t\t  RangeTypeGetOid(DatumGetRangeTypeP(in->datums[0])));\n\n\t/* Allocate memory for bounds */\n\tlowerBounds = palloc(sizeof(RangeBound) * in->nTuples);\n\tupperBounds = palloc(sizeof(RangeBound) * in->nTuples);\n\tj = 0;\n\n\t/* Deserialize bounds of ranges, count non-empty ranges */\n\tfor (i = 0; i < in->nTuples; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(in->datums[i]),\n\t\t\t\t\t\t  &lowerBounds[j], &upperBounds[j], &empty);\n\t\tif (!empty)\n\t\t\tj++;\n\t}\n\tnonEmptyCount = j;\n\n\t/*\n\t * All the ranges are empty. The best we can do is to construct an inner\n\t * node with no centroid, and put all ranges into node 0. If non-empty\n\t * ranges are added later, they will be routed to node 1.\n\t */\n\tif (nonEmptyCount == 0)\n\t{\n\t\tout->nNodes = 2;\n\t\tout->hasPrefix = false;\n\t\t/* Prefix is empty */\n\t\tout->prefixDatum = PointerGetDatum(NULL);\n\t\tout->nodeLabels = NULL;\n\n\t\tout->mapTuplesToNodes = palloc(sizeof(int) * in->nTuples);\n\t\tout->leafTupleDatums = palloc(sizeof(Datum) * in->nTuples);\n\n\t\t/* Place all ranges into node 0 */\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\tRangeType  *range = DatumGetRangeTypeP(in->datums[i]);\n\n\t\t\tout->leafTupleDatums[i] = RangeTypePGetDatum(range);\n\t\t\tout->mapTuplesToNodes[i] = 0;\n\t\t}\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/* Sort range bounds in order to find medians */\n\tqsort_arg(lowerBounds, nonEmptyCount, sizeof(RangeBound),\n\t\t\t  bound_cmp, typcache);\n\tqsort_arg(upperBounds, nonEmptyCount, sizeof(RangeBound),\n\t\t\t  bound_cmp, typcache);\n\n\t/* Construct \"centroid\" range from medians of lower and upper bounds */\n\tcentroid = range_serialize(typcache, &lowerBounds[nonEmptyCount / 2],\n\t\t\t\t\t\t\t   &upperBounds[nonEmptyCount / 2], false);\n\tout->hasPrefix = true;\n\tout->prefixDatum = RangeTypePGetDatum(centroid);\n\n\t/* Create node for empty ranges only if it is a root node */\n\tout->nNodes = (in->level == 0) ? 5 : 4;\n\tout->nodeLabels = NULL;\t\t/* we don't need node labels */\n\n\tout->mapTuplesToNodes = palloc(sizeof(int) * in->nTuples);\n\tout->leafTupleDatums = palloc(sizeof(Datum) * in->nTuples);\n\n\t/*\n\t * Assign ranges to corresponding nodes according to quadrants relative to\n\t * \"centroid\" range.\n\t */\n\tfor (i = 0; i < in->nTuples; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(in->datums[i]);\n\t\tint16\t\tquadrant = getQuadrant(typcache, centroid, range);\n\n\t\tout->leafTupleDatums[i] = RangeTypePGetDatum(range);\n\t\tout->mapTuplesToNodes[i] = quadrant - 1;\n\t}\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "range"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getQuadrant",
          "args": [
            "typcache",
            "centroid",
            "range"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "getQuadrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
          "lines": "94-125",
          "snippet": "static int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/spgist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);",
            "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->datums[i]"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Datum) * in->nTuples"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "centroid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lowerBounds[nonEmptyCount / 2]",
            "&upperBounds[nonEmptyCount / 2]",
            "false"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "upperBounds",
            "nonEmptyCount",
            "sizeof(RangeBound)",
            "bound_cmp",
            "typcache"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "lowerBounds",
            "nonEmptyCount",
            "sizeof(RangeBound)",
            "bound_cmp",
            "typcache"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "range"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->datums[i]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "DatumGetRangeTypeP(in->datums[i])",
            "&lowerBounds[j]",
            "&upperBounds[j]",
            "&empty"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->datums[i]"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(DatumGetRangeTypeP(in->datums[0]))"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "DatumGetRangeTypeP(in->datums[0])"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->datums[0]"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nDatum\nspg_range_quad_picksplit(PG_FUNCTION_ARGS)\n{\n\tspgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(0);\n\tspgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(1);\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tint\t\t\tnonEmptyCount;\n\tRangeType  *centroid;\n\tbool\t\tempty;\n\tTypeCacheEntry *typcache;\n\n\t/* Use the median values of lower and upper bounds as the centroid range */\n\tRangeBound *lowerBounds,\n\t\t\t   *upperBounds;\n\n\ttypcache = range_get_typcache(fcinfo,\n\t\t\t\t\t\t\t\t  RangeTypeGetOid(DatumGetRangeTypeP(in->datums[0])));\n\n\t/* Allocate memory for bounds */\n\tlowerBounds = palloc(sizeof(RangeBound) * in->nTuples);\n\tupperBounds = palloc(sizeof(RangeBound) * in->nTuples);\n\tj = 0;\n\n\t/* Deserialize bounds of ranges, count non-empty ranges */\n\tfor (i = 0; i < in->nTuples; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(in->datums[i]),\n\t\t\t\t\t\t  &lowerBounds[j], &upperBounds[j], &empty);\n\t\tif (!empty)\n\t\t\tj++;\n\t}\n\tnonEmptyCount = j;\n\n\t/*\n\t * All the ranges are empty. The best we can do is to construct an inner\n\t * node with no centroid, and put all ranges into node 0. If non-empty\n\t * ranges are added later, they will be routed to node 1.\n\t */\n\tif (nonEmptyCount == 0)\n\t{\n\t\tout->nNodes = 2;\n\t\tout->hasPrefix = false;\n\t\t/* Prefix is empty */\n\t\tout->prefixDatum = PointerGetDatum(NULL);\n\t\tout->nodeLabels = NULL;\n\n\t\tout->mapTuplesToNodes = palloc(sizeof(int) * in->nTuples);\n\t\tout->leafTupleDatums = palloc(sizeof(Datum) * in->nTuples);\n\n\t\t/* Place all ranges into node 0 */\n\t\tfor (i = 0; i < in->nTuples; i++)\n\t\t{\n\t\t\tRangeType  *range = DatumGetRangeTypeP(in->datums[i]);\n\n\t\t\tout->leafTupleDatums[i] = RangeTypePGetDatum(range);\n\t\t\tout->mapTuplesToNodes[i] = 0;\n\t\t}\n\t\tPG_RETURN_VOID();\n\t}\n\n\t/* Sort range bounds in order to find medians */\n\tqsort_arg(lowerBounds, nonEmptyCount, sizeof(RangeBound),\n\t\t\t  bound_cmp, typcache);\n\tqsort_arg(upperBounds, nonEmptyCount, sizeof(RangeBound),\n\t\t\t  bound_cmp, typcache);\n\n\t/* Construct \"centroid\" range from medians of lower and upper bounds */\n\tcentroid = range_serialize(typcache, &lowerBounds[nonEmptyCount / 2],\n\t\t\t\t\t\t\t   &upperBounds[nonEmptyCount / 2], false);\n\tout->hasPrefix = true;\n\tout->prefixDatum = RangeTypePGetDatum(centroid);\n\n\t/* Create node for empty ranges only if it is a root node */\n\tout->nNodes = (in->level == 0) ? 5 : 4;\n\tout->nodeLabels = NULL;\t\t/* we don't need node labels */\n\n\tout->mapTuplesToNodes = palloc(sizeof(int) * in->nTuples);\n\tout->leafTupleDatums = palloc(sizeof(Datum) * in->nTuples);\n\n\t/*\n\t * Assign ranges to corresponding nodes according to quadrants relative to\n\t * \"centroid\" range.\n\t */\n\tfor (i = 0; i < in->nTuples; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(in->datums[i]);\n\t\tint16\t\tquadrant = getQuadrant(typcache, centroid, range);\n\n\t\tout->leafTupleDatums[i] = RangeTypePGetDatum(range);\n\t\tout->mapTuplesToNodes[i] = quadrant - 1;\n\t}\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "bound_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "185-193",
    "snippet": "static int\nbound_cmp(const void *a, const void *b, void *arg)\n{\n\tRangeBound *ba = (RangeBound *) a;\n\tRangeBound *bb = (RangeBound *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, ba, bb);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tbound_cmp(const void *a, const void *b, void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "ba",
            "bb"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int\tbound_cmp(const void *a, const void *b, void *arg);\n\nstatic int\nbound_cmp(const void *a, const void *b, void *arg)\n{\n\tRangeBound *ba = (RangeBound *) a;\n\tRangeBound *bb = (RangeBound *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, ba, bb);\n}"
  },
  {
    "function_name": "spg_range_quad_choose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "130-180",
    "snippet": "Datum\nspg_range_quad_choose(PG_FUNCTION_ARGS)\n{\n\tspgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0);\n\tspgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1);\n\tRangeType  *inRange = DatumGetRangeTypeP(in->datum),\n\t\t\t   *centroid;\n\tint16\t\tquadrant;\n\tTypeCacheEntry *typcache;\n\n\tif (in->allTheSame)\n\t{\n\t\tout->resultType = spgMatchNode;\n\t\t/* nodeN will be set by core */\n\t\tout->result.matchNode.levelAdd = 0;\n\t\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\t\tPG_RETURN_VOID();\n\t}\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(inRange));\n\n\t/*\n\t * A node with no centroid divides ranges purely on whether they're empty\n\t * or not. All empty ranges go to child node 0, all non-empty ranges go to\n\t * node 1.\n\t */\n\tif (!in->hasPrefix)\n\t{\n\t\tout->resultType = spgMatchNode;\n\t\tif (RangeIsEmpty(inRange))\n\t\t\tout->result.matchNode.nodeN = 0;\n\t\telse\n\t\t\tout->result.matchNode.nodeN = 1;\n\t\tout->result.matchNode.levelAdd = 1;\n\t\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\t\tPG_RETURN_VOID();\n\t}\n\n\tcentroid = DatumGetRangeTypeP(in->prefixDatum);\n\tquadrant = getQuadrant(typcache, centroid, inRange);\n\n\tAssert(quadrant <= in->nNodes);\n\n\t/* Select node matching to quadrant number */\n\tout->resultType = spgMatchNode;\n\tout->result.matchNode.nodeN = quadrant - 1;\n\tout->result.matchNode.levelAdd = 1;\n\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "inRange"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "quadrant <= in->nNodes"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getQuadrant",
          "args": [
            "typcache",
            "centroid",
            "inRange"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "getQuadrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
          "lines": "94-125",
          "snippet": "static int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/spgist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);",
            "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->prefixDatum"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "inRange"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "inRange"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(inRange)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "inRange"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "inRange"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "in->datum"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nDatum\nspg_range_quad_choose(PG_FUNCTION_ARGS)\n{\n\tspgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0);\n\tspgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1);\n\tRangeType  *inRange = DatumGetRangeTypeP(in->datum),\n\t\t\t   *centroid;\n\tint16\t\tquadrant;\n\tTypeCacheEntry *typcache;\n\n\tif (in->allTheSame)\n\t{\n\t\tout->resultType = spgMatchNode;\n\t\t/* nodeN will be set by core */\n\t\tout->result.matchNode.levelAdd = 0;\n\t\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\t\tPG_RETURN_VOID();\n\t}\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(inRange));\n\n\t/*\n\t * A node with no centroid divides ranges purely on whether they're empty\n\t * or not. All empty ranges go to child node 0, all non-empty ranges go to\n\t * node 1.\n\t */\n\tif (!in->hasPrefix)\n\t{\n\t\tout->resultType = spgMatchNode;\n\t\tif (RangeIsEmpty(inRange))\n\t\t\tout->result.matchNode.nodeN = 0;\n\t\telse\n\t\t\tout->result.matchNode.nodeN = 1;\n\t\tout->result.matchNode.levelAdd = 1;\n\t\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\t\tPG_RETURN_VOID();\n\t}\n\n\tcentroid = DatumGetRangeTypeP(in->prefixDatum);\n\tquadrant = getQuadrant(typcache, centroid, inRange);\n\n\tAssert(quadrant <= in->nNodes);\n\n\t/* Select node matching to quadrant number */\n\tout->resultType = spgMatchNode;\n\tout->result.matchNode.nodeN = quadrant - 1;\n\tout->result.matchNode.levelAdd = 1;\n\tout->result.matchNode.restDatum = RangeTypePGetDatum(inRange);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "getQuadrant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "94-125",
    "snippet": "static int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);",
      "static int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper",
            "&centroidUpper"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "tst",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nstatic int16 getQuadrant(TypeCacheEntry *typcache, RangeType *centroid,\n\t\t\tRangeType *tst);\nstatic int adjacent_cmp_bounds(TypeCacheEntry *typcache, RangeBound *arg,\n\t\t\t\t\tRangeBound *centroid);\n\nstatic int16\ngetQuadrant(TypeCacheEntry *typcache, RangeType *centroid, RangeType *tst)\n{\n\tRangeBound\tcentroidLower,\n\t\t\t\tcentroidUpper;\n\tbool\t\tcentroidEmpty;\n\tRangeBound\tlower,\n\t\t\t\tupper;\n\tbool\t\tempty;\n\n\trange_deserialize(typcache, centroid, &centroidLower, &centroidUpper,\n\t\t\t\t\t  &centroidEmpty);\n\trange_deserialize(typcache, tst, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn 5;\n\n\tif (range_cmp_bounds(typcache, &lower, &centroidLower) >= 0)\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tif (range_cmp_bounds(typcache, &upper, &centroidUpper) >= 0)\n\t\t\treturn 4;\n\t\telse\n\t\t\treturn 3;\n\t}\n}"
  },
  {
    "function_name": "spg_range_quad_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_spgist.c",
    "lines": "59-70",
    "snippet": "Datum\nspg_range_quad_config(PG_FUNCTION_ARGS)\n{\n\t/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */\n\tspgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(1);\n\n\tcfg->prefixType = ANYRANGEOID;\n\tcfg->labelType = VOIDOID;\t/* we don't need node labels */\n\tcfg->canReturnData = true;\n\tcfg->longValuesOK = false;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/spgist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/stratnum.h\"\n#include \"access/spgist.h\"\n#include \"postgres.h\"\n\nDatum\nspg_range_quad_config(PG_FUNCTION_ARGS)\n{\n\t/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */\n\tspgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(1);\n\n\tcfg->prefixType = ANYRANGEOID;\n\tcfg->labelType = VOIDOID;\t/* we don't need node labels */\n\tcfg->canReturnData = true;\n\tcfg->longValuesOK = false;\n\tPG_RETURN_VOID();\n}"
  }
]