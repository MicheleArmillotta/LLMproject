[
  {
    "function_name": "cleanup_tsquery_stopwords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "385-444",
    "snippet": "TSQuery\ncleanup_tsquery_stopwords(TSQuery in)\n{\n\tint32\t\tlen,\n\t\t\t\tlenstr,\n\t\t\t\tcommonlen,\n\t\t\t\ti;\n\tNODE\t   *root;\n\tint\t\t\tladd,\n\t\t\t\tradd;\n\tTSQuery\t\tout;\n\tQueryItem  *items;\n\tchar\t   *operands;\n\n\tif (in->size == 0)\n\t\treturn in;\n\n\t/* eliminate stop words */\n\troot = clean_stopword_intree(maketree(GETQUERY(in)), &ladd, &radd);\n\tif (root == NULL)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query contains only stop words or doesn't contain lexemes, ignored\")));\n\t\tout = palloc(HDRSIZETQ);\n\t\tout->size = 0;\n\t\tSET_VARSIZE(out, HDRSIZETQ);\n\t\treturn out;\n\t}\n\n\t/*\n\t * Build TSQuery from plain view\n\t */\n\n\tlenstr = calcstrlen(root);\n\titems = plaintree(root, &len);\n\tcommonlen = COMPUTESIZE(len, lenstr);\n\n\tout = palloc(commonlen);\n\tSET_VARSIZE(out, commonlen);\n\tout->size = len;\n\n\tmemcpy(GETQUERY(out), items, len * sizeof(QueryItem));\n\n\titems = GETQUERY(out);\n\toperands = GETOPERAND(out);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tQueryOperand *op = (QueryOperand *) &items[i];\n\n\t\tif (op->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tmemcpy(operands, GETOPERAND(in) + op->distance, op->length);\n\t\toperands[op->length] = '\\0';\n\t\top->distance = operands - GETOPERAND(out);\n\t\toperands += op->length + 1;\n\t}\n\n\treturn out;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "out"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "operands",
            "GETOPERAND(in) + op->distance",
            "op->length"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "in"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "out"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "out"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "GETQUERY(out)",
            "items",
            "len * sizeof(QueryItem)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "out"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "commonlen"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "commonlen"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPUTESIZE",
          "args": [
            "len",
            "lenstr"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plaintree",
          "args": [
            "root",
            "&len"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "plaintree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "95-111",
          "snippet": "static QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calcstrlen",
          "args": [
            "root"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "HDRSIZETQ"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "NOTICE",
            "(errmsg(\"text-search query contains only stop words or doesn't contain lexemes, ignored\"))"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"text-search query contains only stop words or doesn't contain lexemes, ignored\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_stopword_intree",
          "args": [
            "maketree(GETQUERY(in))",
            "&ladd",
            "&radd"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "clean_stopword_intree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "236-356",
          "snippet": "static NODE *\nclean_stopword_intree(NODE *node, int *ladd, int *radd)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* default output parameters indicate no change in parent distance */\n\t*ladd = *radd = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\telse if (node->valnode->type == QI_VALSTOP)\n\t{\n\t\tpfree(node);\n\t\treturn NULL;\n\t}\n\n\tAssert(node->valnode->type == QI_OPR);\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\t/* NOT doesn't change pattern width, so just report child distances */\n\t\tnode->right = clean_stopword_intree(node->right, ladd, radd);\n\t\tif (!node->right)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\t\tbool\t\tisphrase;\n\t\tint\t\t\tndistance,\n\t\t\t\t\tlladd,\n\t\t\t\t\tlradd,\n\t\t\t\t\trladd,\n\t\t\t\t\trradd;\n\n\t\t/* First, recurse */\n\t\tnode->left = clean_stopword_intree(node->left, &lladd, &lradd);\n\t\tnode->right = clean_stopword_intree(node->right, &rladd, &rradd);\n\n\t\t/* Check if current node is OP_PHRASE, get its distance */\n\t\tisphrase = (node->valnode->qoperator.oper == OP_PHRASE);\n\t\tndistance = isphrase ? node->valnode->qoperator.distance : 0;\n\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * When we collapse out a phrase node entirely, propagate its own\n\t\t\t * distance into both *ladd and *radd; it is the responsibility of\n\t\t\t * the parent node to count it only once.  Also, for a phrase\n\t\t\t * node, distances coming from children are summed and propagated\n\t\t\t * up to parent (we assume lladd == lradd and rladd == rradd, else\n\t\t\t * rule was broken at a lower level).  But if this isn't a phrase\n\t\t\t * node, take the larger of the two child distances; that\n\t\t\t * corresponds to what TS_execute will do in non-stopword cases.\n\t\t\t */\n\t\t\tif (isphrase)\n\t\t\t\t*ladd = *radd = lladd + ndistance + rladd;\n\t\t\telse\n\t\t\t\t*ladd = *radd = Max(lladd, rladd);\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\t/* Removing this operator and left subnode */\n\t\t\t/* lladd and lradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to left */\n\t\t\t\t*ladd = lladd + ndistance + rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the left subnode entirely */\n\t\t\t\t*ladd = rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\t/* Removing this operator and right subnode */\n\t\t\t/* rladd and rradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to right */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd + ndistance + rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the right subnode entirely */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd;\n\t\t\t}\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (isphrase)\n\t\t{\n\t\t\t/* Absorb appropriate corrections at this level */\n\t\t\tnode->valnode->qoperator.distance += lradd + rladd;\n\t\t\t/* Propagate up any unaccounted-for corrections */\n\t\t\t*ladd = lladd;\n\t\t\t*radd = rradd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We're keeping a non-phrase operator, so ladd/radd remain 0 */\n\t\t}\n\n\t\treturn res;\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nclean_stopword_intree(NODE *node, int *ladd, int *radd)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* default output parameters indicate no change in parent distance */\n\t*ladd = *radd = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\telse if (node->valnode->type == QI_VALSTOP)\n\t{\n\t\tpfree(node);\n\t\treturn NULL;\n\t}\n\n\tAssert(node->valnode->type == QI_OPR);\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\t/* NOT doesn't change pattern width, so just report child distances */\n\t\tnode->right = clean_stopword_intree(node->right, ladd, radd);\n\t\tif (!node->right)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\t\tbool\t\tisphrase;\n\t\tint\t\t\tndistance,\n\t\t\t\t\tlladd,\n\t\t\t\t\tlradd,\n\t\t\t\t\trladd,\n\t\t\t\t\trradd;\n\n\t\t/* First, recurse */\n\t\tnode->left = clean_stopword_intree(node->left, &lladd, &lradd);\n\t\tnode->right = clean_stopword_intree(node->right, &rladd, &rradd);\n\n\t\t/* Check if current node is OP_PHRASE, get its distance */\n\t\tisphrase = (node->valnode->qoperator.oper == OP_PHRASE);\n\t\tndistance = isphrase ? node->valnode->qoperator.distance : 0;\n\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * When we collapse out a phrase node entirely, propagate its own\n\t\t\t * distance into both *ladd and *radd; it is the responsibility of\n\t\t\t * the parent node to count it only once.  Also, for a phrase\n\t\t\t * node, distances coming from children are summed and propagated\n\t\t\t * up to parent (we assume lladd == lradd and rladd == rradd, else\n\t\t\t * rule was broken at a lower level).  But if this isn't a phrase\n\t\t\t * node, take the larger of the two child distances; that\n\t\t\t * corresponds to what TS_execute will do in non-stopword cases.\n\t\t\t */\n\t\t\tif (isphrase)\n\t\t\t\t*ladd = *radd = lladd + ndistance + rladd;\n\t\t\telse\n\t\t\t\t*ladd = *radd = Max(lladd, rladd);\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\t/* Removing this operator and left subnode */\n\t\t\t/* lladd and lradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to left */\n\t\t\t\t*ladd = lladd + ndistance + rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the left subnode entirely */\n\t\t\t\t*ladd = rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\t/* Removing this operator and right subnode */\n\t\t\t/* rladd and rradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to right */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd + ndistance + rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the right subnode entirely */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd;\n\t\t\t}\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (isphrase)\n\t\t{\n\t\t\t/* Absorb appropriate corrections at this level */\n\t\t\tnode->valnode->qoperator.distance += lradd + rladd;\n\t\t\t/* Propagate up any unaccounted-for corrections */\n\t\t\t*ladd = lladd;\n\t\t\t*radd = rradd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We're keeping a non-phrase operator, so ladd/radd remain 0 */\n\t\t}\n\n\t\treturn res;\n\t}\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maketree",
          "args": [
            "GETQUERY(in)"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "maketree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "31-48",
          "snippet": "static NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "in"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\ncleanup_tsquery_stopwords(TSQuery in)\n{\n\tint32\t\tlen,\n\t\t\t\tlenstr,\n\t\t\t\tcommonlen,\n\t\t\t\ti;\n\tNODE\t   *root;\n\tint\t\t\tladd,\n\t\t\t\tradd;\n\tTSQuery\t\tout;\n\tQueryItem  *items;\n\tchar\t   *operands;\n\n\tif (in->size == 0)\n\t\treturn in;\n\n\t/* eliminate stop words */\n\troot = clean_stopword_intree(maketree(GETQUERY(in)), &ladd, &radd);\n\tif (root == NULL)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query contains only stop words or doesn't contain lexemes, ignored\")));\n\t\tout = palloc(HDRSIZETQ);\n\t\tout->size = 0;\n\t\tSET_VARSIZE(out, HDRSIZETQ);\n\t\treturn out;\n\t}\n\n\t/*\n\t * Build TSQuery from plain view\n\t */\n\n\tlenstr = calcstrlen(root);\n\titems = plaintree(root, &len);\n\tcommonlen = COMPUTESIZE(len, lenstr);\n\n\tout = palloc(commonlen);\n\tSET_VARSIZE(out, commonlen);\n\tout->size = len;\n\n\tmemcpy(GETQUERY(out), items, len * sizeof(QueryItem));\n\n\titems = GETQUERY(out);\n\toperands = GETOPERAND(out);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tQueryOperand *op = (QueryOperand *) &items[i];\n\n\t\tif (op->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tmemcpy(operands, GETOPERAND(in) + op->distance, op->length);\n\t\toperands[op->length] = '\\0';\n\t\top->distance = operands - GETOPERAND(out);\n\t\toperands += op->length + 1;\n\t}\n\n\treturn out;\n}"
  },
  {
    "function_name": "calcstrlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "361-380",
    "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calcstrlen",
          "args": [
            "node->left"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "node->valnode->type == QI_OPR"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "clean_stopword_intree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "236-356",
    "snippet": "static NODE *\nclean_stopword_intree(NODE *node, int *ladd, int *radd)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* default output parameters indicate no change in parent distance */\n\t*ladd = *radd = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\telse if (node->valnode->type == QI_VALSTOP)\n\t{\n\t\tpfree(node);\n\t\treturn NULL;\n\t}\n\n\tAssert(node->valnode->type == QI_OPR);\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\t/* NOT doesn't change pattern width, so just report child distances */\n\t\tnode->right = clean_stopword_intree(node->right, ladd, radd);\n\t\tif (!node->right)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\t\tbool\t\tisphrase;\n\t\tint\t\t\tndistance,\n\t\t\t\t\tlladd,\n\t\t\t\t\tlradd,\n\t\t\t\t\trladd,\n\t\t\t\t\trradd;\n\n\t\t/* First, recurse */\n\t\tnode->left = clean_stopword_intree(node->left, &lladd, &lradd);\n\t\tnode->right = clean_stopword_intree(node->right, &rladd, &rradd);\n\n\t\t/* Check if current node is OP_PHRASE, get its distance */\n\t\tisphrase = (node->valnode->qoperator.oper == OP_PHRASE);\n\t\tndistance = isphrase ? node->valnode->qoperator.distance : 0;\n\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * When we collapse out a phrase node entirely, propagate its own\n\t\t\t * distance into both *ladd and *radd; it is the responsibility of\n\t\t\t * the parent node to count it only once.  Also, for a phrase\n\t\t\t * node, distances coming from children are summed and propagated\n\t\t\t * up to parent (we assume lladd == lradd and rladd == rradd, else\n\t\t\t * rule was broken at a lower level).  But if this isn't a phrase\n\t\t\t * node, take the larger of the two child distances; that\n\t\t\t * corresponds to what TS_execute will do in non-stopword cases.\n\t\t\t */\n\t\t\tif (isphrase)\n\t\t\t\t*ladd = *radd = lladd + ndistance + rladd;\n\t\t\telse\n\t\t\t\t*ladd = *radd = Max(lladd, rladd);\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\t/* Removing this operator and left subnode */\n\t\t\t/* lladd and lradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to left */\n\t\t\t\t*ladd = lladd + ndistance + rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the left subnode entirely */\n\t\t\t\t*ladd = rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\t/* Removing this operator and right subnode */\n\t\t\t/* rladd and rradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to right */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd + ndistance + rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the right subnode entirely */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd;\n\t\t\t}\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (isphrase)\n\t\t{\n\t\t\t/* Absorb appropriate corrections at this level */\n\t\t\tnode->valnode->qoperator.distance += lradd + rladd;\n\t\t\t/* Propagate up any unaccounted-for corrections */\n\t\t\t*ladd = lladd;\n\t\t\t*radd = rradd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We're keeping a non-phrase operator, so ladd/radd remain 0 */\n\t\t}\n\n\t\treturn res;\n\t}\n\treturn node;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "node"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freetree",
          "args": [
            "node"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "freetree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "113-126",
          "snippet": "static void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "lladd",
            "rladd"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_stopword_intree",
          "args": [
            "node->right",
            "&rladd",
            "&rradd"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "clean_stopword_intree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "236-356",
          "snippet": "static NODE *\nclean_stopword_intree(NODE *node, int *ladd, int *radd)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* default output parameters indicate no change in parent distance */\n\t*ladd = *radd = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\telse if (node->valnode->type == QI_VALSTOP)\n\t{\n\t\tpfree(node);\n\t\treturn NULL;\n\t}\n\n\tAssert(node->valnode->type == QI_OPR);\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\t/* NOT doesn't change pattern width, so just report child distances */\n\t\tnode->right = clean_stopword_intree(node->right, ladd, radd);\n\t\tif (!node->right)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\t\tbool\t\tisphrase;\n\t\tint\t\t\tndistance,\n\t\t\t\t\tlladd,\n\t\t\t\t\tlradd,\n\t\t\t\t\trladd,\n\t\t\t\t\trradd;\n\n\t\t/* First, recurse */\n\t\tnode->left = clean_stopword_intree(node->left, &lladd, &lradd);\n\t\tnode->right = clean_stopword_intree(node->right, &rladd, &rradd);\n\n\t\t/* Check if current node is OP_PHRASE, get its distance */\n\t\tisphrase = (node->valnode->qoperator.oper == OP_PHRASE);\n\t\tndistance = isphrase ? node->valnode->qoperator.distance : 0;\n\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * When we collapse out a phrase node entirely, propagate its own\n\t\t\t * distance into both *ladd and *radd; it is the responsibility of\n\t\t\t * the parent node to count it only once.  Also, for a phrase\n\t\t\t * node, distances coming from children are summed and propagated\n\t\t\t * up to parent (we assume lladd == lradd and rladd == rradd, else\n\t\t\t * rule was broken at a lower level).  But if this isn't a phrase\n\t\t\t * node, take the larger of the two child distances; that\n\t\t\t * corresponds to what TS_execute will do in non-stopword cases.\n\t\t\t */\n\t\t\tif (isphrase)\n\t\t\t\t*ladd = *radd = lladd + ndistance + rladd;\n\t\t\telse\n\t\t\t\t*ladd = *radd = Max(lladd, rladd);\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\t/* Removing this operator and left subnode */\n\t\t\t/* lladd and lradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to left */\n\t\t\t\t*ladd = lladd + ndistance + rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the left subnode entirely */\n\t\t\t\t*ladd = rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\t/* Removing this operator and right subnode */\n\t\t\t/* rladd and rradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to right */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd + ndistance + rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the right subnode entirely */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd;\n\t\t\t}\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (isphrase)\n\t\t{\n\t\t\t/* Absorb appropriate corrections at this level */\n\t\t\tnode->valnode->qoperator.distance += lradd + rladd;\n\t\t\t/* Propagate up any unaccounted-for corrections */\n\t\t\t*ladd = lladd;\n\t\t\t*radd = rradd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We're keeping a non-phrase operator, so ladd/radd remain 0 */\n\t\t}\n\n\t\treturn res;\n\t}\n\treturn node;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "node->valnode->type == QI_OPR"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nclean_stopword_intree(NODE *node, int *ladd, int *radd)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* default output parameters indicate no change in parent distance */\n\t*ladd = *radd = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\telse if (node->valnode->type == QI_VALSTOP)\n\t{\n\t\tpfree(node);\n\t\treturn NULL;\n\t}\n\n\tAssert(node->valnode->type == QI_OPR);\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\t/* NOT doesn't change pattern width, so just report child distances */\n\t\tnode->right = clean_stopword_intree(node->right, ladd, radd);\n\t\tif (!node->right)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\t\tbool\t\tisphrase;\n\t\tint\t\t\tndistance,\n\t\t\t\t\tlladd,\n\t\t\t\t\tlradd,\n\t\t\t\t\trladd,\n\t\t\t\t\trradd;\n\n\t\t/* First, recurse */\n\t\tnode->left = clean_stopword_intree(node->left, &lladd, &lradd);\n\t\tnode->right = clean_stopword_intree(node->right, &rladd, &rradd);\n\n\t\t/* Check if current node is OP_PHRASE, get its distance */\n\t\tisphrase = (node->valnode->qoperator.oper == OP_PHRASE);\n\t\tndistance = isphrase ? node->valnode->qoperator.distance : 0;\n\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * When we collapse out a phrase node entirely, propagate its own\n\t\t\t * distance into both *ladd and *radd; it is the responsibility of\n\t\t\t * the parent node to count it only once.  Also, for a phrase\n\t\t\t * node, distances coming from children are summed and propagated\n\t\t\t * up to parent (we assume lladd == lradd and rladd == rradd, else\n\t\t\t * rule was broken at a lower level).  But if this isn't a phrase\n\t\t\t * node, take the larger of the two child distances; that\n\t\t\t * corresponds to what TS_execute will do in non-stopword cases.\n\t\t\t */\n\t\t\tif (isphrase)\n\t\t\t\t*ladd = *radd = lladd + ndistance + rladd;\n\t\t\telse\n\t\t\t\t*ladd = *radd = Max(lladd, rladd);\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\t/* Removing this operator and left subnode */\n\t\t\t/* lladd and lradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to left */\n\t\t\t\t*ladd = lladd + ndistance + rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the left subnode entirely */\n\t\t\t\t*ladd = rladd;\n\t\t\t\t*radd = rradd;\n\t\t\t}\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\t/* Removing this operator and right subnode */\n\t\t\t/* rladd and rradd are equal/redundant, don't count both */\n\t\t\tif (isphrase)\n\t\t\t{\n\t\t\t\t/* operator's own distance must propagate to right */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd + ndistance + rradd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* at non-phrase op, just forget the right subnode entirely */\n\t\t\t\t*ladd = lladd;\n\t\t\t\t*radd = lradd;\n\t\t\t}\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (isphrase)\n\t\t{\n\t\t\t/* Absorb appropriate corrections at this level */\n\t\t\tnode->valnode->qoperator.distance += lradd + rladd;\n\t\t\t/* Propagate up any unaccounted-for corrections */\n\t\t\t*ladd = lladd;\n\t\t\t*radd = rradd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We're keeping a non-phrase operator, so ladd/radd remain 0 */\n\t\t}\n\n\t\treturn res;\n\t}\n\treturn node;\n}"
  },
  {
    "function_name": "clean_NOT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "188-194",
    "snippet": "QueryItem *\nclean_NOT(QueryItem *ptr, int *len)\n{\n\tNODE\t   *root = maketree(ptr);\n\n\treturn plaintree(clean_NOT_intree(root), len);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plaintree",
          "args": [
            "clean_NOT_intree(root)",
            "len"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "plaintree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "95-111",
          "snippet": "static QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_NOT_intree",
          "args": [
            "root"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "clean_NOT_intree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "134-186",
          "snippet": "static NODE *\nclean_NOT_intree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tfreetree(node);\n\t\treturn NULL;\n\t}\n\n\t/* operator & or | */\n\tif (node->valnode->qoperator.oper == OP_OR)\n\t{\n\t\tif ((node->left = clean_NOT_intree(node->left)) == NULL ||\n\t\t\t(node->right = clean_NOT_intree(node->right)) == NULL)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\n\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE);\n\n\t\tnode->left = clean_NOT_intree(node->left);\n\t\tnode->right = clean_NOT_intree(node->right);\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\tpfree(node);\n\t\t\tres = NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\treturn res;\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nclean_NOT_intree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tfreetree(node);\n\t\treturn NULL;\n\t}\n\n\t/* operator & or | */\n\tif (node->valnode->qoperator.oper == OP_OR)\n\t{\n\t\tif ((node->left = clean_NOT_intree(node->left)) == NULL ||\n\t\t\t(node->right = clean_NOT_intree(node->right)) == NULL)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\n\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE);\n\n\t\tnode->left = clean_NOT_intree(node->left);\n\t\tnode->right = clean_NOT_intree(node->right);\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\tpfree(node);\n\t\t\tres = NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\treturn res;\n\t}\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maketree",
          "args": [
            "ptr"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "maketree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "31-48",
          "snippet": "static NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQueryItem *\nclean_NOT(QueryItem *ptr, int *len)\n{\n\tNODE\t   *root = maketree(ptr);\n\n\treturn plaintree(clean_NOT_intree(root), len);\n}"
  },
  {
    "function_name": "clean_NOT_intree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "134-186",
    "snippet": "static NODE *\nclean_NOT_intree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tfreetree(node);\n\t\treturn NULL;\n\t}\n\n\t/* operator & or | */\n\tif (node->valnode->qoperator.oper == OP_OR)\n\t{\n\t\tif ((node->left = clean_NOT_intree(node->left)) == NULL ||\n\t\t\t(node->right = clean_NOT_intree(node->right)) == NULL)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\n\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE);\n\n\t\tnode->left = clean_NOT_intree(node->left);\n\t\tnode->right = clean_NOT_intree(node->right);\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\tpfree(node);\n\t\t\tres = NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\treturn res;\n\t}\n\treturn node;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "node"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_NOT_intree",
          "args": [
            "node->right"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "clean_NOT_intree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "134-186",
          "snippet": "static NODE *\nclean_NOT_intree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tfreetree(node);\n\t\treturn NULL;\n\t}\n\n\t/* operator & or | */\n\tif (node->valnode->qoperator.oper == OP_OR)\n\t{\n\t\tif ((node->left = clean_NOT_intree(node->left)) == NULL ||\n\t\t\t(node->right = clean_NOT_intree(node->right)) == NULL)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\n\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE);\n\n\t\tnode->left = clean_NOT_intree(node->left);\n\t\tnode->right = clean_NOT_intree(node->right);\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\tpfree(node);\n\t\t\tres = NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\treturn res;\n\t}\n\treturn node;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freetree",
          "args": [
            "node"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "freetree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "113-126",
          "snippet": "static void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nclean_NOT_intree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (node->valnode->type == QI_VAL)\n\t\treturn node;\n\n\tif (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tfreetree(node);\n\t\treturn NULL;\n\t}\n\n\t/* operator & or | */\n\tif (node->valnode->qoperator.oper == OP_OR)\n\t{\n\t\tif ((node->left = clean_NOT_intree(node->left)) == NULL ||\n\t\t\t(node->right = clean_NOT_intree(node->right)) == NULL)\n\t\t{\n\t\t\tfreetree(node);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tNODE\t   *res = node;\n\n\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t   node->valnode->qoperator.oper == OP_PHRASE);\n\n\t\tnode->left = clean_NOT_intree(node->left);\n\t\tnode->right = clean_NOT_intree(node->right);\n\t\tif (node->left == NULL && node->right == NULL)\n\t\t{\n\t\t\tpfree(node);\n\t\t\tres = NULL;\n\t\t}\n\t\telse if (node->left == NULL)\n\t\t{\n\t\t\tres = node->right;\n\t\t\tpfree(node);\n\t\t}\n\t\telse if (node->right == NULL)\n\t\t{\n\t\t\tres = node->left;\n\t\t\tpfree(node);\n\t\t}\n\t\treturn res;\n\t}\n\treturn node;\n}"
  },
  {
    "function_name": "freetree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "113-126",
    "snippet": "static void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "node"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freetree",
          "args": [
            "node->right"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "freetree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "113-126",
          "snippet": "static void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nfreetree(NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (!node)\n\t\treturn;\n\tif (node->left)\n\t\tfreetree(node->left);\n\tif (node->right)\n\t\tfreetree(node->right);\n\tpfree(node);\n}"
  },
  {
    "function_name": "plaintree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "95-111",
    "snippet": "static QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plainnode",
          "args": [
            "&pl",
            "root"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "plainnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "60-90",
          "snippet": "static void\nplainnode(PLAINTREE *state, NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (state->cur == state->len)\n\t{\n\t\tstate->len *= 2;\n\t\tstate->ptr = (QueryItem *) repalloc((void *) state->ptr, state->len * sizeof(QueryItem));\n\t}\n\tmemcpy((void *) &(state->ptr[state->cur]), (void *) node->valnode, sizeof(QueryItem));\n\tif (node->valnode->type == QI_VAL)\n\t\tstate->cur++;\n\telse if (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tstate->ptr[state->cur].qoperator.left = 1;\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t}\n\telse\n\t{\n\t\tint\t\t\tcur = state->cur;\n\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t\tstate->ptr[cur].qoperator.left = state->cur - cur;\n\t\tplainnode(state, node->left);\n\t}\n\tpfree(node);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nplainnode(PLAINTREE *state, NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (state->cur == state->len)\n\t{\n\t\tstate->len *= 2;\n\t\tstate->ptr = (QueryItem *) repalloc((void *) state->ptr, state->len * sizeof(QueryItem));\n\t}\n\tmemcpy((void *) &(state->ptr[state->cur]), (void *) node->valnode, sizeof(QueryItem));\n\tif (node->valnode->type == QI_VAL)\n\t\tstate->cur++;\n\telse if (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tstate->ptr[state->cur].qoperator.left = 1;\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t}\n\telse\n\t{\n\t\tint\t\t\tcur = state->cur;\n\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t\tstate->ptr[cur].qoperator.left = state->cur - cur;\n\t\tplainnode(state, node->left);\n\t}\n\tpfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "pl.len * sizeof(QueryItem)"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QueryItem *\nplaintree(NODE *root, int *len)\n{\n\tPLAINTREE\tpl;\n\n\tpl.cur = 0;\n\tpl.len = 16;\n\tif (root && (root->valnode->type == QI_VAL || root->valnode->type == QI_OPR))\n\t{\n\t\tpl.ptr = (QueryItem *) palloc(pl.len * sizeof(QueryItem));\n\t\tplainnode(&pl, root);\n\t}\n\telse\n\t\tpl.ptr = NULL;\n\t*len = pl.cur;\n\treturn pl.ptr;\n}"
  },
  {
    "function_name": "plainnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "60-90",
    "snippet": "static void\nplainnode(PLAINTREE *state, NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (state->cur == state->len)\n\t{\n\t\tstate->len *= 2;\n\t\tstate->ptr = (QueryItem *) repalloc((void *) state->ptr, state->len * sizeof(QueryItem));\n\t}\n\tmemcpy((void *) &(state->ptr[state->cur]), (void *) node->valnode, sizeof(QueryItem));\n\tif (node->valnode->type == QI_VAL)\n\t\tstate->cur++;\n\telse if (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tstate->ptr[state->cur].qoperator.left = 1;\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t}\n\telse\n\t{\n\t\tint\t\t\tcur = state->cur;\n\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t\tstate->ptr[cur].qoperator.left = state->cur - cur;\n\t\tplainnode(state, node->left);\n\t}\n\tpfree(node);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "node"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plainnode",
          "args": [
            "state",
            "node->left"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "plainnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "60-90",
          "snippet": "static void\nplainnode(PLAINTREE *state, NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (state->cur == state->len)\n\t{\n\t\tstate->len *= 2;\n\t\tstate->ptr = (QueryItem *) repalloc((void *) state->ptr, state->len * sizeof(QueryItem));\n\t}\n\tmemcpy((void *) &(state->ptr[state->cur]), (void *) node->valnode, sizeof(QueryItem));\n\tif (node->valnode->type == QI_VAL)\n\t\tstate->cur++;\n\telse if (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tstate->ptr[state->cur].qoperator.left = 1;\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t}\n\telse\n\t{\n\t\tint\t\t\tcur = state->cur;\n\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t\tstate->ptr[cur].qoperator.left = state->cur - cur;\n\t\tplainnode(state, node->left);\n\t}\n\tpfree(node);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) &(state->ptr[state->cur])",
            "(void *) node->valnode",
            "sizeof(QueryItem)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "(void *) state->ptr",
            "state->len * sizeof(QueryItem)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic void\nplainnode(PLAINTREE *state, NODE *node)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (state->cur == state->len)\n\t{\n\t\tstate->len *= 2;\n\t\tstate->ptr = (QueryItem *) repalloc((void *) state->ptr, state->len * sizeof(QueryItem));\n\t}\n\tmemcpy((void *) &(state->ptr[state->cur]), (void *) node->valnode, sizeof(QueryItem));\n\tif (node->valnode->type == QI_VAL)\n\t\tstate->cur++;\n\telse if (node->valnode->qoperator.oper == OP_NOT)\n\t{\n\t\tstate->ptr[state->cur].qoperator.left = 1;\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t}\n\telse\n\t{\n\t\tint\t\t\tcur = state->cur;\n\n\t\tstate->cur++;\n\t\tplainnode(state, node->right);\n\t\tstate->ptr[cur].qoperator.left = state->cur - cur;\n\t\tplainnode(state, node->left);\n\t}\n\tpfree(node);\n}"
  },
  {
    "function_name": "maketree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
    "lines": "31-48",
    "snippet": "static NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maketree",
          "args": [
            "in + in->qoperator.left"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "maketree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "31-48",
          "snippet": "static NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(NODE)"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic NODE *\nmaketree(QueryItem *in)\n{\n\tNODE\t   *node = (NODE *) palloc(sizeof(NODE));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\tnode->right = node->left = NULL;\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->right = maketree(in + 1);\n\t\tif (in->qoperator.oper != OP_NOT)\n\t\t\tnode->left = maketree(in + in->qoperator.left);\n\t}\n\treturn node;\n}"
  }
]