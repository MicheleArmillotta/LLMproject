[
  {
    "function_name": "inet_hist_match_divider",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "937-971",
    "snippet": "static int\ninet_hist_match_divider(inet *boundary, inet *query, int opr_codenum)\n{\n\tif (ip_family(boundary) == ip_family(query) &&\n\t\tinet_masklen_inclusion_cmp(boundary, query, opr_codenum) == 0)\n\t{\n\t\tint\t\t\tmin_bits,\n\t\t\t\t\tdecisive_bits;\n\n\t\tmin_bits = Min(ip_bits(boundary), ip_bits(query));\n\n\t\t/*\n\t\t * Set decisive_bits to the masklen of the one that should contain the\n\t\t * other according to the operator.\n\t\t */\n\t\tif (opr_codenum < 0)\n\t\t\tdecisive_bits = ip_bits(boundary);\n\t\telse if (opr_codenum > 0)\n\t\t\tdecisive_bits = ip_bits(query);\n\t\telse\n\t\t\tdecisive_bits = min_bits;\n\n\t\t/*\n\t\t * Now return the number of non-common decisive bits.  (This will be\n\t\t * zero if the boundary and query in fact match, else positive.)\n\t\t */\n\t\tif (min_bits > 0)\n\t\t\treturn decisive_bits - bitncommon(ip_addr(boundary),\n\t\t\t\t\t\t\t\t\t\t\t  ip_addr(query),\n\t\t\t\t\t\t\t\t\t\t\t  min_bits);\n\t\treturn decisive_bits;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "ip_addr(boundary)",
            "ip_addr(query)",
            "min_bits"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "query"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "boundary"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "boundary"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "ip_bits(boundary)",
            "ip_bits(query)"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "boundary"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_masklen_inclusion_cmp",
          "args": [
            "boundary",
            "query",
            "opr_codenum"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "inet_masklen_inclusion_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "903-925",
          "snippet": "static int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "query"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "boundary"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_hist_match_divider(inet *boundary, inet *query, int opr_codenum)\n{\n\tif (ip_family(boundary) == ip_family(query) &&\n\t\tinet_masklen_inclusion_cmp(boundary, query, opr_codenum) == 0)\n\t{\n\t\tint\t\t\tmin_bits,\n\t\t\t\t\tdecisive_bits;\n\n\t\tmin_bits = Min(ip_bits(boundary), ip_bits(query));\n\n\t\t/*\n\t\t * Set decisive_bits to the masklen of the one that should contain the\n\t\t * other according to the operator.\n\t\t */\n\t\tif (opr_codenum < 0)\n\t\t\tdecisive_bits = ip_bits(boundary);\n\t\telse if (opr_codenum > 0)\n\t\t\tdecisive_bits = ip_bits(query);\n\t\telse\n\t\t\tdecisive_bits = min_bits;\n\n\t\t/*\n\t\t * Now return the number of non-common decisive bits.  (This will be\n\t\t * zero if the boundary and query in fact match, else positive.)\n\t\t */\n\t\tif (min_bits > 0)\n\t\t\treturn decisive_bits - bitncommon(ip_addr(boundary),\n\t\t\t\t\t\t\t\t\t\t\t  ip_addr(query),\n\t\t\t\t\t\t\t\t\t\t\t  min_bits);\n\t\treturn decisive_bits;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "inet_masklen_inclusion_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "903-925",
    "snippet": "static int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "right"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "left"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}"
  },
  {
    "function_name": "inet_inclusion_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "877-893",
    "snippet": "static int\ninet_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tif (ip_family(left) == ip_family(right))\n\t{\n\t\tint\t\t\torder;\n\n\t\torder = bitncmp(ip_addr(left), ip_addr(right),\n\t\t\t\t\t\tMin(ip_bits(left), ip_bits(right)));\n\t\tif (order != 0)\n\t\t\treturn order;\n\n\t\treturn inet_masklen_inclusion_cmp(left, right, opr_codenum);\n\t}\n\n\treturn ip_family(left) - ip_family(right);\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "right"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "left"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_masklen_inclusion_cmp",
          "args": [
            "left",
            "right",
            "opr_codenum"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "inet_masklen_inclusion_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "903-925",
          "snippet": "static int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_masklen_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tint\t\t\torder;\n\n\torder = (int) ip_bits(left) - (int) ip_bits(right);\n\n\t/*\n\t * Return 0 if the operator would accept this combination of masklens.\n\t * Note that opr_codenum zero (overlaps) will accept all cases.\n\t */\n\tif ((order > 0 && opr_codenum >= 0) ||\n\t\t(order == 0 && opr_codenum >= -1 && opr_codenum <= 1) ||\n\t\t(order < 0 && opr_codenum <= 0))\n\t\treturn 0;\n\n\t/*\n\t * Otherwise, return a negative value for sup/supeq (notionally, the RHS\n\t * needs to have a larger masklen than it has, which would make it sort\n\t * later), or a positive value for sub/subeq (vice versa).\n\t */\n\treturn opr_codenum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitncmp",
          "args": [
            "ip_addr(left)",
            "ip_addr(right)",
            "Min(ip_bits(left), ip_bits(right))"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "bitncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "976-1003",
          "snippet": "int\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "ip_bits(left)",
            "ip_bits(right)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "right"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "left"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "right"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "left"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "right"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "left"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tif (ip_family(left) == ip_family(right))\n\t{\n\t\tint\t\t\torder;\n\n\t\torder = bitncmp(ip_addr(left), ip_addr(right),\n\t\t\t\t\t\tMin(ip_bits(left), ip_bits(right)));\n\t\tif (order != 0)\n\t\t\treturn order;\n\n\t\treturn inet_masklen_inclusion_cmp(left, right, opr_codenum);\n\t}\n\n\treturn ip_family(left) - ip_family(right);\n}"
  },
  {
    "function_name": "inet_opr_codenum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "834-854",
    "snippet": "static int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static int\tinet_opr_codenum(Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator %u for inet selectivity\"",
            "operator"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}"
  },
  {
    "function_name": "inet_semi_join_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "791-824",
    "snippet": "static Selectivity\ninet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum)\n{\n\tif (mcv_exists)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < mcv_nvalues; i++)\n\t\t{\n\t\t\tif (DatumGetBool(FunctionCall2(proc,\n\t\t\t\t\t\t\t\t\t\t   lhs_value,\n\t\t\t\t\t\t\t\t\t\t   mcv_values[i])))\n\t\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\tif (hist_exists && hist_weight > 0)\n\t{\n\t\tSelectivity hist_selec;\n\n\t\t/* Commute operator, since we're passing lhs_value on the right */\n\t\thist_selec = inet_hist_value_sel(hist_values, hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t lhs_value, -opr_codenum);\n\n\t\tif (hist_selec > 0)\n\t\t\treturn Min(1.0, hist_weight * hist_selec);\n\t}\n\n\treturn 0.0;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);",
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "1.0",
            "hist_weight * hist_selec"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_hist_value_sel",
          "args": [
            "hist_values",
            "hist_nvalues",
            "lhs_value",
            "-opr_codenum"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_value_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "602-663",
          "snippet": "static Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2(proc,\n\t\t\t\t\t\t\t\t\t\t   lhs_value,\n\t\t\t\t\t\t\t\t\t\t   mcv_values[i])"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2",
          "args": [
            "proc",
            "lhs_value",
            "mcv_values[i]"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum)\n{\n\tif (mcv_exists)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < mcv_nvalues; i++)\n\t\t{\n\t\t\tif (DatumGetBool(FunctionCall2(proc,\n\t\t\t\t\t\t\t\t\t\t   lhs_value,\n\t\t\t\t\t\t\t\t\t\t   mcv_values[i])))\n\t\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\tif (hist_exists && hist_weight > 0)\n\t{\n\t\tSelectivity hist_selec;\n\n\t\t/* Commute operator, since we're passing lhs_value on the right */\n\t\thist_selec = inet_hist_value_sel(hist_values, hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t lhs_value, -opr_codenum);\n\n\t\tif (hist_selec > 0)\n\t\t\treturn Min(1.0, hist_weight * hist_selec);\n\t}\n\n\treturn 0.0;\n}"
  },
  {
    "function_name": "inet_hist_inclusion_join_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "740-765",
    "snippet": "static Selectivity\ninet_hist_inclusion_join_sel(Datum *hist1_values, int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum)\n{\n\tdouble\t\tmatch = 0.0;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\n\tif (hist2_nvalues <= 2)\n\t\treturn 0.0;\t\t\t\t/* no interior histogram elements */\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (hist2_nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\tn = 0;\n\tfor (i = 1; i < hist2_nvalues - 1; i += k)\n\t{\n\t\tmatch += inet_hist_value_sel(hist1_values, hist1_nvalues,\n\t\t\t\t\t\t\t\t\t hist2_values[i], opr_codenum);\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_CONSIDERED_ELEMS 1024"
    ],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_hist_value_sel",
          "args": [
            "hist1_values",
            "hist1_nvalues",
            "hist2_values[i]",
            "opr_codenum"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_value_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "602-663",
          "snippet": "static Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_inclusion_join_sel(Datum *hist1_values, int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum)\n{\n\tdouble\t\tmatch = 0.0;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\n\tif (hist2_nvalues <= 2)\n\t\treturn 0.0;\t\t\t\t/* no interior histogram elements */\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (hist2_nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\tn = 0;\n\tfor (i = 1; i < hist2_nvalues - 1; i += k)\n\t{\n\t\tmatch += inet_hist_value_sel(hist1_values, hist1_nvalues,\n\t\t\t\t\t\t\t\t\t hist2_values[i], opr_codenum);\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
  },
  {
    "function_name": "inet_mcv_hist_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "703-724",
    "snippet": "static Selectivity\ninet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers, int mcv_nvalues,\n\t\t\t\t  Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum)\n{\n\tSelectivity selec = 0.0;\n\tint\t\t\ti;\n\n\t/*\n\t * We'll call inet_hist_value_selec with the histogram on the left, so we\n\t * must commute the operator.\n\t */\n\topr_codenum = -opr_codenum;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tselec += mcv_numbers[i] *\n\t\t\tinet_hist_value_sel(hist_values, hist_nvalues, mcv_values[i],\n\t\t\t\t\t\t\t\topr_codenum);\n\t}\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);",
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_hist_value_sel",
          "args": [
            "hist_values",
            "hist_nvalues",
            "mcv_values[i]",
            "opr_codenum"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_value_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "602-663",
          "snippet": "static Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers, int mcv_nvalues,\n\t\t\t\t  Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum)\n{\n\tSelectivity selec = 0.0;\n\tint\t\t\ti;\n\n\t/*\n\t * We'll call inet_hist_value_selec with the histogram on the left, so we\n\t * must commute the operator.\n\t */\n\topr_codenum = -opr_codenum;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tselec += mcv_numbers[i] *\n\t\t\tinet_hist_value_sel(hist_values, hist_nvalues, mcv_values[i],\n\t\t\t\t\t\t\t\topr_codenum);\n\t}\n\treturn selec;\n}"
  },
  {
    "function_name": "inet_mcv_join_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "671-692",
    "snippet": "static Selectivity\ninet_mcv_join_sel(Datum *mcv1_values, float4 *mcv1_numbers, int mcv1_nvalues,\n\t\t\t\t  Datum *mcv2_values, float4 *mcv2_numbers, int mcv2_nvalues,\n\t\t\t\t  Oid operator)\n{\n\tSelectivity selec = 0.0;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tfmgr_info(get_opcode(operator), &proc);\n\n\tfor (i = 0; i < mcv1_nvalues; i++)\n\t{\n\t\tfor (j = 0; j < mcv2_nvalues; j++)\n\t\t\tif (DatumGetBool(FunctionCall2(&proc,\n\t\t\t\t\t\t\t\t\t\t   mcv1_values[i],\n\t\t\t\t\t\t\t\t\t\t   mcv2_values[j])))\n\t\t\t\tselec += mcv1_numbers[i] * mcv2_numbers[j];\n\t}\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static int\tinet_opr_codenum(Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2(&proc,\n\t\t\t\t\t\t\t\t\t\t   mcv1_values[i],\n\t\t\t\t\t\t\t\t\t\t   mcv2_values[j])"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2",
          "args": [
            "&proc",
            "mcv1_values[i]",
            "mcv2_values[j]"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(operator)",
            "&proc"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic Selectivity\ninet_mcv_join_sel(Datum *mcv1_values, float4 *mcv1_numbers, int mcv1_nvalues,\n\t\t\t\t  Datum *mcv2_values, float4 *mcv2_numbers, int mcv2_nvalues,\n\t\t\t\t  Oid operator)\n{\n\tSelectivity selec = 0.0;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tfmgr_info(get_opcode(operator), &proc);\n\n\tfor (i = 0; i < mcv1_nvalues; i++)\n\t{\n\t\tfor (j = 0; j < mcv2_nvalues; j++)\n\t\t\tif (DatumGetBool(FunctionCall2(&proc,\n\t\t\t\t\t\t\t\t\t\t   mcv1_values[i],\n\t\t\t\t\t\t\t\t\t\t   mcv2_values[j])))\n\t\t\t\tselec += mcv1_numbers[i] * mcv2_numbers[j];\n\t}\n\treturn selec;\n}"
  },
  {
    "function_name": "inet_hist_value_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "602-663",
    "snippet": "static Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_CONSIDERED_ELEMS 1024"
    ],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "2.0",
            "Max(left_divider, right_divider)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "left_divider",
            "right_divider"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_hist_match_divider",
          "args": [
            "right",
            "query",
            "opr_codenum"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_match_divider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "937-971",
          "snippet": "static int\ninet_hist_match_divider(inet *boundary, inet *query, int opr_codenum)\n{\n\tif (ip_family(boundary) == ip_family(query) &&\n\t\tinet_masklen_inclusion_cmp(boundary, query, opr_codenum) == 0)\n\t{\n\t\tint\t\t\tmin_bits,\n\t\t\t\t\tdecisive_bits;\n\n\t\tmin_bits = Min(ip_bits(boundary), ip_bits(query));\n\n\t\t/*\n\t\t * Set decisive_bits to the masklen of the one that should contain the\n\t\t * other according to the operator.\n\t\t */\n\t\tif (opr_codenum < 0)\n\t\t\tdecisive_bits = ip_bits(boundary);\n\t\telse if (opr_codenum > 0)\n\t\t\tdecisive_bits = ip_bits(query);\n\t\telse\n\t\t\tdecisive_bits = min_bits;\n\n\t\t/*\n\t\t * Now return the number of non-common decisive bits.  (This will be\n\t\t * zero if the boundary and query in fact match, else positive.)\n\t\t */\n\t\tif (min_bits > 0)\n\t\t\treturn decisive_bits - bitncommon(ip_addr(boundary),\n\t\t\t\t\t\t\t\t\t\t\t  ip_addr(query),\n\t\t\t\t\t\t\t\t\t\t\t  min_bits);\n\t\treturn decisive_bits;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_hist_match_divider(inet *boundary, inet *query, int opr_codenum)\n{\n\tif (ip_family(boundary) == ip_family(query) &&\n\t\tinet_masklen_inclusion_cmp(boundary, query, opr_codenum) == 0)\n\t{\n\t\tint\t\t\tmin_bits,\n\t\t\t\t\tdecisive_bits;\n\n\t\tmin_bits = Min(ip_bits(boundary), ip_bits(query));\n\n\t\t/*\n\t\t * Set decisive_bits to the masklen of the one that should contain the\n\t\t * other according to the operator.\n\t\t */\n\t\tif (opr_codenum < 0)\n\t\t\tdecisive_bits = ip_bits(boundary);\n\t\telse if (opr_codenum > 0)\n\t\t\tdecisive_bits = ip_bits(query);\n\t\telse\n\t\t\tdecisive_bits = min_bits;\n\n\t\t/*\n\t\t * Now return the number of non-common decisive bits.  (This will be\n\t\t * zero if the boundary and query in fact match, else positive.)\n\t\t */\n\t\tif (min_bits > 0)\n\t\t\treturn decisive_bits - bitncommon(ip_addr(boundary),\n\t\t\t\t\t\t\t\t\t\t\t  ip_addr(query),\n\t\t\t\t\t\t\t\t\t\t\t  min_bits);\n\t\treturn decisive_bits;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_inclusion_cmp",
          "args": [
            "right",
            "query",
            "opr_codenum"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "inet_inclusion_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "877-893",
          "snippet": "static int\ninet_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tif (ip_family(left) == ip_family(right))\n\t{\n\t\tint\t\t\torder;\n\n\t\torder = bitncmp(ip_addr(left), ip_addr(right),\n\t\t\t\t\t\tMin(ip_bits(left), ip_bits(right)));\n\t\tif (order != 0)\n\t\t\treturn order;\n\n\t\treturn inet_masklen_inclusion_cmp(left, right, opr_codenum);\n\t}\n\n\treturn ip_family(left) - ip_family(right);\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic int\ninet_inclusion_cmp(inet *left, inet *right, int opr_codenum)\n{\n\tif (ip_family(left) == ip_family(right))\n\t{\n\t\tint\t\t\torder;\n\n\t\torder = bitncmp(ip_addr(left), ip_addr(right),\n\t\t\t\t\t\tMin(ip_bits(left), ip_bits(right)));\n\t\tif (order != 0)\n\t\t\treturn order;\n\n\t\treturn inet_masklen_inclusion_cmp(left, right, opr_codenum);\n\t}\n\n\treturn ip_family(left) - ip_family(right);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "values[i]"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "values[0]"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "constvalue"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
  },
  {
    "function_name": "mcv_population",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "537-549",
    "snippet": "static Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\n\nstatic Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}"
  },
  {
    "function_name": "networkjoinsel_semi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "388-531",
    "snippet": "static Selectivity\nnetworkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0,\n\t\t\t\thist2_weight = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\tfmgr_info(get_opcode(operator), &proc);\n\n\t/* Estimate number of input rows represented by RHS histogram. */\n\tif (hist2_exists && vardata2->rel)\n\t\thist2_weight = (1.0 - nullfrac2 - sumcommon2) * vardata2->rel->rows;\n\n\t/*\n\t * Consider each element of the LHS MCV list, matching it to whatever RHS\n\t * stats we have.  Scale according to the known frequency of the MCV.\n\t */\n\tif (mcv1_exists && (mcv2_exists || hist2_exists))\n\t{\n\t\tfor (i = 0; i < mcv1_length; i++)\n\t\t{\n\t\t\tselec += mcv1_slot.numbers[i] *\n\t\t\t\tinet_semi_join_sel(mcv1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t}\n\t}\n\n\t/*\n\t * Consider each element of the LHS histogram, except for the first and\n\t * last elements, which we exclude on the grounds that they're outliers\n\t * and thus not very representative.  Scale on the assumption that each\n\t * such histogram element represents an equal share of the LHS histogram\n\t * population (which is a bit bogus, because the members of its bucket may\n\t * not all act the same with respect to the join clause, but it's hard to\n\t * do better).\n\t *\n\t * If there are too many histogram elements, decimate to limit runtime.\n\t */\n\tif (hist1_exists && hist1_slot.nvalues > 2 && (mcv2_exists || hist2_exists))\n\t{\n\t\tdouble\t\thist_selec_sum = 0.0;\n\t\tint\t\t\tk,\n\t\t\t\t\tn;\n\n\t\tk = (hist1_slot.nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\t\tn = 0;\n\t\tfor (i = 1; i < hist1_slot.nvalues - 1; i += k)\n\t\t{\n\t\t\thist_selec_sum +=\n\t\t\t\tinet_semi_join_sel(hist1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t\tn++;\n\t\t}\n\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) * hist_selec_sum / n;\n\t}\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_CONSIDERED_ELEMS 1024"
    ],
    "globals_used": [
      "static Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&hist2_slot"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_semi_join_sel",
          "args": [
            "hist1_slot.values[i]",
            "mcv2_exists",
            "mcv2_slot.values",
            "mcv2_length",
            "hist2_exists",
            "hist2_slot.values",
            "hist2_slot.nvalues",
            "hist2_weight",
            "&proc",
            "opr_codenum"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "inet_semi_join_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "791-824",
          "snippet": "static Selectivity\ninet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum)\n{\n\tif (mcv_exists)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < mcv_nvalues; i++)\n\t\t{\n\t\t\tif (DatumGetBool(FunctionCall2(proc,\n\t\t\t\t\t\t\t\t\t\t   lhs_value,\n\t\t\t\t\t\t\t\t\t\t   mcv_values[i])))\n\t\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\tif (hist_exists && hist_weight > 0)\n\t{\n\t\tSelectivity hist_selec;\n\n\t\t/* Commute operator, since we're passing lhs_value on the right */\n\t\thist_selec = inet_hist_value_sel(hist_values, hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t lhs_value, -opr_codenum);\n\n\t\tif (hist_selec > 0)\n\t\t\treturn Min(1.0, hist_weight * hist_selec);\n\t}\n\n\treturn 0.0;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);",
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum)\n{\n\tif (mcv_exists)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < mcv_nvalues; i++)\n\t\t{\n\t\t\tif (DatumGetBool(FunctionCall2(proc,\n\t\t\t\t\t\t\t\t\t\t   lhs_value,\n\t\t\t\t\t\t\t\t\t\t   mcv_values[i])))\n\t\t\t\treturn 1.0;\n\t\t}\n\t}\n\n\tif (hist_exists && hist_weight > 0)\n\t{\n\t\tSelectivity hist_selec;\n\n\t\t/* Commute operator, since we're passing lhs_value on the right */\n\t\thist_selec = inet_hist_value_sel(hist_values, hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t lhs_value, -opr_codenum);\n\n\t\tif (hist_selec > 0)\n\t\t\treturn Min(1.0, hist_weight * hist_selec);\n\t}\n\n\treturn 0.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(operator)",
            "&proc"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_opr_codenum",
          "args": [
            "operator"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "inet_opr_codenum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "834-854",
          "snippet": "static int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static int\tinet_opr_codenum(Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hist2_slot",
            "0",
            "sizeof(hist2_slot)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mcv2_slot",
            "0",
            "sizeof(mcv2_slot)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcv_population",
          "args": [
            "mcv2_slot.numbers",
            "mcv2_length"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "mcv_population",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "537-549",
          "snippet": "static Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\n\nstatic Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "mcv2_slot.nvalues",
            "MAX_CONSIDERED_ELEMS"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&hist2_slot",
            "vardata2->statsTuple",
            "STATISTIC_KIND_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hist1_slot",
            "0",
            "sizeof(hist1_slot)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mcv1_slot",
            "0",
            "sizeof(mcv1_slot)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "mcv1_slot.nvalues",
            "MAX_CONSIDERED_ELEMS"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\nnetworkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0,\n\t\t\t\thist2_weight = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\tfmgr_info(get_opcode(operator), &proc);\n\n\t/* Estimate number of input rows represented by RHS histogram. */\n\tif (hist2_exists && vardata2->rel)\n\t\thist2_weight = (1.0 - nullfrac2 - sumcommon2) * vardata2->rel->rows;\n\n\t/*\n\t * Consider each element of the LHS MCV list, matching it to whatever RHS\n\t * stats we have.  Scale according to the known frequency of the MCV.\n\t */\n\tif (mcv1_exists && (mcv2_exists || hist2_exists))\n\t{\n\t\tfor (i = 0; i < mcv1_length; i++)\n\t\t{\n\t\t\tselec += mcv1_slot.numbers[i] *\n\t\t\t\tinet_semi_join_sel(mcv1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t}\n\t}\n\n\t/*\n\t * Consider each element of the LHS histogram, except for the first and\n\t * last elements, which we exclude on the grounds that they're outliers\n\t * and thus not very representative.  Scale on the assumption that each\n\t * such histogram element represents an equal share of the LHS histogram\n\t * population (which is a bit bogus, because the members of its bucket may\n\t * not all act the same with respect to the join clause, but it's hard to\n\t * do better).\n\t *\n\t * If there are too many histogram elements, decimate to limit runtime.\n\t */\n\tif (hist1_exists && hist1_slot.nvalues > 2 && (mcv2_exists || hist2_exists))\n\t{\n\t\tdouble\t\thist_selec_sum = 0.0;\n\t\tint\t\t\tk,\n\t\t\t\t\tn;\n\n\t\tk = (hist1_slot.nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\t\tn = 0;\n\t\tfor (i = 1; i < hist1_slot.nvalues - 1; i += k)\n\t\t{\n\t\t\thist_selec_sum +=\n\t\t\t\tinet_semi_join_sel(hist1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t\tn++;\n\t\t}\n\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) * hist_selec_sum / n;\n\t}\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "networkjoinsel_inner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "261-380",
    "snippet": "static Selectivity\nnetworkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tint\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\n\t/*\n\t * Calculate selectivity for MCV vs MCV matches.\n\t */\n\tif (mcv1_exists && mcv2_exists)\n\t\tselec += inet_mcv_join_sel(mcv1_slot.values, mcv1_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv1_length,\n\t\t\t\t\t\t\t\t   mcv2_slot.values, mcv2_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv2_length,\n\t\t\t\t\t\t\t\t   operator);\n\n\t/*\n\t * Add in selectivities for MCV vs histogram matches, scaling according to\n\t * the fractions of the populations represented by the histograms. Note\n\t * that the second case needs to commute the operator.\n\t */\n\tif (mcv1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_mcv_hist_sel(mcv1_slot.values, mcv1_slot.numbers, mcv1_length,\n\t\t\t\t\t\t\t  hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t  opr_codenum);\n\tif (mcv2_exists && hist1_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\tinet_mcv_hist_sel(mcv2_slot.values, mcv2_slot.numbers, mcv2_length,\n\t\t\t\t\t\t\t  hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t  -opr_codenum);\n\n\t/*\n\t * Add in selectivity for histogram vs histogram matches, again scaling\n\t * appropriately.\n\t */\n\tif (hist1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\t(1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_hist_inclusion_join_sel(hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t opr_codenum);\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_CONSIDERED_ELEMS 1024"
    ],
    "globals_used": [
      "static Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&hist2_slot"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_hist_inclusion_join_sel",
          "args": [
            "hist1_slot.values",
            "hist1_slot.nvalues",
            "hist2_slot.values",
            "hist2_slot.nvalues",
            "opr_codenum"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_inclusion_join_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "740-765",
          "snippet": "static Selectivity\ninet_hist_inclusion_join_sel(Datum *hist1_values, int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum)\n{\n\tdouble\t\tmatch = 0.0;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\n\tif (hist2_nvalues <= 2)\n\t\treturn 0.0;\t\t\t\t/* no interior histogram elements */\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (hist2_nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\tn = 0;\n\tfor (i = 1; i < hist2_nvalues - 1; i += k)\n\t{\n\t\tmatch += inet_hist_value_sel(hist1_values, hist1_nvalues,\n\t\t\t\t\t\t\t\t\t hist2_values[i], opr_codenum);\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_inclusion_join_sel(Datum *hist1_values, int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum)\n{\n\tdouble\t\tmatch = 0.0;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\n\tif (hist2_nvalues <= 2)\n\t\treturn 0.0;\t\t\t\t/* no interior histogram elements */\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (hist2_nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\tn = 0;\n\tfor (i = 1; i < hist2_nvalues - 1; i += k)\n\t{\n\t\tmatch += inet_hist_value_sel(hist1_values, hist1_nvalues,\n\t\t\t\t\t\t\t\t\t hist2_values[i], opr_codenum);\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_mcv_hist_sel",
          "args": [
            "mcv2_slot.values",
            "mcv2_slot.numbers",
            "mcv2_length",
            "hist1_slot.values",
            "hist1_slot.nvalues",
            "-opr_codenum"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "inet_mcv_hist_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "703-724",
          "snippet": "static Selectivity\ninet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers, int mcv_nvalues,\n\t\t\t\t  Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum)\n{\n\tSelectivity selec = 0.0;\n\tint\t\t\ti;\n\n\t/*\n\t * We'll call inet_hist_value_selec with the histogram on the left, so we\n\t * must commute the operator.\n\t */\n\topr_codenum = -opr_codenum;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tselec += mcv_numbers[i] *\n\t\t\tinet_hist_value_sel(hist_values, hist_nvalues, mcv_values[i],\n\t\t\t\t\t\t\t\topr_codenum);\n\t}\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);",
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers, int mcv_nvalues,\n\t\t\t\t  Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum)\n{\n\tSelectivity selec = 0.0;\n\tint\t\t\ti;\n\n\t/*\n\t * We'll call inet_hist_value_selec with the histogram on the left, so we\n\t * must commute the operator.\n\t */\n\topr_codenum = -opr_codenum;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tselec += mcv_numbers[i] *\n\t\t\tinet_hist_value_sel(hist_values, hist_nvalues, mcv_values[i],\n\t\t\t\t\t\t\t\topr_codenum);\n\t}\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_mcv_join_sel",
          "args": [
            "mcv1_slot.values",
            "mcv1_slot.numbers",
            "mcv1_length",
            "mcv2_slot.values",
            "mcv2_slot.numbers",
            "mcv2_length",
            "operator"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "inet_mcv_join_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "671-692",
          "snippet": "static Selectivity\ninet_mcv_join_sel(Datum *mcv1_values, float4 *mcv1_numbers, int mcv1_nvalues,\n\t\t\t\t  Datum *mcv2_values, float4 *mcv2_numbers, int mcv2_nvalues,\n\t\t\t\t  Oid operator)\n{\n\tSelectivity selec = 0.0;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tfmgr_info(get_opcode(operator), &proc);\n\n\tfor (i = 0; i < mcv1_nvalues; i++)\n\t{\n\t\tfor (j = 0; j < mcv2_nvalues; j++)\n\t\t\tif (DatumGetBool(FunctionCall2(&proc,\n\t\t\t\t\t\t\t\t\t\t   mcv1_values[i],\n\t\t\t\t\t\t\t\t\t\t   mcv2_values[j])))\n\t\t\t\tselec += mcv1_numbers[i] * mcv2_numbers[j];\n\t}\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static int\tinet_opr_codenum(Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic Selectivity\ninet_mcv_join_sel(Datum *mcv1_values, float4 *mcv1_numbers, int mcv1_nvalues,\n\t\t\t\t  Datum *mcv2_values, float4 *mcv2_numbers, int mcv2_nvalues,\n\t\t\t\t  Oid operator)\n{\n\tSelectivity selec = 0.0;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tfmgr_info(get_opcode(operator), &proc);\n\n\tfor (i = 0; i < mcv1_nvalues; i++)\n\t{\n\t\tfor (j = 0; j < mcv2_nvalues; j++)\n\t\t\tif (DatumGetBool(FunctionCall2(&proc,\n\t\t\t\t\t\t\t\t\t\t   mcv1_values[i],\n\t\t\t\t\t\t\t\t\t\t   mcv2_values[j])))\n\t\t\t\tselec += mcv1_numbers[i] * mcv2_numbers[j];\n\t}\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_opr_codenum",
          "args": [
            "operator"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "inet_opr_codenum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "834-854",
          "snippet": "static int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static int\tinet_opr_codenum(Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hist2_slot",
            "0",
            "sizeof(hist2_slot)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mcv2_slot",
            "0",
            "sizeof(mcv2_slot)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcv_population",
          "args": [
            "mcv2_slot.numbers",
            "mcv2_length"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "mcv_population",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "537-549",
          "snippet": "static Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcv_population(float4 *mcv_numbers, int mcv_nvalues);\n\nstatic Selectivity\nmcv_population(float4 *mcv_numbers, int mcv_nvalues)\n{\n\tSelectivity sumcommon = 0.0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < mcv_nvalues; i++)\n\t{\n\t\tsumcommon += mcv_numbers[i];\n\t}\n\n\treturn sumcommon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "mcv2_slot.nvalues",
            "MAX_CONSIDERED_ELEMS"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&hist2_slot",
            "vardata2->statsTuple",
            "STATISTIC_KIND_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hist1_slot",
            "0",
            "sizeof(hist1_slot)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mcv1_slot",
            "0",
            "sizeof(mcv1_slot)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "mcv1_slot.nvalues",
            "MAX_CONSIDERED_ELEMS"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\nnetworkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tint\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\n\t/*\n\t * Calculate selectivity for MCV vs MCV matches.\n\t */\n\tif (mcv1_exists && mcv2_exists)\n\t\tselec += inet_mcv_join_sel(mcv1_slot.values, mcv1_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv1_length,\n\t\t\t\t\t\t\t\t   mcv2_slot.values, mcv2_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv2_length,\n\t\t\t\t\t\t\t\t   operator);\n\n\t/*\n\t * Add in selectivities for MCV vs histogram matches, scaling according to\n\t * the fractions of the populations represented by the histograms. Note\n\t * that the second case needs to commute the operator.\n\t */\n\tif (mcv1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_mcv_hist_sel(mcv1_slot.values, mcv1_slot.numbers, mcv1_length,\n\t\t\t\t\t\t\t  hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t  opr_codenum);\n\tif (mcv2_exists && hist1_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\tinet_mcv_hist_sel(mcv2_slot.values, mcv2_slot.numbers, mcv2_length,\n\t\t\t\t\t\t\t  hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t  -opr_codenum);\n\n\t/*\n\t * Add in selectivity for histogram vs histogram matches, again scaling\n\t * appropriately.\n\t */\n\tif (hist1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\t(1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_hist_inclusion_join_sel(hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t opr_codenum);\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "networkjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "194-247",
    "snippet": "Datum\nnetworkjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n#ifdef NOT_USED\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n#endif\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tdouble\t\tselec;\n\tVariableStatData vardata1;\n\tVariableStatData vardata2;\n\tbool\t\tjoin_is_reversed;\n\n\tget_join_variables(root, args, sjinfo,\n\t\t\t\t\t   &vardata1, &vardata2, &join_is_reversed);\n\n\tswitch (sjinfo->jointype)\n\t{\n\t\tcase JOIN_INNER:\n\t\tcase JOIN_LEFT:\n\t\tcase JOIN_FULL:\n\n\t\t\t/*\n\t\t\t * Selectivity for left/full join is not exactly the same as inner\n\t\t\t * join, but we neglect the difference, as eqjoinsel does.\n\t\t\t */\n\t\t\tselec = networkjoinsel_inner(operator, &vardata1, &vardata2);\n\t\t\tbreak;\n\t\tcase JOIN_SEMI:\n\t\tcase JOIN_ANTI:\n\t\t\t/* Here, it's important that we pass the outer var on the left. */\n\t\t\tif (!join_is_reversed)\n\t\t\t\tselec = networkjoinsel_semi(operator, &vardata1, &vardata2);\n\t\t\telse\n\t\t\t\tselec = networkjoinsel_semi(get_commutator(operator),\n\t\t\t\t\t\t\t\t\t\t\t&vardata2, &vardata1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* other values not expected here */\n\t\t\telog(ERROR, \"unrecognized join type: %d\",\n\t\t\t\t (int) sjinfo->jointype);\n\t\t\tselec = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tReleaseVariableStats(vardata1);\n\tReleaseVariableStats(vardata2);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static int\tinet_opr_codenum(Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) selec"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata2"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized join type: %d\"",
            "(int) sjinfo->jointype"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkjoinsel_semi",
          "args": [
            "get_commutator(operator)",
            "&vardata2",
            "&vardata1"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "networkjoinsel_semi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "388-531",
          "snippet": "static Selectivity\nnetworkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0,\n\t\t\t\thist2_weight = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\tfmgr_info(get_opcode(operator), &proc);\n\n\t/* Estimate number of input rows represented by RHS histogram. */\n\tif (hist2_exists && vardata2->rel)\n\t\thist2_weight = (1.0 - nullfrac2 - sumcommon2) * vardata2->rel->rows;\n\n\t/*\n\t * Consider each element of the LHS MCV list, matching it to whatever RHS\n\t * stats we have.  Scale according to the known frequency of the MCV.\n\t */\n\tif (mcv1_exists && (mcv2_exists || hist2_exists))\n\t{\n\t\tfor (i = 0; i < mcv1_length; i++)\n\t\t{\n\t\t\tselec += mcv1_slot.numbers[i] *\n\t\t\t\tinet_semi_join_sel(mcv1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t}\n\t}\n\n\t/*\n\t * Consider each element of the LHS histogram, except for the first and\n\t * last elements, which we exclude on the grounds that they're outliers\n\t * and thus not very representative.  Scale on the assumption that each\n\t * such histogram element represents an equal share of the LHS histogram\n\t * population (which is a bit bogus, because the members of its bucket may\n\t * not all act the same with respect to the join clause, but it's hard to\n\t * do better).\n\t *\n\t * If there are too many histogram elements, decimate to limit runtime.\n\t */\n\tif (hist1_exists && hist1_slot.nvalues > 2 && (mcv2_exists || hist2_exists))\n\t{\n\t\tdouble\t\thist_selec_sum = 0.0;\n\t\tint\t\t\tk,\n\t\t\t\t\tn;\n\n\t\tk = (hist1_slot.nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\t\tn = 0;\n\t\tfor (i = 1; i < hist1_slot.nvalues - 1; i += k)\n\t\t{\n\t\t\thist_selec_sum +=\n\t\t\t\tinet_semi_join_sel(hist1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t\tn++;\n\t\t}\n\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) * hist_selec_sum / n;\n\t}\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);",
            "static Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\nnetworkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0,\n\t\t\t\thist2_weight = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tFmgrInfo\tproc;\n\tint\t\t\ti,\n\t\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\tfmgr_info(get_opcode(operator), &proc);\n\n\t/* Estimate number of input rows represented by RHS histogram. */\n\tif (hist2_exists && vardata2->rel)\n\t\thist2_weight = (1.0 - nullfrac2 - sumcommon2) * vardata2->rel->rows;\n\n\t/*\n\t * Consider each element of the LHS MCV list, matching it to whatever RHS\n\t * stats we have.  Scale according to the known frequency of the MCV.\n\t */\n\tif (mcv1_exists && (mcv2_exists || hist2_exists))\n\t{\n\t\tfor (i = 0; i < mcv1_length; i++)\n\t\t{\n\t\t\tselec += mcv1_slot.numbers[i] *\n\t\t\t\tinet_semi_join_sel(mcv1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t}\n\t}\n\n\t/*\n\t * Consider each element of the LHS histogram, except for the first and\n\t * last elements, which we exclude on the grounds that they're outliers\n\t * and thus not very representative.  Scale on the assumption that each\n\t * such histogram element represents an equal share of the LHS histogram\n\t * population (which is a bit bogus, because the members of its bucket may\n\t * not all act the same with respect to the join clause, but it's hard to\n\t * do better).\n\t *\n\t * If there are too many histogram elements, decimate to limit runtime.\n\t */\n\tif (hist1_exists && hist1_slot.nvalues > 2 && (mcv2_exists || hist2_exists))\n\t{\n\t\tdouble\t\thist_selec_sum = 0.0;\n\t\tint\t\t\tk,\n\t\t\t\t\tn;\n\n\t\tk = (hist1_slot.nvalues - 3) / MAX_CONSIDERED_ELEMS + 1;\n\n\t\tn = 0;\n\t\tfor (i = 1; i < hist1_slot.nvalues - 1; i += k)\n\t\t{\n\t\t\thist_selec_sum +=\n\t\t\t\tinet_semi_join_sel(hist1_slot.values[i],\n\t\t\t\t\t\t\t\t   mcv2_exists, mcv2_slot.values, mcv2_length,\n\t\t\t\t\t\t\t\t   hist2_exists,\n\t\t\t\t\t\t\t\t   hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t   hist2_weight,\n\t\t\t\t\t\t\t\t   &proc, opr_codenum);\n\t\t\tn++;\n\t\t}\n\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) * hist_selec_sum / n;\n\t}\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_commutator",
          "args": [
            "operator"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "get_commutator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1297-1314",
          "snippet": "Oid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkjoinsel_inner",
          "args": [
            "operator",
            "&vardata1",
            "&vardata2"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "networkjoinsel_inner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "261-380",
          "snippet": "static Selectivity\nnetworkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tint\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\n\t/*\n\t * Calculate selectivity for MCV vs MCV matches.\n\t */\n\tif (mcv1_exists && mcv2_exists)\n\t\tselec += inet_mcv_join_sel(mcv1_slot.values, mcv1_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv1_length,\n\t\t\t\t\t\t\t\t   mcv2_slot.values, mcv2_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv2_length,\n\t\t\t\t\t\t\t\t   operator);\n\n\t/*\n\t * Add in selectivities for MCV vs histogram matches, scaling according to\n\t * the fractions of the populations represented by the histograms. Note\n\t * that the second case needs to commute the operator.\n\t */\n\tif (mcv1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_mcv_hist_sel(mcv1_slot.values, mcv1_slot.numbers, mcv1_length,\n\t\t\t\t\t\t\t  hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t  opr_codenum);\n\tif (mcv2_exists && hist1_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\tinet_mcv_hist_sel(mcv2_slot.values, mcv2_slot.numbers, mcv2_length,\n\t\t\t\t\t\t\t  hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t  -opr_codenum);\n\n\t/*\n\t * Add in selectivity for histogram vs histogram matches, again scaling\n\t * appropriately.\n\t */\n\tif (hist1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\t(1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_hist_inclusion_join_sel(hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t opr_codenum);\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);",
            "static Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_opr_codenum(Oid operator);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\nnetworkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tForm_pg_statistic stats;\n\tdouble\t\tnullfrac1 = 0.0,\n\t\t\t\tnullfrac2 = 0.0;\n\tSelectivity selec = 0.0,\n\t\t\t\tsumcommon1 = 0.0,\n\t\t\t\tsumcommon2 = 0.0;\n\tbool\t\tmcv1_exists = false,\n\t\t\t\tmcv2_exists = false,\n\t\t\t\thist1_exists = false,\n\t\t\t\thist2_exists = false;\n\tint\t\t\topr_codenum;\n\tint\t\t\tmcv1_length = 0,\n\t\t\t\tmcv2_length = 0;\n\tAttStatsSlot mcv1_slot;\n\tAttStatsSlot mcv2_slot;\n\tAttStatsSlot hist1_slot;\n\tAttStatsSlot hist2_slot;\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tnullfrac1 = stats->stanullfrac;\n\n\t\tmcv1_exists = get_attstatsslot(&mcv1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist1_exists = get_attstatsslot(&hist1_slot, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv1_length = Min(mcv1_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv1_exists)\n\t\t\tsumcommon1 = mcv_population(mcv1_slot.numbers, mcv1_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv1_slot, 0, sizeof(mcv1_slot));\n\t\tmemset(&hist1_slot, 0, sizeof(hist1_slot));\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tnullfrac2 = stats->stanullfrac;\n\n\t\tmcv2_exists = get_attstatsslot(&mcv2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t   STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t\thist2_exists = get_attstatsslot(&hist2_slot, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\tSTATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t\t\t\tATTSTATSSLOT_VALUES);\n\t\t/* Arbitrarily limit number of MCVs considered */\n\t\tmcv2_length = Min(mcv2_slot.nvalues, MAX_CONSIDERED_ELEMS);\n\t\tif (mcv2_exists)\n\t\t\tsumcommon2 = mcv_population(mcv2_slot.numbers, mcv2_length);\n\t}\n\telse\n\t{\n\t\tmemset(&mcv2_slot, 0, sizeof(mcv2_slot));\n\t\tmemset(&hist2_slot, 0, sizeof(hist2_slot));\n\t}\n\n\topr_codenum = inet_opr_codenum(operator);\n\n\t/*\n\t * Calculate selectivity for MCV vs MCV matches.\n\t */\n\tif (mcv1_exists && mcv2_exists)\n\t\tselec += inet_mcv_join_sel(mcv1_slot.values, mcv1_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv1_length,\n\t\t\t\t\t\t\t\t   mcv2_slot.values, mcv2_slot.numbers,\n\t\t\t\t\t\t\t\t   mcv2_length,\n\t\t\t\t\t\t\t\t   operator);\n\n\t/*\n\t * Add in selectivities for MCV vs histogram matches, scaling according to\n\t * the fractions of the populations represented by the histograms. Note\n\t * that the second case needs to commute the operator.\n\t */\n\tif (mcv1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_mcv_hist_sel(mcv1_slot.values, mcv1_slot.numbers, mcv1_length,\n\t\t\t\t\t\t\t  hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t  opr_codenum);\n\tif (mcv2_exists && hist1_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\tinet_mcv_hist_sel(mcv2_slot.values, mcv2_slot.numbers, mcv2_length,\n\t\t\t\t\t\t\t  hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t  -opr_codenum);\n\n\t/*\n\t * Add in selectivity for histogram vs histogram matches, again scaling\n\t * appropriately.\n\t */\n\tif (hist1_exists && hist2_exists)\n\t\tselec += (1.0 - nullfrac1 - sumcommon1) *\n\t\t\t(1.0 - nullfrac2 - sumcommon2) *\n\t\t\tinet_hist_inclusion_join_sel(hist1_slot.values, hist1_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t hist2_slot.values, hist2_slot.nvalues,\n\t\t\t\t\t\t\t\t\t\t opr_codenum);\n\n\t/*\n\t * If useful statistics are not available then use the default estimate.\n\t * We can apply null fractions if known, though.\n\t */\n\tif ((!mcv1_exists && !hist1_exists) || (!mcv2_exists && !hist2_exists))\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2) * DEFAULT_SEL(operator);\n\n\t/* Release stats. */\n\tfree_attstatsslot(&mcv1_slot);\n\tfree_attstatsslot(&mcv2_slot);\n\tfree_attstatsslot(&hist1_slot);\n\tfree_attstatsslot(&hist2_slot);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_join_variables",
          "args": [
            "root",
            "args",
            "sjinfo",
            "&vardata1",
            "&vardata2",
            "&join_is_reversed"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "get_join_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4713-4738",
          "snippet": "void\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nvoid\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "3"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity networkjoinsel_inner(Oid operator,\n\t\t\t\t\t VariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity networkjoinsel_semi(Oid operator,\n\t\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nDatum\nnetworkjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n#ifdef NOT_USED\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n#endif\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tdouble\t\tselec;\n\tVariableStatData vardata1;\n\tVariableStatData vardata2;\n\tbool\t\tjoin_is_reversed;\n\n\tget_join_variables(root, args, sjinfo,\n\t\t\t\t\t   &vardata1, &vardata2, &join_is_reversed);\n\n\tswitch (sjinfo->jointype)\n\t{\n\t\tcase JOIN_INNER:\n\t\tcase JOIN_LEFT:\n\t\tcase JOIN_FULL:\n\n\t\t\t/*\n\t\t\t * Selectivity for left/full join is not exactly the same as inner\n\t\t\t * join, but we neglect the difference, as eqjoinsel does.\n\t\t\t */\n\t\t\tselec = networkjoinsel_inner(operator, &vardata1, &vardata2);\n\t\t\tbreak;\n\t\tcase JOIN_SEMI:\n\t\tcase JOIN_ANTI:\n\t\t\t/* Here, it's important that we pass the outer var on the left. */\n\t\t\tif (!join_is_reversed)\n\t\t\t\tselec = networkjoinsel_semi(operator, &vardata1, &vardata2);\n\t\t\telse\n\t\t\t\tselec = networkjoinsel_semi(get_commutator(operator),\n\t\t\t\t\t\t\t\t\t\t\t&vardata2, &vardata1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* other values not expected here */\n\t\t\telog(ERROR, \"unrecognized join type: %d\",\n\t\t\t\t (int) sjinfo->jointype);\n\t\t\tselec = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tReleaseVariableStats(vardata1);\n\tReleaseVariableStats(vardata2);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
  },
  {
    "function_name": "networksel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
    "lines": "78-174",
    "snippet": "Datum\nnetworksel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec,\n\t\t\t\tmcv_selec,\n\t\t\t\tnon_mcv_selec;\n\tDatum\t\tconstvalue;\n\tForm_pg_statistic stats;\n\tAttStatsSlot hslot;\n\tdouble\t\tsumcommon,\n\t\t\t\tnullfrac;\n\tFmgrInfo\tproc;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\t/* All of the operators handled here are strict. */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstvalue = ((Const *) other)->constvalue;\n\n\t/* Otherwise, we need stats in order to produce a non-default estimate. */\n\tif (!HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\tnullfrac = stats->stanullfrac;\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tfmgr_info(get_opcode(operator), &proc);\n\tmcv_selec = mcv_selectivity(&vardata, &proc, constvalue, varonleft,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If we have a histogram, use it to estimate the proportion of the\n\t * non-MCV population that satisfies the clause.  If we don't, apply the\n\t * default selectivity to that population.\n\t */\n\tif (get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tint\t\t\topr_codenum = inet_opr_codenum(operator);\n\n\t\t/* Commute if needed, so we can consider histogram to be on the left */\n\t\tif (!varonleft)\n\t\t\topr_codenum = -opr_codenum;\n\t\tnon_mcv_selec = inet_hist_value_sel(hslot.values, hslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\tconstvalue, opr_codenum);\n\n\t\tfree_attstatsslot(&hslot);\n\t}\n\telse\n\t\tnon_mcv_selec = DEFAULT_SEL(operator);\n\n\t/* Combine selectivities for MCV and non-MCV populations */\n\tselec = mcv_selec + (1.0 - nullfrac - sumcommon) * non_mcv_selec;\n\n\t/* Result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8(selec);\n}",
    "includes": [
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
      "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
      "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
      "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
      "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
      "static int\tinet_opr_codenum(Oid operator);",
      "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
      "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
      "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "selec"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&hslot"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_hist_value_sel",
          "args": [
            "hslot.values",
            "hslot.nvalues",
            "constvalue",
            "opr_codenum"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "inet_hist_value_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "602-663",
          "snippet": "static Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_CONSIDERED_ELEMS 1024"
          ],
          "globals_used": [
            "static Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);",
            "static Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);",
            "static Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);",
            "static Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);",
            "static int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);",
            "static int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);",
            "static int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define MAX_CONSIDERED_ELEMS 1024\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nstatic Selectivity\ninet_hist_value_sel(Datum *values, int nvalues, Datum constvalue,\n\t\t\t\t\tint opr_codenum)\n{\n\tSelectivity match = 0.0;\n\tinet\t   *query,\n\t\t\t   *left,\n\t\t\t   *right;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tn;\n\tint\t\t\tleft_order,\n\t\t\t\tright_order,\n\t\t\t\tleft_divider,\n\t\t\t\tright_divider;\n\n\t/* guard against zero-divide below */\n\tif (nvalues <= 1)\n\t\treturn 0.0;\n\n\t/* if there are too many histogram elements, decimate to limit runtime */\n\tk = (nvalues - 2) / MAX_CONSIDERED_ELEMS + 1;\n\n\tquery = DatumGetInetPP(constvalue);\n\n\t/* \"left\" is the left boundary value of the current bucket ... */\n\tleft = DatumGetInetPP(values[0]);\n\tleft_order = inet_inclusion_cmp(left, query, opr_codenum);\n\n\tn = 0;\n\tfor (i = k; i < nvalues; i += k)\n\t{\n\t\t/* ... and \"right\" is the right boundary value */\n\t\tright = DatumGetInetPP(values[i]);\n\t\tright_order = inet_inclusion_cmp(right, query, opr_codenum);\n\n\t\tif (left_order == 0 && right_order == 0)\n\t\t{\n\t\t\t/* The whole bucket matches, since both endpoints do. */\n\t\t\tmatch += 1.0;\n\t\t}\n\t\telse if ((left_order <= 0 && right_order >= 0) ||\n\t\t\t\t (left_order >= 0 && right_order <= 0))\n\t\t{\n\t\t\t/* Partial bucket match. */\n\t\t\tleft_divider = inet_hist_match_divider(left, query, opr_codenum);\n\t\t\tright_divider = inet_hist_match_divider(right, query, opr_codenum);\n\n\t\t\tif (left_divider >= 0 || right_divider >= 0)\n\t\t\t\tmatch += 1.0 / pow(2.0, Max(left_divider, right_divider));\n\t\t}\n\n\t\t/* Shift the variables. */\n\t\tleft = right;\n\t\tleft_order = right_order;\n\n\t\t/* Count the number of buckets considered. */\n\t\tn++;\n\t}\n\n\treturn match / n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_opr_codenum",
          "args": [
            "operator"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "inet_opr_codenum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_selfuncs.c",
          "lines": "834-854",
          "snippet": "static int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);",
            "static int\tinet_opr_codenum(Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic int\tinet_opr_codenum(Oid operator);\n\nstatic int\ninet_opr_codenum(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_INET_SUP_OP:\n\t\t\treturn -2;\n\t\tcase OID_INET_SUPEQ_OP:\n\t\t\treturn -1;\n\t\tcase OID_INET_OVERLAP_OP:\n\t\t\treturn 0;\n\t\tcase OID_INET_SUBEQ_OP:\n\t\t\treturn 1;\n\t\tcase OID_INET_SUB_OP:\n\t\t\treturn 2;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator %u for inet selectivity\",\n\t\t\t\t operator);\n\t}\n\treturn 0;\t\t\t\t\t/* unreached, but keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&hslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcv_selectivity",
          "args": [
            "&vardata",
            "&proc",
            "constvalue",
            "varonleft",
            "&sumcommon"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "mcv_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "638-676",
          "snippet": "double\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(operator)",
            "&proc"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity inet_hist_value_sel(Datum *values, int nvalues,\n\t\t\t\t\tDatum constvalue, int opr_codenum);\nstatic Selectivity inet_mcv_join_sel(Datum *mcv1_values,\n\t\t\t\t  float4 *mcv1_numbers, int mcv1_nvalues, Datum *mcv2_values,\n\t\t\t\t  float4 *mcv2_numbers, int mcv2_nvalues, Oid operator);\nstatic Selectivity inet_mcv_hist_sel(Datum *mcv_values, float4 *mcv_numbers,\n\t\t\t\t  int mcv_nvalues, Datum *hist_values, int hist_nvalues,\n\t\t\t\t  int opr_codenum);\nstatic Selectivity inet_hist_inclusion_join_sel(Datum *hist1_values,\n\t\t\t\t\t\t\t int hist1_nvalues,\n\t\t\t\t\t\t\t Datum *hist2_values, int hist2_nvalues,\n\t\t\t\t\t\t\t int opr_codenum);\nstatic Selectivity inet_semi_join_sel(Datum lhs_value,\n\t\t\t\t   bool mcv_exists, Datum *mcv_values, int mcv_nvalues,\n\t\t\t\t   bool hist_exists, Datum *hist_values, int hist_nvalues,\n\t\t\t\t   double hist_weight,\n\t\t\t\t   FmgrInfo *proc, int opr_codenum);\nstatic int\tinet_opr_codenum(Oid operator);\nstatic int\tinet_inclusion_cmp(inet *left, inet *right, int opr_codenum);\nstatic int inet_masklen_inclusion_cmp(inet *left, inet *right,\n\t\t\t\t\t\t   int opr_codenum);\nstatic int inet_hist_match_divider(inet *boundary, inet *query,\n\t\t\t\t\t\tint opr_codenum);\n\nDatum\nnetworksel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec,\n\t\t\t\tmcv_selec,\n\t\t\t\tnon_mcv_selec;\n\tDatum\t\tconstvalue;\n\tForm_pg_statistic stats;\n\tAttStatsSlot hslot;\n\tdouble\t\tsumcommon,\n\t\t\t\tnullfrac;\n\tFmgrInfo\tproc;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\t/* All of the operators handled here are strict. */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstvalue = ((Const *) other)->constvalue;\n\n\t/* Otherwise, we need stats in order to produce a non-default estimate. */\n\tif (!HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\tnullfrac = stats->stanullfrac;\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tfmgr_info(get_opcode(operator), &proc);\n\tmcv_selec = mcv_selectivity(&vardata, &proc, constvalue, varonleft,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If we have a histogram, use it to estimate the proportion of the\n\t * non-MCV population that satisfies the clause.  If we don't, apply the\n\t * default selectivity to that population.\n\t */\n\tif (get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tint\t\t\topr_codenum = inet_opr_codenum(operator);\n\n\t\t/* Commute if needed, so we can consider histogram to be on the left */\n\t\tif (!varonleft)\n\t\t\topr_codenum = -opr_codenum;\n\t\tnon_mcv_selec = inet_hist_value_sel(hslot.values, hslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\tconstvalue, opr_codenum);\n\n\t\tfree_attstatsslot(&hslot);\n\t}\n\telse\n\t\tnon_mcv_selec = DEFAULT_SEL(operator);\n\n\t/* Combine selectivities for MCV and non-MCV populations */\n\tselec = mcv_selec + (1.0 - nullfrac - sumcommon) * non_mcv_selec;\n\n\t/* Result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8(selec);\n}"
  }
]