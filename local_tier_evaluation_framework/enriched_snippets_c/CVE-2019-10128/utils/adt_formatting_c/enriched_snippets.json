[
  {
    "function_name": "float8_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "5717-5814",
    "snippet": "Datum\nfloat8_to_char(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tvalue = PG_GETARG_FLOAT8(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\n\tNUM_TOCHAR_prepare;\n\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman((int) rint(value));\n\telse if (IS_EEEE(&Num))\n\t{\n\t\tif (isnan(value) || is_infinite(value))\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum = (char *) psprintf(\"%+.*e\", Num.post, value);\n\n\t\t\t/*\n\t\t\t * Swap a leading positive sign for a space.\n\t\t\t */\n\t\t\tif (*orgnum == '+')\n\t\t\t\t*orgnum = ' ';\n\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfloat8\t\tval = value;\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tdouble\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tval = value * multi;\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\t\torgnum = psprintf(\"%.0f\", fabs(val));\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* adjust post digits to fit max double digits */\n\t\tif (numstr_pre_len >= DBL_DIG)\n\t\t\tNum.post = 0;\n\t\telse if (numstr_pre_len + Num.post > DBL_DIG)\n\t\t\tNum.post = DBL_DIG - numstr_pre_len;\n\t\torgnum = psprintf(\"%.*f\", Num.post, val);\n\n\t\tif (*orgnum == '-')\n\t\t{\t\t\t\t\t\t/* < 0 */\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */",
      "#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static char *fill_str(char *str, int c, int max);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "numstr",
            "'#'",
            "Num.pre + Num.post + 1"
          ],
          "line": 5807
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "Num.pre + Num.post + 2"
          ],
          "line": 5806
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "numstr"
          ],
          "line": 5798
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "numstr",
            "'.'"
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.*f\"",
            "Num.post",
            "val"
          ],
          "line": 5782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.0f\"",
            "fabs(val)"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "val"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double) 10",
            "(double) Num.multi"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "&Num"
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%+.*e\"",
            "Num.post",
            "value"
          ],
          "line": 5751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "value"
          ],
          "line": 5738
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "value"
          ],
          "line": 5738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "&Num"
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_to_roman",
          "args": [
            "(int) rint(value)"
          ],
          "line": 5735
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_roman",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4122-4163",
          "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
            "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
            "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "value"
          ],
          "line": 5735
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "&Num"
          ],
          "line": 5734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "0"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */\n#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *fill_str(char *str, int c, int max);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\n\nDatum\nfloat8_to_char(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tvalue = PG_GETARG_FLOAT8(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\n\tNUM_TOCHAR_prepare;\n\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman((int) rint(value));\n\telse if (IS_EEEE(&Num))\n\t{\n\t\tif (isnan(value) || is_infinite(value))\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum = (char *) psprintf(\"%+.*e\", Num.post, value);\n\n\t\t\t/*\n\t\t\t * Swap a leading positive sign for a space.\n\t\t\t */\n\t\t\tif (*orgnum == '+')\n\t\t\t\t*orgnum = ' ';\n\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfloat8\t\tval = value;\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tdouble\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tval = value * multi;\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\t\torgnum = psprintf(\"%.0f\", fabs(val));\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* adjust post digits to fit max double digits */\n\t\tif (numstr_pre_len >= DBL_DIG)\n\t\t\tNum.post = 0;\n\t\telse if (numstr_pre_len + Num.post > DBL_DIG)\n\t\t\tNum.post = DBL_DIG - numstr_pre_len;\n\t\torgnum = psprintf(\"%.*f\", Num.post, val);\n\n\t\tif (*orgnum == '-')\n\t\t{\t\t\t\t\t\t/* < 0 */\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "float4_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "5613-5711",
    "snippet": "Datum\nfloat4_to_char(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tvalue = PG_GETARG_FLOAT4(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\n\tNUM_TOCHAR_prepare;\n\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman((int) rint(value));\n\telse if (IS_EEEE(&Num))\n\t{\n\t\tif (isnan(value) || is_infinite(value))\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum = psprintf(\"%+.*e\", Num.post, value);\n\n\t\t\t/*\n\t\t\t * Swap a leading positive sign for a space.\n\t\t\t */\n\t\t\tif (*orgnum == '+')\n\t\t\t\t*orgnum = ' ';\n\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfloat4\t\tval = value;\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tfloat\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tval = value * multi;\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\torgnum = (char *) psprintf(\"%.0f\", fabs(val));\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* adjust post digits to fit max float digits */\n\t\tif (numstr_pre_len >= FLT_DIG)\n\t\t\tNum.post = 0;\n\t\telse if (numstr_pre_len + Num.post > FLT_DIG)\n\t\t\tNum.post = FLT_DIG - numstr_pre_len;\n\t\torgnum = psprintf(\"%.*f\", Num.post, val);\n\n\t\tif (*orgnum == '-')\n\t\t{\t\t\t\t\t\t/* < 0 */\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */",
      "#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static char *fill_str(char *str, int c, int max);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "numstr",
            "'#'",
            "Num.pre + Num.post + 1"
          ],
          "line": 5704
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "Num.pre + Num.post + 2"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "numstr"
          ],
          "line": 5695
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "numstr",
            "'.'"
          ],
          "line": 5692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.*f\"",
            "Num.post",
            "val"
          ],
          "line": 5679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%.0f\"",
            "fabs(val)"
          ],
          "line": 5671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fabs",
          "args": [
            "val"
          ],
          "line": 5671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double) 10",
            "(double) Num.multi"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "&Num"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%+.*e\"",
            "Num.post",
            "value"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "value"
          ],
          "line": 5634
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "value"
          ],
          "line": 5634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "&Num"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_to_roman",
          "args": [
            "(int) rint(value)"
          ],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_roman",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4122-4163",
          "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
            "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
            "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "value"
          ],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "&Num"
          ],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT4",
          "args": [
            "0"
          ],
          "line": 5616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */\n#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *fill_str(char *str, int c, int max);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\n\nDatum\nfloat4_to_char(PG_FUNCTION_ARGS)\n{\n\tfloat4\t\tvalue = PG_GETARG_FLOAT4(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\n\tNUM_TOCHAR_prepare;\n\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman((int) rint(value));\n\telse if (IS_EEEE(&Num))\n\t{\n\t\tif (isnan(value) || is_infinite(value))\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum = psprintf(\"%+.*e\", Num.post, value);\n\n\t\t\t/*\n\t\t\t * Swap a leading positive sign for a space.\n\t\t\t */\n\t\t\tif (*orgnum == '+')\n\t\t\t\t*orgnum = ' ';\n\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfloat4\t\tval = value;\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tfloat\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tval = value * multi;\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\torgnum = (char *) psprintf(\"%.0f\", fabs(val));\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* adjust post digits to fit max float digits */\n\t\tif (numstr_pre_len >= FLT_DIG)\n\t\t\tNum.post = 0;\n\t\telse if (numstr_pre_len + Num.post > FLT_DIG)\n\t\t\tNum.post = FLT_DIG - numstr_pre_len;\n\t\torgnum = psprintf(\"%.*f\", Num.post, val);\n\n\t\tif (*orgnum == '-')\n\t\t{\t\t\t\t\t\t/* < 0 */\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "int8_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "5503-5607",
    "snippet": "Datum\nint8_to_char(PG_FUNCTION_ARGS)\n{\n\tint64\t\tvalue = PG_GETARG_INT64(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (int32)\n\t */\n\tif (IS_ROMAN(&Num))\n\t{\n\t\t/* Currently don't support int8 conversion to roman... */\n\t\tnumstr = orgnum = int_to_roman(DatumGetInt32(\n\t\t\t\t\t\t\t\t\t\t\t\t\t DirectFunctionCall1(int84, Int64GetDatum(value))));\n\t}\n\telse if (IS_EEEE(&Num))\n\t{\n\t\t/* to avoid loss of precision, must go via numeric not float8 */\n\t\tNumeric\t\tval;\n\n\t\tval = DatumGetNumeric(DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value)));\n\t\torgnum = numeric_out_sci(val, Num.post);\n\n\t\t/*\n\t\t * numeric_out_sci() does not emit a sign for positive numbers.  We\n\t\t * need to add a space in this case so that positive and negative\n\t\t * numbers are aligned.  We don't have to worry about NaN here.\n\t\t */\n\t\tif (*orgnum != '-')\n\t\t{\n\t\t\tnumstr = (char *) palloc(strlen(orgnum) + 2);\n\t\t\t*numstr = ' ';\n\t\t\tstrcpy(numstr + 1, orgnum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tdouble\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tvalue = DatumGetInt64(DirectFunctionCall2(int8mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  DirectFunctionCall1(dtoi8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Float8GetDatum(multi))));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\torgnum = DatumGetCString(DirectFunctionCall1(int8out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t Int64GetDatum(value)));\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\torgnum++;\n\t\t}\n\t\telse\n\t\t\tsign = '+';\n\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* post-decimal digits?  Pad out with zeros. */\n\t\tif (Num.post)\n\t\t{\n\t\t\tnumstr = (char *) palloc(numstr_pre_len + Num.post + 2);\n\t\t\tstrcpy(numstr, orgnum);\n\t\t\t*(numstr + numstr_pre_len) = '.';\n\t\t\tmemset(numstr + numstr_pre_len + 1, '0', Num.post);\n\t\t\t*(numstr + numstr_pre_len + Num.post + 1) = '\\0';\n\t\t}\n\t\telse\n\t\t\tnumstr = orgnum;\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */",
      "#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "numstr",
            "'#'",
            "Num.pre + Num.post + 1"
          ],
          "line": 5600
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "Num.pre + Num.post + 2"
          ],
          "line": 5599
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "numstr + numstr_pre_len + 1",
            "'0'",
            "Num.post"
          ],
          "line": 5587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "numstr",
            "orgnum"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orgnum"
          ],
          "line": 5579
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(int8out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t Int64GetDatum(value))"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8out",
            "Int64GetDatum(value)"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "value"
          ],
          "line": 5569
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "DirectFunctionCall2(int8mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  DirectFunctionCall1(dtoi8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Float8GetDatum(multi)))"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "int8mul",
            "Int64GetDatum(value)",
            "DirectFunctionCall1(dtoi8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Float8GetDatum(multi))"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "dtoi8",
            "Float8GetDatum(multi)"
          ],
          "line": 5563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatum",
          "args": [
            "multi"
          ],
          "line": 5564
        },
        "resolved": true,
        "details": {
          "function_name": "Float8GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1900-1907",
          "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double) 10",
            "(double) Num.multi"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "&Num"
          ],
          "line": 5557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numeric_out_sci",
          "args": [
            "val",
            "Num.post"
          ],
          "line": 5535
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_out_sci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numeric.c",
          "lines": "729-746",
          "snippet": "char *\nnumeric_out_sci(Numeric num, int scale)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var_sci(&x, scale);\n\n\treturn str;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double numeric_to_double_no_overflow(Numeric num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"funcapi.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double numeric_to_double_no_overflow(Numeric num);\n\nchar *\nnumeric_out_sci(Numeric num, int scale)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var_sci(&x, scale);\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value))"
          ],
          "line": 5533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(value)"
          ],
          "line": 5533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "&Num"
          ],
          "line": 5528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_to_roman",
          "args": [
            "DatumGetInt32(\n\t\t\t\t\t\t\t\t\t\t\t\t\t DirectFunctionCall1(int84, Int64GetDatum(value)))"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_roman",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4122-4163",
          "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
            "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
            "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "DirectFunctionCall1(int84, Int64GetDatum(value))"
          ],
          "line": 5525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int84",
            "Int64GetDatum(value)"
          ],
          "line": 5526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "&Num"
          ],
          "line": 5522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 5506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */\n#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\n\nDatum\nint8_to_char(PG_FUNCTION_ARGS)\n{\n\tint64\t\tvalue = PG_GETARG_INT64(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (int32)\n\t */\n\tif (IS_ROMAN(&Num))\n\t{\n\t\t/* Currently don't support int8 conversion to roman... */\n\t\tnumstr = orgnum = int_to_roman(DatumGetInt32(\n\t\t\t\t\t\t\t\t\t\t\t\t\t DirectFunctionCall1(int84, Int64GetDatum(value))));\n\t}\n\telse if (IS_EEEE(&Num))\n\t{\n\t\t/* to avoid loss of precision, must go via numeric not float8 */\n\t\tNumeric\t\tval;\n\n\t\tval = DatumGetNumeric(DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value)));\n\t\torgnum = numeric_out_sci(val, Num.post);\n\n\t\t/*\n\t\t * numeric_out_sci() does not emit a sign for positive numbers.  We\n\t\t * need to add a space in this case so that positive and negative\n\t\t * numbers are aligned.  We don't have to worry about NaN here.\n\t\t */\n\t\tif (*orgnum != '-')\n\t\t{\n\t\t\tnumstr = (char *) palloc(strlen(orgnum) + 2);\n\t\t\t*numstr = ' ';\n\t\t\tstrcpy(numstr + 1, orgnum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tdouble\t\tmulti = pow((double) 10, (double) Num.multi);\n\n\t\t\tvalue = DatumGetInt64(DirectFunctionCall2(int8mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  DirectFunctionCall1(dtoi8,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Float8GetDatum(multi))));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\torgnum = DatumGetCString(DirectFunctionCall1(int8out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t Int64GetDatum(value)));\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\torgnum++;\n\t\t}\n\t\telse\n\t\t\tsign = '+';\n\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* post-decimal digits?  Pad out with zeros. */\n\t\tif (Num.post)\n\t\t{\n\t\t\tnumstr = (char *) palloc(numstr_pre_len + Num.post + 2);\n\t\t\tstrcpy(numstr, orgnum);\n\t\t\t*(numstr + numstr_pre_len) = '.';\n\t\t\tmemset(numstr + numstr_pre_len + 1, '0', Num.post);\n\t\t\t*(numstr + numstr_pre_len + Num.post + 1) = '\\0';\n\t\t}\n\t\telse\n\t\t\tnumstr = orgnum;\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "int4_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "5409-5497",
    "snippet": "Datum\nint4_to_char(PG_FUNCTION_ARGS)\n{\n\tint32\t\tvalue = PG_GETARG_INT32(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (int32)\n\t */\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman(value);\n\telse if (IS_EEEE(&Num))\n\t{\n\t\t/* we can do it easily because float8 won't lose any precision */\n\t\tfloat8\t\tval = (float8) value;\n\n\t\torgnum = (char *) psprintf(\"%+.*e\", Num.post, val);\n\n\t\t/*\n\t\t * Swap a leading positive sign for a space.\n\t\t */\n\t\tif (*orgnum == '+')\n\t\t\t*orgnum = ' ';\n\n\t\tnumstr = orgnum;\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\torgnum = DatumGetCString(DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value * ((int32) pow((double) 10, (double) Num.multi)))));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\torgnum = DatumGetCString(DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value)));\n\t\t}\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\torgnum++;\n\t\t}\n\t\telse\n\t\t\tsign = '+';\n\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* post-decimal digits?  Pad out with zeros. */\n\t\tif (Num.post)\n\t\t{\n\t\t\tnumstr = (char *) palloc(numstr_pre_len + Num.post + 2);\n\t\t\tstrcpy(numstr, orgnum);\n\t\t\t*(numstr + numstr_pre_len) = '.';\n\t\t\tmemset(numstr + numstr_pre_len + 1, '0', Num.post);\n\t\t\t*(numstr + numstr_pre_len + Num.post + 1) = '\\0';\n\t\t}\n\t\telse\n\t\t\tnumstr = orgnum;\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */",
      "#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "numstr",
            "'#'",
            "Num.pre + Num.post + 1"
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "Num.pre + Num.post + 2"
          ],
          "line": 5489
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "numstr + numstr_pre_len + 1",
            "'0'",
            "Num.post"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "numstr",
            "orgnum"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orgnum"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value))"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int4out",
            "Int32GetDatum(value)"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "value"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value * ((int32) pow((double) 10, (double) Num.multi))))"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int4out",
            "Int32GetDatum(value * ((int32) pow((double) 10, (double) Num.multi)))"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "value * ((int32) pow((double) 10, (double) Num.multi))"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double) 10",
            "(double) Num.multi"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "&Num"
          ],
          "line": 5449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%+.*e\"",
            "Num.post",
            "val"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "&Num"
          ],
          "line": 5430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_to_roman",
          "args": [
            "value"
          ],
          "line": 5429
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_roman",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4122-4163",
          "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
            "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
            "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "&Num"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 5412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */\n#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\n\nDatum\nint4_to_char(PG_FUNCTION_ARGS)\n{\n\tint32\t\tvalue = PG_GETARG_INT32(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (int32)\n\t */\n\tif (IS_ROMAN(&Num))\n\t\tnumstr = orgnum = int_to_roman(value);\n\telse if (IS_EEEE(&Num))\n\t{\n\t\t/* we can do it easily because float8 won't lose any precision */\n\t\tfloat8\t\tval = (float8) value;\n\n\t\torgnum = (char *) psprintf(\"%+.*e\", Num.post, val);\n\n\t\t/*\n\t\t * Swap a leading positive sign for a space.\n\t\t */\n\t\tif (*orgnum == '+')\n\t\t\t*orgnum = ' ';\n\n\t\tnumstr = orgnum;\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\torgnum = DatumGetCString(DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value * ((int32) pow((double) 10, (double) Num.multi)))));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\torgnum = DatumGetCString(DirectFunctionCall1(int4out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Int32GetDatum(value)));\n\t\t}\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\torgnum++;\n\t\t}\n\t\telse\n\t\t\tsign = '+';\n\n\t\tnumstr_pre_len = strlen(orgnum);\n\n\t\t/* post-decimal digits?  Pad out with zeros. */\n\t\tif (Num.post)\n\t\t{\n\t\t\tnumstr = (char *) palloc(numstr_pre_len + Num.post + 2);\n\t\t\tstrcpy(numstr, orgnum);\n\t\t\t*(numstr + numstr_pre_len) = '.';\n\t\t\tmemset(numstr + numstr_pre_len + 1, '0', Num.post);\n\t\t\t*(numstr + numstr_pre_len + Num.post + 1) = '\\0';\n\t\t}\n\t\telse\n\t\t\tnumstr = orgnum;\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "numeric_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "5285-5403",
    "snippet": "Datum\nnumeric_to_char(PG_FUNCTION_ARGS)\n{\n\tNumeric\t\tvalue = PG_GETARG_NUMERIC(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\tNumeric\t\tx;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (numeric)\n\t */\n\tif (IS_ROMAN(&Num))\n\t{\n\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(0)));\n\t\tnumstr = orgnum =\n\t\t\tint_to_roman(DatumGetInt32(DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(x))));\n\t}\n\telse if (IS_EEEE(&Num))\n\t{\n\t\torgnum = numeric_out_sci(value, Num.post);\n\n\t\t/*\n\t\t * numeric_out_sci() does not emit a sign for positive numbers.  We\n\t\t * need to add a space in this case so that positive and negative\n\t\t * numbers are aligned.  We also have to do the right thing for NaN.\n\t\t */\n\t\tif (strcmp(orgnum, \"NaN\") == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse if (*orgnum != '-')\n\t\t{\n\t\t\tnumstr = (char *) palloc(strlen(orgnum) + 2);\n\t\t\t*numstr = ' ';\n\t\t\tstrcpy(numstr + 1, orgnum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\t\tNumeric\t\tval = value;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tNumeric\t\ta = DatumGetNumeric(DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(10)));\n\t\t\tNumeric\t\tb = DatumGetNumeric(DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.multi)));\n\n\t\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_power,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(a),\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(b)));\n\t\t\tval = DatumGetNumeric(DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(x)));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(val),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.post)));\n\t\torgnum = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(x)));\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */",
      "#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "numstr",
            "'#'",
            "Num.pre + Num.post + 1"
          ],
          "line": 5396
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "Num.pre + Num.post + 2"
          ],
          "line": 5395
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "numstr"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "numstr",
            "'.'"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(x))"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "NumericGetDatum(x)"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "x"
          ],
          "line": 5371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(val),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.post))"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_round",
            "NumericGetDatum(val)",
            "Int32GetDatum(Num.post)"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "Num.post"
          ],
          "line": 5369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "val"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(x))"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_mul",
            "NumericGetDatum(value)",
            "NumericGetDatum(x)"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "x"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "value"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_power,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(a),\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(b))"
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_power",
            "NumericGetDatum(a)",
            "NumericGetDatum(b)"
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "b"
          ],
          "line": 5360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "a"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.multi))"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int4_numeric",
            "Int32GetDatum(Num.multi)"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "Num.multi"
          ],
          "line": 5356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(10))"
          ],
          "line": 5353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int4_numeric",
            "Int32GetDatum(10)"
          ],
          "line": 5353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "10"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "&Num"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "numstr + 1",
            "orgnum"
          ],
          "line": 5339
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orgnum",
            "\"NaN\""
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numeric_out_sci",
          "args": [
            "value",
            "Num.post"
          ],
          "line": 5317
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_out_sci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numeric.c",
          "lines": "729-746",
          "snippet": "char *\nnumeric_out_sci(Numeric num, int scale)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var_sci(&x, scale);\n\n\treturn str;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double numeric_to_double_no_overflow(Numeric num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"funcapi.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double numeric_to_double_no_overflow(Numeric num);\n\nchar *\nnumeric_out_sci(Numeric num, int scale)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var_sci(&x, scale);\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "&Num"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_to_roman",
          "args": [
            "DatumGetInt32(DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(x)))"
          ],
          "line": 5312
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_roman",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4122-4163",
          "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
            "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
            "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(x))"
          ],
          "line": 5312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int4",
            "NumericGetDatum(x)"
          ],
          "line": 5312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "x"
          ],
          "line": 5313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(0))"
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_round",
            "NumericGetDatum(value)",
            "Int32GetDatum(0)"
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "0"
          ],
          "line": 5310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "value"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "&Num"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NUMERIC",
          "args": [
            "0"
          ],
          "line": 5288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TOCHAR_finish \\\ndo { \\\n\tint\t\tlen; \\\n\t\t\t\t\t\t\t\t\t\\\n\tNUM_processor(format, &Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \\\n\t\t\t\t\t\t\t\t\t\\\n\tif (shouldFree)\t\t\t\t\t\\\n\t\tpfree(format);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Convert null-terminated representation of result to standard text. \\\n\t * The result is usually much bigger than it needs to be, but there \\\n\t * seems little point in realloc'ing it smaller. \\\n\t */\n#define NUM_TOCHAR_prepare \\\ndo { \\\n\tint len = VARSIZE_ANY_EXHDR(fmt); \\\n\tif (len <= 0 || len >= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)\t\t\\\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\")); \\\n\tresult\t= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);\t\\\n\tformat\t= NUM_cache(len, &Num, fmt, &shouldFree);\t\t\\\n} while (0)\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\n\nDatum\nnumeric_to_char(PG_FUNCTION_ARGS)\n{\n\tNumeric\t\tvalue = PG_GETARG_NUMERIC(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tNUMDesc\t\tNum;\n\tFormatNode *format;\n\ttext\t   *result;\n\tbool\t\tshouldFree;\n\tint\t\t\tout_pre_spaces = 0,\n\t\t\t\tsign = 0;\n\tchar\t   *numstr,\n\t\t\t   *orgnum,\n\t\t\t   *p;\n\tNumeric\t\tx;\n\n\tNUM_TOCHAR_prepare;\n\n\t/*\n\t * On DateType depend part (numeric)\n\t */\n\tif (IS_ROMAN(&Num))\n\t{\n\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(0)));\n\t\tnumstr = orgnum =\n\t\t\tint_to_roman(DatumGetInt32(DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(x))));\n\t}\n\telse if (IS_EEEE(&Num))\n\t{\n\t\torgnum = numeric_out_sci(value, Num.post);\n\n\t\t/*\n\t\t * numeric_out_sci() does not emit a sign for positive numbers.  We\n\t\t * need to add a space in this case so that positive and negative\n\t\t * numbers are aligned.  We also have to do the right thing for NaN.\n\t\t */\n\t\tif (strcmp(orgnum, \"NaN\") == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Allow 6 characters for the leading sign, the decimal point,\n\t\t\t * \"e\", the exponent's sign and two exponent digits.\n\t\t\t */\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 7);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 6);\n\t\t\t*numstr = ' ';\n\t\t\t*(numstr + Num.pre + 1) = '.';\n\t\t}\n\t\telse if (*orgnum != '-')\n\t\t{\n\t\t\tnumstr = (char *) palloc(strlen(orgnum) + 2);\n\t\t\t*numstr = ' ';\n\t\t\tstrcpy(numstr + 1, orgnum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumstr = orgnum;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint\t\t\tnumstr_pre_len;\n\t\tNumeric\t\tval = value;\n\n\t\tif (IS_MULTI(&Num))\n\t\t{\n\t\t\tNumeric\t\ta = DatumGetNumeric(DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(10)));\n\t\t\tNumeric\t\tb = DatumGetNumeric(DirectFunctionCall1(int4_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.multi)));\n\n\t\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_power,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(a),\n\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(b)));\n\t\t\tval = DatumGetNumeric(DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(x)));\n\t\t\tNum.pre += Num.multi;\n\t\t}\n\n\t\tx = DatumGetNumeric(DirectFunctionCall2(numeric_round,\n\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(val),\n\t\t\t\t\t\t\t\t\t\t\t\tInt32GetDatum(Num.post)));\n\t\torgnum = DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(x)));\n\n\t\tif (*orgnum == '-')\n\t\t{\n\t\t\tsign = '-';\n\t\t\tnumstr = orgnum + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsign = '+';\n\t\t\tnumstr = orgnum;\n\t\t}\n\n\t\tif ((p = strchr(numstr, '.')))\n\t\t\tnumstr_pre_len = p - numstr;\n\t\telse\n\t\t\tnumstr_pre_len = strlen(numstr);\n\n\t\t/* needs padding? */\n\t\tif (numstr_pre_len < Num.pre)\n\t\t\tout_pre_spaces = Num.pre - numstr_pre_len;\n\t\t/* overflowed prefix digit format? */\n\t\telse if (numstr_pre_len > Num.pre)\n\t\t{\n\t\t\tnumstr = (char *) palloc(Num.pre + Num.post + 2);\n\t\t\tfill_str(numstr, '#', Num.pre + Num.post + 1);\n\t\t\t*(numstr + Num.pre) = '.';\n\t\t}\n\t}\n\n\tNUM_TOCHAR_finish;\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "NUM_processor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4707-5182",
    "snippet": "static char *\nNUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid)\n{\n\tFormatNode *n;\n\tNUMProc\t\t_Np,\n\t\t\t   *Np = &_Np;\n\tconst char *pattern;\n\tint\t\t\tpattern_len;\n\n\tMemSet(Np, 0, sizeof(NUMProc));\n\n\tNp->Num = Num;\n\tNp->is_to_char = is_to_char;\n\tNp->number = number;\n\tNp->inout = inout;\n\tNp->last_relevant = NULL;\n\tNp->read_post = 0;\n\tNp->read_pre = 0;\n\tNp->read_dec = false;\n\n\tif (Np->Num->zero_start)\n\t\t--Np->Num->zero_start;\n\n\tif (IS_EEEE(Np->Num))\n\t{\n\t\tif (!Np->is_to_char)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"EEEE\\\" not supported for input\")));\n\t\treturn strcpy(inout, number);\n\t}\n\n\t/*\n\t * Roman correction\n\t */\n\tif (IS_ROMAN(Np->Num))\n\t{\n\t\tif (!Np->is_to_char)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"RN\\\" not supported for input\")));\n\n\t\tNp->Num->lsign = Np->Num->pre_lsign_num = Np->Num->post =\n\t\t\tNp->Num->pre = Np->out_pre_spaces = Np->sign = 0;\n\n\t\tif (IS_FILLMODE(Np->Num))\n\t\t{\n\t\t\tNp->Num->flag = 0;\n\t\t\tNp->Num->flag |= NUM_F_FILLMODE;\n\t\t}\n\t\telse\n\t\t\tNp->Num->flag = 0;\n\t\tNp->Num->flag |= NUM_F_ROMAN;\n\t}\n\n\t/*\n\t * Sign\n\t */\n\tif (is_to_char)\n\t{\n\t\tNp->sign = sign;\n\n\t\t/* MI/PL/SG - write sign itself and not in number */\n\t\tif (IS_PLUS(Np->Num) || IS_MINUS(Np->Num))\n\t\t{\n\t\t\tif (IS_PLUS(Np->Num) && IS_MINUS(Np->Num) == false)\n\t\t\t\tNp->sign_wrote = false; /* need sign */\n\t\t\telse\n\t\t\t\tNp->sign_wrote = true;\t/* needn't sign */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Np->sign != '-')\n\t\t\t{\n\t\t\t\tif (IS_BRACKET(Np->Num) && IS_FILLMODE(Np->Num))\n\t\t\t\t\tNp->Num->flag &= ~NUM_F_BRACKET;\n\t\t\t\tif (IS_MINUS(Np->Num))\n\t\t\t\t\tNp->Num->flag &= ~NUM_F_MINUS;\n\t\t\t}\n\t\t\telse if (Np->sign != '+' && IS_PLUS(Np->Num))\n\t\t\t\tNp->Num->flag &= ~NUM_F_PLUS;\n\n\t\t\tif (Np->sign == '+' && IS_FILLMODE(Np->Num) && IS_LSIGN(Np->Num) == false)\n\t\t\t\tNp->sign_wrote = true;\t/* needn't sign */\n\t\t\telse\n\t\t\t\tNp->sign_wrote = false; /* need sign */\n\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE && Np->Num->pre == Np->Num->pre_lsign_num)\n\t\t\t\tNp->Num->lsign = NUM_LSIGN_POST;\n\t\t}\n\t}\n\telse\n\t\tNp->sign = false;\n\n\t/*\n\t * Count\n\t */\n\tNp->num_count = Np->Num->post + Np->Num->pre - 1;\n\n\tif (is_to_char)\n\t{\n\t\tNp->out_pre_spaces = to_char_out_pre_spaces;\n\n\t\tif (IS_FILLMODE(Np->Num) && IS_DECIMAL(Np->Num))\n\t\t{\n\t\t\tNp->last_relevant = get_last_relevant_decnum(Np->number);\n\n\t\t\t/*\n\t\t\t * If any '0' specifiers are present, make sure we don't strip\n\t\t\t * those digits.\n\t\t\t */\n\t\t\tif (Np->last_relevant && Np->Num->zero_end > Np->out_pre_spaces)\n\t\t\t{\n\t\t\t\tchar\t   *last_zero;\n\n\t\t\t\tlast_zero = Np->number + (Np->Num->zero_end - Np->out_pre_spaces);\n\t\t\t\tif (Np->last_relevant < last_zero)\n\t\t\t\t\tNp->last_relevant = last_zero;\n\t\t\t}\n\t\t}\n\n\t\tif (Np->sign_wrote == false && Np->out_pre_spaces == 0)\n\t\t\t++Np->num_count;\n\t}\n\telse\n\t{\n\t\tNp->out_pre_spaces = 0;\n\t\t*Np->number = ' ';\t\t/* sign space */\n\t\t*(Np->number + 1) = '\\0';\n\t}\n\n\tNp->num_in = 0;\n\tNp->num_curr = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output,\n\t\t \"\\n\\tSIGN: '%c'\\n\\tNUM: '%s'\\n\\tPRE: %d\\n\\tPOST: %d\\n\\tNUM_COUNT: %d\\n\\tNUM_PRE: %d\\n\\tSIGN_WROTE: %s\\n\\tZERO: %s\\n\\tZERO_START: %d\\n\\tZERO_END: %d\\n\\tLAST_RELEVANT: %s\\n\\tBRACKET: %s\\n\\tPLUS: %s\\n\\tMINUS: %s\\n\\tFILLMODE: %s\\n\\tROMAN: %s\\n\\tEEEE: %s\",\n\t\t Np->sign,\n\t\t Np->number,\n\t\t Np->Num->pre,\n\t\t Np->Num->post,\n\t\t Np->num_count,\n\t\t Np->out_pre_spaces,\n\t\t Np->sign_wrote ? \"Yes\" : \"No\",\n\t\t IS_ZERO(Np->Num) ? \"Yes\" : \"No\",\n\t\t Np->Num->zero_start,\n\t\t Np->Num->zero_end,\n\t\t Np->last_relevant ? Np->last_relevant : \"<not set>\",\n\t\t IS_BRACKET(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_PLUS(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_MINUS(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_FILLMODE(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_ROMAN(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_EEEE(Np->Num) ? \"Yes\" : \"No\"\n\t\t);\n#endif\n\n\t/*\n\t * Locale\n\t */\n\tNUM_prepare_locale(Np);\n\n\t/*\n\t * Processor direct cycle\n\t */\n\tif (Np->is_to_char)\n\t\tNp->number_p = Np->number;\n\telse\n\t\tNp->number_p = Np->number + 1;\t/* first char is space for sign */\n\n\tfor (n = node, Np->inout_p = Np->inout; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (!Np->is_to_char)\n\t\t{\n\t\t\t/*\n\t\t\t * Check at least one byte remains to be scanned.  (In actions\n\t\t\t * below, must use AMOUNT_TEST if we want to read more bytes than\n\t\t\t * that.)\n\t\t\t */\n\t\t\tif (OVERLOAD_TEST)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Format pictures actions\n\t\t */\n\t\tif (n->type == NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Create/read digit/zero/blank/sign/special-case\n\t\t\t *\n\t\t\t * 'NUM_S' note: The locale sign is anchored to number and we\n\t\t\t * read/write it when we work with first or last number\n\t\t\t * (NUM_0/NUM_9).  This is why NUM_S is missing in switch().\n\t\t\t *\n\t\t\t * Notice the \"Np->inout_p++\" at the bottom of the loop.  This is\n\t\t\t * why most of the actions advance inout_p one less than you might\n\t\t\t * expect.  In cases where we don't want that increment to happen,\n\t\t\t * a switch case ends with \"continue\" not \"break\".\n\t\t\t */\n\t\t\tswitch (n->key->id)\n\t\t\t{\n\t\t\t\tcase NUM_9:\n\t\t\t\tcase NUM_0:\n\t\t\t\tcase NUM_DEC:\n\t\t\t\tcase NUM_D:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_numpart_to_char(Np, n->key->id);\n\t\t\t\t\t\tcontinue;\t/* for() */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_numpart_from_char(Np, n->key->id, input_len);\n\t\t\t\t\t\tbreak;\t/* switch() case: */\n\t\t\t\t\t}\n\n\t\t\t\tcase NUM_COMMA:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ',';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (*Np->inout_p != ',')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_G:\n\t\t\t\t\tpattern = Np->L_thousands_sep;\n\t\t\t\t\tpattern_len = strlen(pattern);\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* just in case there are MB chars */\n\t\t\t\t\t\t\t\tpattern_len = pg_mbstrlen(pattern);\n\t\t\t\t\t\t\t\tmemset(Np->inout_p, ' ', pattern_len);\n\t\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy(Np->inout_p, pattern);\n\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Because L_thousands_sep typically contains data\n\t\t\t\t\t\t * characters (either '.' or ','), we can't use\n\t\t\t\t\t\t * NUM_eat_non_data_chars here.  Instead skip only if\n\t\t\t\t\t\t * the input matches L_thousands_sep.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (AMOUNT_TEST(pattern_len) &&\n\t\t\t\t\t\t\tstrncmp(Np->inout_p, pattern, pattern_len) == 0)\n\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_L:\n\t\t\t\t\tpattern = Np->L_currency_symbol;\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, pattern);\n\t\t\t\t\t\tNp->inout_p += strlen(pattern) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, pg_mbstrlen(pattern), input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_RN:\n\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, Np->number_p);\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(Np->inout_p, \"%15s\", Np->number_p);\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_rn:\n\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, asc_tolower_z(Np->number_p));\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(Np->inout_p, \"%15s\", asc_tolower_z(Np->number_p));\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_th:\n\t\t\t\t\tif (IS_ROMAN(Np->Num) || *Np->number == '#' ||\n\t\t\t\t\t\tNp->sign == '-' || IS_DECIMAL(Np->Num))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, get_th(Np->number, TH_LOWER));\n\t\t\t\t\t\tNp->inout_p += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* All variants of 'th' occupy 2 characters */\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 2, input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_TH:\n\t\t\t\t\tif (IS_ROMAN(Np->Num) || *Np->number == '#' ||\n\t\t\t\t\t\tNp->sign == '-' || IS_DECIMAL(Np->Num))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, get_th(Np->number, TH_UPPER));\n\t\t\t\t\t\tNp->inout_p += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* All variants of 'TH' occupy 2 characters */\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 2, input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_MI:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\t\t\t*Np->inout_p = '-';\n\t\t\t\t\t\telse if (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '-')\n\t\t\t\t\t\t\t*Np->number = '-';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_PL:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Np->sign == '+')\n\t\t\t\t\t\t\t*Np->inout_p = '+';\n\t\t\t\t\t\telse if (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '+')\n\t\t\t\t\t\t\t*Np->number = '+';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_SG:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t\t*Np->inout_p = Np->sign;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '-')\n\t\t\t\t\t\t\t*Np->number = '-';\n\t\t\t\t\t\telse if (*Np->inout_p == '+')\n\t\t\t\t\t\t\t*Np->number = '+';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In TO_CHAR, non-pattern characters in the format are copied to\n\t\t\t * the output.  In TO_NUMBER, we skip one input character for each\n\t\t\t * non-pattern format character, whether or not it matches the\n\t\t\t * format character.\n\t\t\t */\n\t\t\tif (Np->is_to_char)\n\t\t\t{\n\t\t\t\tstrcpy(Np->inout_p, n->character);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tNp->inout_p++;\n\t}\n\n\tif (Np->is_to_char)\n\t{\n\t\t*Np->inout_p = '\\0';\n\t\treturn Np->inout;\n\t}\n\telse\n\t{\n\t\tif (*(Np->number_p - 1) == '.')\n\t\t\t*(Np->number_p - 1) = '\\0';\n\t\telse\n\t\t\t*Np->number_p = '\\0';\n\n\t\t/*\n\t\t * Correction - precision of dec. number\n\t\t */\n\t\tNp->Num->post = Np->read_post;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"TO_NUMBER (number): '%s'\", Np->number);\n#endif\n\t\treturn Np->number;\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)",
      "#define NUM_LSIGN_POST\t1",
      "#define NUM_LSIGN_PRE\t(-1)",
      "#define NUM_F_ROMAN\t\t\t(1 << 10)",
      "#define NUM_F_PLUS\t\t\t(1 << 9)",
      "#define NUM_F_MINUS\t\t\t(1 << 8)",
      "#define NUM_F_BRACKET\t\t(1 << 7)",
      "#define NUM_F_FILLMODE\t\t(1 << 5)",
      "#define TH_LOWER\t\t2",
      "#define TH_UPPER\t\t1",
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static char *int_to_roman(int number);",
      "static void NUM_prepare_locale(NUMProc *Np);",
      "static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"TO_NUMBER (number): '%s'\"",
            "Np->number"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "Np->inout_p"
          ],
          "line": 5153
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Np->inout_p"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "Np->inout_p",
            "n->character"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUM_eat_non_data_chars",
          "args": [
            "Np",
            "1",
            "input_len"
          ],
          "line": 5127
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_eat_non_data_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4694-4705",
          "snippet": "static void\nNUM_eat_non_data_chars(NUMProc *Np, int n, int input_len)\n{\n\twhile (n-- > 0)\n\t{\n\t\tif (OVERLOAD_TEST)\n\t\t\tbreak;\t\t\t\t/* end of input */\n\t\tif (strchr(\"0123456789.,+-\", *Np->inout_p) != NULL)\n\t\t\tbreak;\t\t\t\t/* it's a data character */\n\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)"
          ],
          "globals_used": [
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void NUM_prepare_locale(NUMProc *Np);",
            "static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)\n\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);\n\nstatic void\nNUM_eat_non_data_chars(NUMProc *Np, int n, int input_len)\n{\n\twhile (n-- > 0)\n\t{\n\t\tif (OVERLOAD_TEST)\n\t\t\tbreak;\t\t\t\t/* end of input */\n\t\tif (strchr(\"0123456789.,+-\", *Np->inout_p) != NULL)\n\t\t\tbreak;\t\t\t\t/* it's a data character */\n\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_th",
          "args": [
            "Np->number",
            "TH_UPPER"
          ],
          "line": 5061
        },
        "resolved": true,
        "details": {
          "function_name": "get_th",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1381-1420",
          "snippet": "static const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TH_UPPER\t\t1"
          ],
          "globals_used": [
            "static const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};",
            "static const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TH_UPPER\t\t1\n\nstatic const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};\nstatic const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 5056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "Np->Num"
          ],
          "line": 5055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 5038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "Np->Num"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "Np->inout_p",
            "\"%15s\"",
            "asc_tolower_z(Np->number_p)"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_tolower_z",
          "args": [
            "Np->number_p"
          ],
          "line": 5031
        },
        "resolved": true,
        "details": {
          "function_name": "asc_tolower_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1994-1998",
          "snippet": "static char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "Np->inout_p",
            "\"%15s\"",
            "Np->number_p"
          ],
          "line": 5018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen",
          "args": [
            "pattern"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "Np->inout_p",
            "pattern",
            "pattern_len"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "pattern_len"
          ],
          "line": 4988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Np->inout_p",
            "' '",
            "pattern_len"
          ],
          "line": 4964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NUM_numpart_from_char",
          "args": [
            "Np",
            "n->key->id",
            "input_len"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_numpart_from_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4289-4492",
          "snippet": "static void\nNUM_numpart_from_char(NUMProc *Np, int id, int input_len)\n{\n\tbool\t\tisread = false;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \" --- scan start --- id=%s\",\n\t\t (id == NUM_0 || id == NUM_9) ? \"NUM_0/9\" : id == NUM_DEC ? \"NUM_DEC\" : \"???\");\n#endif\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\tif (*Np->inout_p == ' ')\n\t\tNp->inout_p++;\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * read sign before number\n\t */\n\tif (*Np->number == ' ' && (id == NUM_0 || id == NUM_9) &&\n\t\t(Np->read_pre + Np->read_post) == 0)\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read sign (%c), locale positive: %s, negative: %s\",\n\t\t\t *Np->inout_p, Np->L_positive_sign, Np->L_negative_sign);\n#endif\n\n\t\t/*\n\t\t * locale sign\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t{\n\t\t\tint\t\t\tx = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale pre-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + - < >\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || (IS_BRACKET(Np->Num) &&\n\t\t\t\t\t\t\t\t\t\t*Np->inout_p == '<'))\n\t\t\t{\n\t\t\t\t*Np->number = '-';\t/* set - */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t\telse if (*Np->inout_p == '+')\n\t\t\t{\n\t\t\t\t*Np->number = '+';\t/* set + */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"Scan for numbers (%c), current number: '%s'\", *Np->inout_p, Np->number);\n#endif\n\n\t/*\n\t * read digit or decimal point\n\t */\n\tif (isdigit((unsigned char) *Np->inout_p))\n\t{\n\t\tif (Np->read_dec && Np->read_post == Np->Num->post)\n\t\t\treturn;\n\n\t\t*Np->number_p = *Np->inout_p;\n\t\tNp->number_p++;\n\n\t\tif (Np->read_dec)\n\t\t\tNp->read_post++;\n\t\telse\n\t\t\tNp->read_pre++;\n\n\t\tisread = true;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Read digit (%c)\", *Np->inout_p);\n#endif\n\t}\n\telse if (IS_DECIMAL(Np->Num) && Np->read_dec == false)\n\t{\n\t\t/*\n\t\t * We need not test IS_LDECIMAL(Np->Num) explicitly here, because\n\t\t * Np->decimal is always just \".\" if we don't have a D format token.\n\t\t * So we just unconditionally match to Np->decimal.\n\t\t */\n\t\tint\t\t\tx = strlen(Np->decimal);\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read decimal point (%c)\",\n\t\t\t *Np->inout_p);\n#endif\n\t\tif (x && AMOUNT_TEST(x) && strncmp(Np->inout_p, Np->decimal, x) == 0)\n\t\t{\n\t\t\tNp->inout_p += x - 1;\n\t\t\t*Np->number_p = '.';\n\t\t\tNp->number_p++;\n\t\t\tNp->read_dec = true;\n\t\t\tisread = true;\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * Read sign behind \"last\" number\n\t *\n\t * We need sign detection because determine exact position of post-sign is\n\t * difficult:\n\t *\n\t * FM9999.9999999S\t   -> 123.001- 9.9S\t\t\t   -> .5- FM9.999999MI ->\n\t * 5.01-\n\t */\n\tif (*Np->number == ' ' && Np->read_pre + Np->read_post > 0)\n\t{\n\t\t/*\n\t\t * locale sign (NUM_S) is always anchored behind a last number, if: -\n\t\t * locale sign expected - last read char was NUM_0/9 or NUM_DEC - and\n\t\t * next char is not digit\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && isread &&\n\t\t\t(Np->inout_p + 1) < Np->inout + input_len &&\n\t\t\t!isdigit((unsigned char) *(Np->inout_p + 1)))\n\t\t{\n\t\t\tint\t\t\tx;\n\t\t\tchar\t   *tmp = Np->inout_p++;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale post-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t\tif (*Np->number == ' ')\n\t\t\t\t/* no sign read */\n\t\t\t\tNp->inout_p = tmp;\n\t\t}\n\n\t\t/*\n\t\t * try read non-locale sign, it's happen only if format is not exact\n\t\t * and we cannot determine sign position of MI/PL/SG, an example:\n\t\t *\n\t\t * FM9.999999MI\t\t\t   -> 5.01-\n\t\t *\n\t\t * if (.... && IS_LSIGN(Np->Num)==false) prevents read wrong formats\n\t\t * like to_number('1 -', '9S') where sign is not anchored to last\n\t\t * number.\n\t\t */\n\t\telse if (isread == false && IS_LSIGN(Np->Num) == false &&\n\t\t\t\t (IS_PLUS(Np->Num) || IS_MINUS(Np->Num)))\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple post-sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + -\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || *Np->inout_p == '+')\n\t\t\t\t/* NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = *Np->inout_p;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)",
            "#define NUM_LSIGN_PRE\t(-1)",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static char *int_to_roman(int number);",
            "static void NUM_prepare_locale(NUMProc *Np);",
            "static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)\n#define NUM_LSIGN_PRE\t(-1)\n#define DEBUG_elog_output\tDEBUG3\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUM_numpart_from_char(NUMProc *Np, int id, int input_len)\n{\n\tbool\t\tisread = false;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \" --- scan start --- id=%s\",\n\t\t (id == NUM_0 || id == NUM_9) ? \"NUM_0/9\" : id == NUM_DEC ? \"NUM_DEC\" : \"???\");\n#endif\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\tif (*Np->inout_p == ' ')\n\t\tNp->inout_p++;\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * read sign before number\n\t */\n\tif (*Np->number == ' ' && (id == NUM_0 || id == NUM_9) &&\n\t\t(Np->read_pre + Np->read_post) == 0)\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read sign (%c), locale positive: %s, negative: %s\",\n\t\t\t *Np->inout_p, Np->L_positive_sign, Np->L_negative_sign);\n#endif\n\n\t\t/*\n\t\t * locale sign\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t{\n\t\t\tint\t\t\tx = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale pre-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + - < >\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || (IS_BRACKET(Np->Num) &&\n\t\t\t\t\t\t\t\t\t\t*Np->inout_p == '<'))\n\t\t\t{\n\t\t\t\t*Np->number = '-';\t/* set - */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t\telse if (*Np->inout_p == '+')\n\t\t\t{\n\t\t\t\t*Np->number = '+';\t/* set + */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"Scan for numbers (%c), current number: '%s'\", *Np->inout_p, Np->number);\n#endif\n\n\t/*\n\t * read digit or decimal point\n\t */\n\tif (isdigit((unsigned char) *Np->inout_p))\n\t{\n\t\tif (Np->read_dec && Np->read_post == Np->Num->post)\n\t\t\treturn;\n\n\t\t*Np->number_p = *Np->inout_p;\n\t\tNp->number_p++;\n\n\t\tif (Np->read_dec)\n\t\t\tNp->read_post++;\n\t\telse\n\t\t\tNp->read_pre++;\n\n\t\tisread = true;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Read digit (%c)\", *Np->inout_p);\n#endif\n\t}\n\telse if (IS_DECIMAL(Np->Num) && Np->read_dec == false)\n\t{\n\t\t/*\n\t\t * We need not test IS_LDECIMAL(Np->Num) explicitly here, because\n\t\t * Np->decimal is always just \".\" if we don't have a D format token.\n\t\t * So we just unconditionally match to Np->decimal.\n\t\t */\n\t\tint\t\t\tx = strlen(Np->decimal);\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read decimal point (%c)\",\n\t\t\t *Np->inout_p);\n#endif\n\t\tif (x && AMOUNT_TEST(x) && strncmp(Np->inout_p, Np->decimal, x) == 0)\n\t\t{\n\t\t\tNp->inout_p += x - 1;\n\t\t\t*Np->number_p = '.';\n\t\t\tNp->number_p++;\n\t\t\tNp->read_dec = true;\n\t\t\tisread = true;\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * Read sign behind \"last\" number\n\t *\n\t * We need sign detection because determine exact position of post-sign is\n\t * difficult:\n\t *\n\t * FM9999.9999999S\t   -> 123.001- 9.9S\t\t\t   -> .5- FM9.999999MI ->\n\t * 5.01-\n\t */\n\tif (*Np->number == ' ' && Np->read_pre + Np->read_post > 0)\n\t{\n\t\t/*\n\t\t * locale sign (NUM_S) is always anchored behind a last number, if: -\n\t\t * locale sign expected - last read char was NUM_0/9 or NUM_DEC - and\n\t\t * next char is not digit\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && isread &&\n\t\t\t(Np->inout_p + 1) < Np->inout + input_len &&\n\t\t\t!isdigit((unsigned char) *(Np->inout_p + 1)))\n\t\t{\n\t\t\tint\t\t\tx;\n\t\t\tchar\t   *tmp = Np->inout_p++;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale post-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t\tif (*Np->number == ' ')\n\t\t\t\t/* no sign read */\n\t\t\t\tNp->inout_p = tmp;\n\t\t}\n\n\t\t/*\n\t\t * try read non-locale sign, it's happen only if format is not exact\n\t\t * and we cannot determine sign position of MI/PL/SG, an example:\n\t\t *\n\t\t * FM9.999999MI\t\t\t   -> 5.01-\n\t\t *\n\t\t * if (.... && IS_LSIGN(Np->Num)==false) prevents read wrong formats\n\t\t * like to_number('1 -', '9S') where sign is not anchored to last\n\t\t * number.\n\t\t */\n\t\telse if (isread == false && IS_LSIGN(Np->Num) == false &&\n\t\t\t\t (IS_PLUS(Np->Num) || IS_MINUS(Np->Num)))\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple post-sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + -\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || *Np->inout_p == '+')\n\t\t\t\t/* NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = *Np->inout_p;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUM_numpart_to_char",
          "args": [
            "Np",
            "n->key->id"
          ],
          "line": 4917
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_numpart_to_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4504-4689",
          "snippet": "static void\nNUM_numpart_to_char(NUMProc *Np, int id)\n{\n\tint\t\t\tend;\n\n\tif (IS_ROMAN(Np->Num))\n\t\treturn;\n\n\t/* Note: in this elog() output not set '\\0' in 'inout' */\n\n#ifdef DEBUG_TO_FROM_CHAR\n\n\t/*\n\t * Np->num_curr is number of current item in format-picture, it is not\n\t * current position in inout!\n\t */\n\telog(DEBUG_elog_output,\n\t\t \"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \\\"%s\\\", INOUT: \\\"%s\\\"\",\n\t\t Np->sign_wrote,\n\t\t Np->num_curr,\n\t\t Np->number_p,\n\t\t Np->inout);\n#endif\n\tNp->num_in = false;\n\n\t/*\n\t * Write sign if real number will write to output Note: IS_PREDEC_SPACE()\n\t * handle \"9.9\" --> \" .1\"\n\t */\n\tif (Np->sign_wrote == false &&\n\t\t(Np->num_curr >= Np->out_pre_spaces || (IS_ZERO(Np->Num) && Np->Num->zero_start == Np->num_curr)) &&\n\t\t(IS_PREDEC_SPACE(Np) == false || (Np->last_relevant && *Np->last_relevant == '.')))\n\t{\n\t\tif (IS_LSIGN(Np->Num))\n\t\t{\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\tNp->sign_wrote = true;\n\t\t\t}\n\t\t}\n\t\telse if (IS_BRACKET(Np->Num))\n\t\t{\n\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '<';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '+')\n\t\t{\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write + */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '-')\n\t\t{\t\t\t\t\t\t/* Write - */\n\t\t\t*Np->inout_p = '-';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t}\n\n\n\t/*\n\t * digits / FM / Zero / Dec. point\n\t */\n\tif (id == NUM_9 || id == NUM_0 || id == NUM_D || id == NUM_DEC)\n\t{\n\t\tif (Np->num_curr < Np->out_pre_spaces &&\n\t\t\t(Np->Num->zero_start > Np->num_curr || !IS_ZERO(Np->Num)))\n\t\t{\n\t\t\t/*\n\t\t\t * Write blank space\n\t\t\t */\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write ' ' */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t}\n\t\telse if (IS_ZERO(Np->Num) &&\n\t\t\t\t Np->num_curr < Np->out_pre_spaces &&\n\t\t\t\t Np->Num->zero_start <= Np->num_curr)\n\t\t{\n\t\t\t/*\n\t\t\t * Write ZERO\n\t\t\t */\n\t\t\t*Np->inout_p = '0'; /* Write '0' */\n\t\t\t++Np->inout_p;\n\t\t\tNp->num_in = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Write Decimal point\n\t\t\t */\n\t\t\tif (*Np->number_p == '.')\n\t\t\t{\n\t\t\t\tif (!Np->last_relevant || *Np->last_relevant != '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ora 'n' -- FM9.9 --> 'n.'\n\t\t\t\t */\n\t\t\t\telse if (IS_FILLMODE(Np->Num) &&\n\t\t\t\t\t\t Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Write Digits\n\t\t\t\t */\n\t\t\t\tif (Np->last_relevant && Np->number_p > Np->last_relevant &&\n\t\t\t\t\tid != NUM_0)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * '0.1' -- 9.9 --> '  .1'\n\t\t\t\t */\n\t\t\t\telse if (IS_PREDEC_SPACE(Np))\n\t\t\t\t{\n\t\t\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * '0' -- FM9.9 --> '0.'\n\t\t\t\t\t */\n\t\t\t\t\telse if (Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = '0';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*Np->inout_p = *Np->number_p;\t/* Write DIGIT */\n\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\tNp->num_in = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* do no exceed string length */\n\t\t\tif (*Np->number_p)\n\t\t\t\t++Np->number_p;\n\t\t}\n\n\t\tend = Np->num_count + (Np->out_pre_spaces ? 1 : 0) + (IS_DECIMAL(Np->Num) ? 1 : 0);\n\n\t\tif (Np->last_relevant && Np->last_relevant == Np->number_p)\n\t\t\tend = Np->num_curr;\n\n\t\tif (Np->num_curr + 1 == end)\n\t\t{\n\t\t\tif (Np->sign_wrote == true && IS_BRACKET(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '>';\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\telse if (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_POST)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t}\n\t}\n\n\t++Np->num_curr;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_LSIGN_POST\t1",
            "#define NUM_LSIGN_PRE\t(-1)",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static char *int_to_roman(int number);",
            "static void NUM_prepare_locale(NUMProc *Np);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_LSIGN_POST\t1\n#define NUM_LSIGN_PRE\t(-1)\n#define DEBUG_elog_output\tDEBUG3\n\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUM_numpart_to_char(NUMProc *Np, int id)\n{\n\tint\t\t\tend;\n\n\tif (IS_ROMAN(Np->Num))\n\t\treturn;\n\n\t/* Note: in this elog() output not set '\\0' in 'inout' */\n\n#ifdef DEBUG_TO_FROM_CHAR\n\n\t/*\n\t * Np->num_curr is number of current item in format-picture, it is not\n\t * current position in inout!\n\t */\n\telog(DEBUG_elog_output,\n\t\t \"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \\\"%s\\\", INOUT: \\\"%s\\\"\",\n\t\t Np->sign_wrote,\n\t\t Np->num_curr,\n\t\t Np->number_p,\n\t\t Np->inout);\n#endif\n\tNp->num_in = false;\n\n\t/*\n\t * Write sign if real number will write to output Note: IS_PREDEC_SPACE()\n\t * handle \"9.9\" --> \" .1\"\n\t */\n\tif (Np->sign_wrote == false &&\n\t\t(Np->num_curr >= Np->out_pre_spaces || (IS_ZERO(Np->Num) && Np->Num->zero_start == Np->num_curr)) &&\n\t\t(IS_PREDEC_SPACE(Np) == false || (Np->last_relevant && *Np->last_relevant == '.')))\n\t{\n\t\tif (IS_LSIGN(Np->Num))\n\t\t{\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\tNp->sign_wrote = true;\n\t\t\t}\n\t\t}\n\t\telse if (IS_BRACKET(Np->Num))\n\t\t{\n\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '<';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '+')\n\t\t{\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write + */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '-')\n\t\t{\t\t\t\t\t\t/* Write - */\n\t\t\t*Np->inout_p = '-';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t}\n\n\n\t/*\n\t * digits / FM / Zero / Dec. point\n\t */\n\tif (id == NUM_9 || id == NUM_0 || id == NUM_D || id == NUM_DEC)\n\t{\n\t\tif (Np->num_curr < Np->out_pre_spaces &&\n\t\t\t(Np->Num->zero_start > Np->num_curr || !IS_ZERO(Np->Num)))\n\t\t{\n\t\t\t/*\n\t\t\t * Write blank space\n\t\t\t */\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write ' ' */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t}\n\t\telse if (IS_ZERO(Np->Num) &&\n\t\t\t\t Np->num_curr < Np->out_pre_spaces &&\n\t\t\t\t Np->Num->zero_start <= Np->num_curr)\n\t\t{\n\t\t\t/*\n\t\t\t * Write ZERO\n\t\t\t */\n\t\t\t*Np->inout_p = '0'; /* Write '0' */\n\t\t\t++Np->inout_p;\n\t\t\tNp->num_in = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Write Decimal point\n\t\t\t */\n\t\t\tif (*Np->number_p == '.')\n\t\t\t{\n\t\t\t\tif (!Np->last_relevant || *Np->last_relevant != '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ora 'n' -- FM9.9 --> 'n.'\n\t\t\t\t */\n\t\t\t\telse if (IS_FILLMODE(Np->Num) &&\n\t\t\t\t\t\t Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Write Digits\n\t\t\t\t */\n\t\t\t\tif (Np->last_relevant && Np->number_p > Np->last_relevant &&\n\t\t\t\t\tid != NUM_0)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * '0.1' -- 9.9 --> '  .1'\n\t\t\t\t */\n\t\t\t\telse if (IS_PREDEC_SPACE(Np))\n\t\t\t\t{\n\t\t\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * '0' -- FM9.9 --> '0.'\n\t\t\t\t\t */\n\t\t\t\t\telse if (Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = '0';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*Np->inout_p = *Np->number_p;\t/* Write DIGIT */\n\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\tNp->num_in = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* do no exceed string length */\n\t\t\tif (*Np->number_p)\n\t\t\t\t++Np->number_p;\n\t\t}\n\n\t\tend = Np->num_count + (Np->out_pre_spaces ? 1 : 0) + (IS_DECIMAL(Np->Num) ? 1 : 0);\n\n\t\tif (Np->last_relevant && Np->last_relevant == Np->number_p)\n\t\t\tend = Np->num_curr;\n\n\t\tif (Np->num_curr + 1 == end)\n\t\t{\n\t\t\tif (Np->sign_wrote == true && IS_BRACKET(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '>';\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\telse if (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_POST)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t}\n\t}\n\n\t++Np->num_curr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUM_prepare_locale",
          "args": [
            "Np"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_prepare_locale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4171-4243",
          "snippet": "static void\nNUM_prepare_locale(NUMProc *Np)\n{\n\tif (Np->Num->need_locale)\n\t{\n\t\tstruct lconv *lconv;\n\n\t\t/*\n\t\t * Get locales\n\t\t */\n\t\tlconv = PGLC_localeconv();\n\n\t\t/*\n\t\t * Positive / Negative number sign\n\t\t */\n\t\tif (lconv->negative_sign && *lconv->negative_sign)\n\t\t\tNp->L_negative_sign = lconv->negative_sign;\n\t\telse\n\t\t\tNp->L_negative_sign = \"-\";\n\n\t\tif (lconv->positive_sign && *lconv->positive_sign)\n\t\t\tNp->L_positive_sign = lconv->positive_sign;\n\t\telse\n\t\t\tNp->L_positive_sign = \"+\";\n\n\t\t/*\n\t\t * Number decimal point\n\t\t */\n\t\tif (lconv->decimal_point && *lconv->decimal_point)\n\t\t\tNp->decimal = lconv->decimal_point;\n\n\t\telse\n\t\t\tNp->decimal = \".\";\n\n\t\tif (!IS_LDECIMAL(Np->Num))\n\t\t\tNp->decimal = \".\";\n\n\t\t/*\n\t\t * Number thousands separator\n\t\t *\n\t\t * Some locales (e.g. broken glibc pt_BR), have a comma for decimal,\n\t\t * but \"\" for thousands_sep, so we set the thousands_sep too.\n\t\t * http://archives.postgresql.org/pgsql-hackers/2007-11/msg00772.php\n\t\t */\n\t\tif (lconv->thousands_sep && *lconv->thousands_sep)\n\t\t\tNp->L_thousands_sep = lconv->thousands_sep;\n\t\t/* Make sure thousands separator doesn't match decimal point symbol. */\n\t\telse if (strcmp(Np->decimal, \",\") !=0)\n\t\t\tNp->L_thousands_sep = \",\";\n\t\telse\n\t\t\tNp->L_thousands_sep = \".\";\n\n\t\t/*\n\t\t * Currency symbol\n\t\t */\n\t\tif (lconv->currency_symbol && *lconv->currency_symbol)\n\t\t\tNp->L_currency_symbol = lconv->currency_symbol;\n\t\telse\n\t\t\tNp->L_currency_symbol = \" \";\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Default values\n\t\t */\n\t\tNp->L_negative_sign = \"-\";\n\t\tNp->L_positive_sign = \"+\";\n\t\tNp->decimal = \".\";\n\n\t\tNp->L_thousands_sep = \",\";\n\t\tNp->L_currency_symbol = \" \";\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static char *int_to_roman(int number);",
            "static void NUM_prepare_locale(NUMProc *Np);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\n\nstatic void\nNUM_prepare_locale(NUMProc *Np)\n{\n\tif (Np->Num->need_locale)\n\t{\n\t\tstruct lconv *lconv;\n\n\t\t/*\n\t\t * Get locales\n\t\t */\n\t\tlconv = PGLC_localeconv();\n\n\t\t/*\n\t\t * Positive / Negative number sign\n\t\t */\n\t\tif (lconv->negative_sign && *lconv->negative_sign)\n\t\t\tNp->L_negative_sign = lconv->negative_sign;\n\t\telse\n\t\t\tNp->L_negative_sign = \"-\";\n\n\t\tif (lconv->positive_sign && *lconv->positive_sign)\n\t\t\tNp->L_positive_sign = lconv->positive_sign;\n\t\telse\n\t\t\tNp->L_positive_sign = \"+\";\n\n\t\t/*\n\t\t * Number decimal point\n\t\t */\n\t\tif (lconv->decimal_point && *lconv->decimal_point)\n\t\t\tNp->decimal = lconv->decimal_point;\n\n\t\telse\n\t\t\tNp->decimal = \".\";\n\n\t\tif (!IS_LDECIMAL(Np->Num))\n\t\t\tNp->decimal = \".\";\n\n\t\t/*\n\t\t * Number thousands separator\n\t\t *\n\t\t * Some locales (e.g. broken glibc pt_BR), have a comma for decimal,\n\t\t * but \"\" for thousands_sep, so we set the thousands_sep too.\n\t\t * http://archives.postgresql.org/pgsql-hackers/2007-11/msg00772.php\n\t\t */\n\t\tif (lconv->thousands_sep && *lconv->thousands_sep)\n\t\t\tNp->L_thousands_sep = lconv->thousands_sep;\n\t\t/* Make sure thousands separator doesn't match decimal point symbol. */\n\t\telse if (strcmp(Np->decimal, \",\") !=0)\n\t\t\tNp->L_thousands_sep = \",\";\n\t\telse\n\t\t\tNp->L_thousands_sep = \".\";\n\n\t\t/*\n\t\t * Currency symbol\n\t\t */\n\t\tif (lconv->currency_symbol && *lconv->currency_symbol)\n\t\t\tNp->L_currency_symbol = lconv->currency_symbol;\n\t\telse\n\t\t\tNp->L_currency_symbol = \" \";\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Default values\n\t\t */\n\t\tNp->L_negative_sign = \"-\";\n\t\tNp->L_positive_sign = \"+\";\n\t\tNp->decimal = \".\";\n\n\t\tNp->L_thousands_sep = \",\";\n\t\tNp->L_currency_symbol = \" \";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "Np->Num"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "Np->Num"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "Np->Num"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "Np->Num"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "Np->Num"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "Np->Num"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_relevant_decnum",
          "args": [
            "Np->number"
          ],
          "line": 4814
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_relevant_decnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4253-4275",
          "snippet": "static char *\nget_last_relevant_decnum(char *num)\n{\n\tchar\t   *result,\n\t\t\t   *p = strchr(num, '.');\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"get_last_relevant_decnum()\");\n#endif\n\n\tif (!p)\n\t\treturn NULL;\n\n\tresult = p;\n\n\twhile (*(++p))\n\t{\n\t\tif (*p != '0')\n\t\t\tresult = p;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DEBUG_elog_output\tDEBUG3\n\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nget_last_relevant_decnum(char *num)\n{\n\tchar\t   *result,\n\t\t\t   *p = strchr(num, '.');\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"get_last_relevant_decnum()\");\n#endif\n\n\tif (!p)\n\t\treturn NULL;\n\n\tresult = p;\n\n\twhile (*(++p))\n\t{\n\t\tif (*p != '0')\n\t\t\tresult = p;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "Np->Num"
          ],
          "line": 4788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "Np->Num"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "Np->Num"
          ],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "Np->Num"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "Np->Num"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "Np->Num"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "Np->Num"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"RN\\\" not supported for input\"))"
          ],
          "line": 4747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"RN\\\" not supported for input\""
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "Np->Num"
          ],
          "line": 4744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"EEEE\\\" not supported for input\"))"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "Np->Num"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "Np",
            "0",
            "sizeof(NUMProc)"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)\n#define NUM_LSIGN_POST\t1\n#define NUM_LSIGN_PRE\t(-1)\n#define NUM_F_ROMAN\t\t\t(1 << 10)\n#define NUM_F_PLUS\t\t\t(1 << 9)\n#define NUM_F_MINUS\t\t\t(1 << 8)\n#define NUM_F_BRACKET\t\t(1 << 7)\n#define NUM_F_FILLMODE\t\t(1 << 5)\n#define TH_LOWER\t\t2\n#define TH_UPPER\t\t1\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nNUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid)\n{\n\tFormatNode *n;\n\tNUMProc\t\t_Np,\n\t\t\t   *Np = &_Np;\n\tconst char *pattern;\n\tint\t\t\tpattern_len;\n\n\tMemSet(Np, 0, sizeof(NUMProc));\n\n\tNp->Num = Num;\n\tNp->is_to_char = is_to_char;\n\tNp->number = number;\n\tNp->inout = inout;\n\tNp->last_relevant = NULL;\n\tNp->read_post = 0;\n\tNp->read_pre = 0;\n\tNp->read_dec = false;\n\n\tif (Np->Num->zero_start)\n\t\t--Np->Num->zero_start;\n\n\tif (IS_EEEE(Np->Num))\n\t{\n\t\tif (!Np->is_to_char)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"EEEE\\\" not supported for input\")));\n\t\treturn strcpy(inout, number);\n\t}\n\n\t/*\n\t * Roman correction\n\t */\n\tif (IS_ROMAN(Np->Num))\n\t{\n\t\tif (!Np->is_to_char)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"\\\"RN\\\" not supported for input\")));\n\n\t\tNp->Num->lsign = Np->Num->pre_lsign_num = Np->Num->post =\n\t\t\tNp->Num->pre = Np->out_pre_spaces = Np->sign = 0;\n\n\t\tif (IS_FILLMODE(Np->Num))\n\t\t{\n\t\t\tNp->Num->flag = 0;\n\t\t\tNp->Num->flag |= NUM_F_FILLMODE;\n\t\t}\n\t\telse\n\t\t\tNp->Num->flag = 0;\n\t\tNp->Num->flag |= NUM_F_ROMAN;\n\t}\n\n\t/*\n\t * Sign\n\t */\n\tif (is_to_char)\n\t{\n\t\tNp->sign = sign;\n\n\t\t/* MI/PL/SG - write sign itself and not in number */\n\t\tif (IS_PLUS(Np->Num) || IS_MINUS(Np->Num))\n\t\t{\n\t\t\tif (IS_PLUS(Np->Num) && IS_MINUS(Np->Num) == false)\n\t\t\t\tNp->sign_wrote = false; /* need sign */\n\t\t\telse\n\t\t\t\tNp->sign_wrote = true;\t/* needn't sign */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Np->sign != '-')\n\t\t\t{\n\t\t\t\tif (IS_BRACKET(Np->Num) && IS_FILLMODE(Np->Num))\n\t\t\t\t\tNp->Num->flag &= ~NUM_F_BRACKET;\n\t\t\t\tif (IS_MINUS(Np->Num))\n\t\t\t\t\tNp->Num->flag &= ~NUM_F_MINUS;\n\t\t\t}\n\t\t\telse if (Np->sign != '+' && IS_PLUS(Np->Num))\n\t\t\t\tNp->Num->flag &= ~NUM_F_PLUS;\n\n\t\t\tif (Np->sign == '+' && IS_FILLMODE(Np->Num) && IS_LSIGN(Np->Num) == false)\n\t\t\t\tNp->sign_wrote = true;\t/* needn't sign */\n\t\t\telse\n\t\t\t\tNp->sign_wrote = false; /* need sign */\n\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE && Np->Num->pre == Np->Num->pre_lsign_num)\n\t\t\t\tNp->Num->lsign = NUM_LSIGN_POST;\n\t\t}\n\t}\n\telse\n\t\tNp->sign = false;\n\n\t/*\n\t * Count\n\t */\n\tNp->num_count = Np->Num->post + Np->Num->pre - 1;\n\n\tif (is_to_char)\n\t{\n\t\tNp->out_pre_spaces = to_char_out_pre_spaces;\n\n\t\tif (IS_FILLMODE(Np->Num) && IS_DECIMAL(Np->Num))\n\t\t{\n\t\t\tNp->last_relevant = get_last_relevant_decnum(Np->number);\n\n\t\t\t/*\n\t\t\t * If any '0' specifiers are present, make sure we don't strip\n\t\t\t * those digits.\n\t\t\t */\n\t\t\tif (Np->last_relevant && Np->Num->zero_end > Np->out_pre_spaces)\n\t\t\t{\n\t\t\t\tchar\t   *last_zero;\n\n\t\t\t\tlast_zero = Np->number + (Np->Num->zero_end - Np->out_pre_spaces);\n\t\t\t\tif (Np->last_relevant < last_zero)\n\t\t\t\t\tNp->last_relevant = last_zero;\n\t\t\t}\n\t\t}\n\n\t\tif (Np->sign_wrote == false && Np->out_pre_spaces == 0)\n\t\t\t++Np->num_count;\n\t}\n\telse\n\t{\n\t\tNp->out_pre_spaces = 0;\n\t\t*Np->number = ' ';\t\t/* sign space */\n\t\t*(Np->number + 1) = '\\0';\n\t}\n\n\tNp->num_in = 0;\n\tNp->num_curr = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output,\n\t\t \"\\n\\tSIGN: '%c'\\n\\tNUM: '%s'\\n\\tPRE: %d\\n\\tPOST: %d\\n\\tNUM_COUNT: %d\\n\\tNUM_PRE: %d\\n\\tSIGN_WROTE: %s\\n\\tZERO: %s\\n\\tZERO_START: %d\\n\\tZERO_END: %d\\n\\tLAST_RELEVANT: %s\\n\\tBRACKET: %s\\n\\tPLUS: %s\\n\\tMINUS: %s\\n\\tFILLMODE: %s\\n\\tROMAN: %s\\n\\tEEEE: %s\",\n\t\t Np->sign,\n\t\t Np->number,\n\t\t Np->Num->pre,\n\t\t Np->Num->post,\n\t\t Np->num_count,\n\t\t Np->out_pre_spaces,\n\t\t Np->sign_wrote ? \"Yes\" : \"No\",\n\t\t IS_ZERO(Np->Num) ? \"Yes\" : \"No\",\n\t\t Np->Num->zero_start,\n\t\t Np->Num->zero_end,\n\t\t Np->last_relevant ? Np->last_relevant : \"<not set>\",\n\t\t IS_BRACKET(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_PLUS(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_MINUS(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_FILLMODE(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_ROMAN(Np->Num) ? \"Yes\" : \"No\",\n\t\t IS_EEEE(Np->Num) ? \"Yes\" : \"No\"\n\t\t);\n#endif\n\n\t/*\n\t * Locale\n\t */\n\tNUM_prepare_locale(Np);\n\n\t/*\n\t * Processor direct cycle\n\t */\n\tif (Np->is_to_char)\n\t\tNp->number_p = Np->number;\n\telse\n\t\tNp->number_p = Np->number + 1;\t/* first char is space for sign */\n\n\tfor (n = node, Np->inout_p = Np->inout; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (!Np->is_to_char)\n\t\t{\n\t\t\t/*\n\t\t\t * Check at least one byte remains to be scanned.  (In actions\n\t\t\t * below, must use AMOUNT_TEST if we want to read more bytes than\n\t\t\t * that.)\n\t\t\t */\n\t\t\tif (OVERLOAD_TEST)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Format pictures actions\n\t\t */\n\t\tif (n->type == NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Create/read digit/zero/blank/sign/special-case\n\t\t\t *\n\t\t\t * 'NUM_S' note: The locale sign is anchored to number and we\n\t\t\t * read/write it when we work with first or last number\n\t\t\t * (NUM_0/NUM_9).  This is why NUM_S is missing in switch().\n\t\t\t *\n\t\t\t * Notice the \"Np->inout_p++\" at the bottom of the loop.  This is\n\t\t\t * why most of the actions advance inout_p one less than you might\n\t\t\t * expect.  In cases where we don't want that increment to happen,\n\t\t\t * a switch case ends with \"continue\" not \"break\".\n\t\t\t */\n\t\t\tswitch (n->key->id)\n\t\t\t{\n\t\t\t\tcase NUM_9:\n\t\t\t\tcase NUM_0:\n\t\t\t\tcase NUM_DEC:\n\t\t\t\tcase NUM_D:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_numpart_to_char(Np, n->key->id);\n\t\t\t\t\t\tcontinue;\t/* for() */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_numpart_from_char(Np, n->key->id, input_len);\n\t\t\t\t\t\tbreak;\t/* switch() case: */\n\t\t\t\t\t}\n\n\t\t\t\tcase NUM_COMMA:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ',';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (*Np->inout_p != ',')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_G:\n\t\t\t\t\tpattern = Np->L_thousands_sep;\n\t\t\t\t\tpattern_len = strlen(pattern);\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* just in case there are MB chars */\n\t\t\t\t\t\t\t\tpattern_len = pg_mbstrlen(pattern);\n\t\t\t\t\t\t\t\tmemset(Np->inout_p, ' ', pattern_len);\n\t\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy(Np->inout_p, pattern);\n\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Np->num_in)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Because L_thousands_sep typically contains data\n\t\t\t\t\t\t * characters (either '.' or ','), we can't use\n\t\t\t\t\t\t * NUM_eat_non_data_chars here.  Instead skip only if\n\t\t\t\t\t\t * the input matches L_thousands_sep.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (AMOUNT_TEST(pattern_len) &&\n\t\t\t\t\t\t\tstrncmp(Np->inout_p, pattern, pattern_len) == 0)\n\t\t\t\t\t\t\tNp->inout_p += pattern_len - 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_L:\n\t\t\t\t\tpattern = Np->L_currency_symbol;\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, pattern);\n\t\t\t\t\t\tNp->inout_p += strlen(pattern) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, pg_mbstrlen(pattern), input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_RN:\n\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, Np->number_p);\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(Np->inout_p, \"%15s\", Np->number_p);\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_rn:\n\t\t\t\t\tif (IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, asc_tolower_z(Np->number_p));\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(Np->inout_p, \"%15s\", asc_tolower_z(Np->number_p));\n\t\t\t\t\t\tNp->inout_p += strlen(Np->inout_p) - 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_th:\n\t\t\t\t\tif (IS_ROMAN(Np->Num) || *Np->number == '#' ||\n\t\t\t\t\t\tNp->sign == '-' || IS_DECIMAL(Np->Num))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, get_th(Np->number, TH_LOWER));\n\t\t\t\t\t\tNp->inout_p += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* All variants of 'th' occupy 2 characters */\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 2, input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_TH:\n\t\t\t\t\tif (IS_ROMAN(Np->Num) || *Np->number == '#' ||\n\t\t\t\t\t\tNp->sign == '-' || IS_DECIMAL(Np->Num))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(Np->inout_p, get_th(Np->number, TH_UPPER));\n\t\t\t\t\t\tNp->inout_p += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* All variants of 'TH' occupy 2 characters */\n\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 2, input_len);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_MI:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\t\t\t*Np->inout_p = '-';\n\t\t\t\t\t\telse if (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '-')\n\t\t\t\t\t\t\t*Np->number = '-';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_PL:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Np->sign == '+')\n\t\t\t\t\t\t\t*Np->inout_p = '+';\n\t\t\t\t\t\telse if (IS_FILLMODE(Np->Num))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '+')\n\t\t\t\t\t\t\t*Np->number = '+';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NUM_SG:\n\t\t\t\t\tif (Np->is_to_char)\n\t\t\t\t\t\t*Np->inout_p = Np->sign;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*Np->inout_p == '-')\n\t\t\t\t\t\t\t*Np->number = '-';\n\t\t\t\t\t\telse if (*Np->inout_p == '+')\n\t\t\t\t\t\t\t*Np->number = '+';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNUM_eat_non_data_chars(Np, 1, input_len);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In TO_CHAR, non-pattern characters in the format are copied to\n\t\t\t * the output.  In TO_NUMBER, we skip one input character for each\n\t\t\t * non-pattern format character, whether or not it matches the\n\t\t\t * format character.\n\t\t\t */\n\t\t\tif (Np->is_to_char)\n\t\t\t{\n\t\t\t\tstrcpy(Np->inout_p, n->character);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tNp->inout_p++;\n\t}\n\n\tif (Np->is_to_char)\n\t{\n\t\t*Np->inout_p = '\\0';\n\t\treturn Np->inout;\n\t}\n\telse\n\t{\n\t\tif (*(Np->number_p - 1) == '.')\n\t\t\t*(Np->number_p - 1) = '\\0';\n\t\telse\n\t\t\t*Np->number_p = '\\0';\n\n\t\t/*\n\t\t * Correction - precision of dec. number\n\t\t */\n\t\tNp->Num->post = Np->read_post;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"TO_NUMBER (number): '%s'\", Np->number);\n#endif\n\t\treturn Np->number;\n\t}\n}"
  },
  {
    "function_name": "NUM_eat_non_data_chars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4694-4705",
    "snippet": "static void\nNUM_eat_non_data_chars(NUMProc *Np, int n, int input_len)\n{\n\twhile (n-- > 0)\n\t{\n\t\tif (OVERLOAD_TEST)\n\t\t\tbreak;\t\t\t\t/* end of input */\n\t\tif (strchr(\"0123456789.,+-\", *Np->inout_p) != NULL)\n\t\t\tbreak;\t\t\t\t/* it's a data character */\n\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)"
    ],
    "globals_used": [
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void NUM_prepare_locale(NUMProc *Np);",
      "static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "Np->inout_p"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"0123456789.,+-\"",
            "*Np->inout_p"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)\n\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);\n\nstatic void\nNUM_eat_non_data_chars(NUMProc *Np, int n, int input_len)\n{\n\twhile (n-- > 0)\n\t{\n\t\tif (OVERLOAD_TEST)\n\t\t\tbreak;\t\t\t\t/* end of input */\n\t\tif (strchr(\"0123456789.,+-\", *Np->inout_p) != NULL)\n\t\t\tbreak;\t\t\t\t/* it's a data character */\n\t\tNp->inout_p += pg_mblen(Np->inout_p);\n\t}\n}"
  },
  {
    "function_name": "NUM_numpart_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4504-4689",
    "snippet": "static void\nNUM_numpart_to_char(NUMProc *Np, int id)\n{\n\tint\t\t\tend;\n\n\tif (IS_ROMAN(Np->Num))\n\t\treturn;\n\n\t/* Note: in this elog() output not set '\\0' in 'inout' */\n\n#ifdef DEBUG_TO_FROM_CHAR\n\n\t/*\n\t * Np->num_curr is number of current item in format-picture, it is not\n\t * current position in inout!\n\t */\n\telog(DEBUG_elog_output,\n\t\t \"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \\\"%s\\\", INOUT: \\\"%s\\\"\",\n\t\t Np->sign_wrote,\n\t\t Np->num_curr,\n\t\t Np->number_p,\n\t\t Np->inout);\n#endif\n\tNp->num_in = false;\n\n\t/*\n\t * Write sign if real number will write to output Note: IS_PREDEC_SPACE()\n\t * handle \"9.9\" --> \" .1\"\n\t */\n\tif (Np->sign_wrote == false &&\n\t\t(Np->num_curr >= Np->out_pre_spaces || (IS_ZERO(Np->Num) && Np->Num->zero_start == Np->num_curr)) &&\n\t\t(IS_PREDEC_SPACE(Np) == false || (Np->last_relevant && *Np->last_relevant == '.')))\n\t{\n\t\tif (IS_LSIGN(Np->Num))\n\t\t{\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\tNp->sign_wrote = true;\n\t\t\t}\n\t\t}\n\t\telse if (IS_BRACKET(Np->Num))\n\t\t{\n\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '<';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '+')\n\t\t{\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write + */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '-')\n\t\t{\t\t\t\t\t\t/* Write - */\n\t\t\t*Np->inout_p = '-';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t}\n\n\n\t/*\n\t * digits / FM / Zero / Dec. point\n\t */\n\tif (id == NUM_9 || id == NUM_0 || id == NUM_D || id == NUM_DEC)\n\t{\n\t\tif (Np->num_curr < Np->out_pre_spaces &&\n\t\t\t(Np->Num->zero_start > Np->num_curr || !IS_ZERO(Np->Num)))\n\t\t{\n\t\t\t/*\n\t\t\t * Write blank space\n\t\t\t */\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write ' ' */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t}\n\t\telse if (IS_ZERO(Np->Num) &&\n\t\t\t\t Np->num_curr < Np->out_pre_spaces &&\n\t\t\t\t Np->Num->zero_start <= Np->num_curr)\n\t\t{\n\t\t\t/*\n\t\t\t * Write ZERO\n\t\t\t */\n\t\t\t*Np->inout_p = '0'; /* Write '0' */\n\t\t\t++Np->inout_p;\n\t\t\tNp->num_in = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Write Decimal point\n\t\t\t */\n\t\t\tif (*Np->number_p == '.')\n\t\t\t{\n\t\t\t\tif (!Np->last_relevant || *Np->last_relevant != '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ora 'n' -- FM9.9 --> 'n.'\n\t\t\t\t */\n\t\t\t\telse if (IS_FILLMODE(Np->Num) &&\n\t\t\t\t\t\t Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Write Digits\n\t\t\t\t */\n\t\t\t\tif (Np->last_relevant && Np->number_p > Np->last_relevant &&\n\t\t\t\t\tid != NUM_0)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * '0.1' -- 9.9 --> '  .1'\n\t\t\t\t */\n\t\t\t\telse if (IS_PREDEC_SPACE(Np))\n\t\t\t\t{\n\t\t\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * '0' -- FM9.9 --> '0.'\n\t\t\t\t\t */\n\t\t\t\t\telse if (Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = '0';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*Np->inout_p = *Np->number_p;\t/* Write DIGIT */\n\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\tNp->num_in = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* do no exceed string length */\n\t\t\tif (*Np->number_p)\n\t\t\t\t++Np->number_p;\n\t\t}\n\n\t\tend = Np->num_count + (Np->out_pre_spaces ? 1 : 0) + (IS_DECIMAL(Np->Num) ? 1 : 0);\n\n\t\tif (Np->last_relevant && Np->last_relevant == Np->number_p)\n\t\t\tend = Np->num_curr;\n\n\t\tif (Np->num_curr + 1 == end)\n\t\t{\n\t\t\tif (Np->sign_wrote == true && IS_BRACKET(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '>';\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\telse if (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_POST)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t}\n\t}\n\n\t++Np->num_curr;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_LSIGN_POST\t1",
      "#define NUM_LSIGN_PRE\t(-1)",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static char *int_to_roman(int number);",
      "static void NUM_prepare_locale(NUMProc *Np);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Np->inout_p"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "Np->inout_p",
            "Np->L_positive_sign"
          ],
          "line": 4682
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "Np->Num"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PREDEC_SPACE",
          "args": [
            "Np"
          ],
          "line": 4636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "Np->Num"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "Np->Num"
          ],
          "line": 4579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "Np->Num"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "Np->Num"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PREDEC_SPACE",
          "args": [
            "Np"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "Np->Num"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \\\"%s\\\", INOUT: \\\"%s\\\"\"",
            "Np->sign_wrote",
            "Np->num_curr",
            "Np->number_p",
            "Np->inout"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "Np->Num"
          ],
          "line": 4509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_LSIGN_POST\t1\n#define NUM_LSIGN_PRE\t(-1)\n#define DEBUG_elog_output\tDEBUG3\n\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUM_numpart_to_char(NUMProc *Np, int id)\n{\n\tint\t\t\tend;\n\n\tif (IS_ROMAN(Np->Num))\n\t\treturn;\n\n\t/* Note: in this elog() output not set '\\0' in 'inout' */\n\n#ifdef DEBUG_TO_FROM_CHAR\n\n\t/*\n\t * Np->num_curr is number of current item in format-picture, it is not\n\t * current position in inout!\n\t */\n\telog(DEBUG_elog_output,\n\t\t \"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \\\"%s\\\", INOUT: \\\"%s\\\"\",\n\t\t Np->sign_wrote,\n\t\t Np->num_curr,\n\t\t Np->number_p,\n\t\t Np->inout);\n#endif\n\tNp->num_in = false;\n\n\t/*\n\t * Write sign if real number will write to output Note: IS_PREDEC_SPACE()\n\t * handle \"9.9\" --> \" .1\"\n\t */\n\tif (Np->sign_wrote == false &&\n\t\t(Np->num_curr >= Np->out_pre_spaces || (IS_ZERO(Np->Num) && Np->Num->zero_start == Np->num_curr)) &&\n\t\t(IS_PREDEC_SPACE(Np) == false || (Np->last_relevant && *Np->last_relevant == '.')))\n\t{\n\t\tif (IS_LSIGN(Np->Num))\n\t\t{\n\t\t\tif (Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\tNp->sign_wrote = true;\n\t\t\t}\n\t\t}\n\t\telse if (IS_BRACKET(Np->Num))\n\t\t{\n\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '<';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '+')\n\t\t{\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write + */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t\telse if (Np->sign == '-')\n\t\t{\t\t\t\t\t\t/* Write - */\n\t\t\t*Np->inout_p = '-';\n\t\t\t++Np->inout_p;\n\t\t\tNp->sign_wrote = true;\n\t\t}\n\t}\n\n\n\t/*\n\t * digits / FM / Zero / Dec. point\n\t */\n\tif (id == NUM_9 || id == NUM_0 || id == NUM_D || id == NUM_DEC)\n\t{\n\t\tif (Np->num_curr < Np->out_pre_spaces &&\n\t\t\t(Np->Num->zero_start > Np->num_curr || !IS_ZERO(Np->Num)))\n\t\t{\n\t\t\t/*\n\t\t\t * Write blank space\n\t\t\t */\n\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = ' '; /* Write ' ' */\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t}\n\t\telse if (IS_ZERO(Np->Num) &&\n\t\t\t\t Np->num_curr < Np->out_pre_spaces &&\n\t\t\t\t Np->Num->zero_start <= Np->num_curr)\n\t\t{\n\t\t\t/*\n\t\t\t * Write ZERO\n\t\t\t */\n\t\t\t*Np->inout_p = '0'; /* Write '0' */\n\t\t\t++Np->inout_p;\n\t\t\tNp->num_in = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Write Decimal point\n\t\t\t */\n\t\t\tif (*Np->number_p == '.')\n\t\t\t{\n\t\t\t\tif (!Np->last_relevant || *Np->last_relevant != '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Ora 'n' -- FM9.9 --> 'n.'\n\t\t\t\t */\n\t\t\t\telse if (IS_FILLMODE(Np->Num) &&\n\t\t\t\t\t\t Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t{\n\t\t\t\t\tstrcpy(Np->inout_p, Np->decimal);\t/* Write DEC/D */\n\t\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Write Digits\n\t\t\t\t */\n\t\t\t\tif (Np->last_relevant && Np->number_p > Np->last_relevant &&\n\t\t\t\t\tid != NUM_0)\n\t\t\t\t\t;\n\n\t\t\t\t/*\n\t\t\t\t * '0.1' -- 9.9 --> '  .1'\n\t\t\t\t */\n\t\t\t\telse if (IS_PREDEC_SPACE(Np))\n\t\t\t\t{\n\t\t\t\t\tif (!IS_FILLMODE(Np->Num))\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = ' ';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * '0' -- FM9.9 --> '0.'\n\t\t\t\t\t */\n\t\t\t\t\telse if (Np->last_relevant && *Np->last_relevant == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\t*Np->inout_p = '0';\n\t\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*Np->inout_p = *Np->number_p;\t/* Write DIGIT */\n\t\t\t\t\t++Np->inout_p;\n\t\t\t\t\tNp->num_in = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* do no exceed string length */\n\t\t\tif (*Np->number_p)\n\t\t\t\t++Np->number_p;\n\t\t}\n\n\t\tend = Np->num_count + (Np->out_pre_spaces ? 1 : 0) + (IS_DECIMAL(Np->Num) ? 1 : 0);\n\n\t\tif (Np->last_relevant && Np->last_relevant == Np->number_p)\n\t\t\tend = Np->num_curr;\n\n\t\tif (Np->num_curr + 1 == end)\n\t\t{\n\t\t\tif (Np->sign_wrote == true && IS_BRACKET(Np->Num))\n\t\t\t{\n\t\t\t\t*Np->inout_p = Np->sign == '+' ? ' ' : '>';\n\t\t\t\t++Np->inout_p;\n\t\t\t}\n\t\t\telse if (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_POST)\n\t\t\t{\n\t\t\t\tif (Np->sign == '-')\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_negative_sign);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(Np->inout_p, Np->L_positive_sign);\n\t\t\t\tNp->inout_p += strlen(Np->inout_p);\n\t\t\t}\n\t\t}\n\t}\n\n\t++Np->num_curr;\n}"
  },
  {
    "function_name": "NUM_numpart_from_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4289-4492",
    "snippet": "static void\nNUM_numpart_from_char(NUMProc *Np, int id, int input_len)\n{\n\tbool\t\tisread = false;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \" --- scan start --- id=%s\",\n\t\t (id == NUM_0 || id == NUM_9) ? \"NUM_0/9\" : id == NUM_DEC ? \"NUM_DEC\" : \"???\");\n#endif\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\tif (*Np->inout_p == ' ')\n\t\tNp->inout_p++;\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * read sign before number\n\t */\n\tif (*Np->number == ' ' && (id == NUM_0 || id == NUM_9) &&\n\t\t(Np->read_pre + Np->read_post) == 0)\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read sign (%c), locale positive: %s, negative: %s\",\n\t\t\t *Np->inout_p, Np->L_positive_sign, Np->L_negative_sign);\n#endif\n\n\t\t/*\n\t\t * locale sign\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t{\n\t\t\tint\t\t\tx = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale pre-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + - < >\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || (IS_BRACKET(Np->Num) &&\n\t\t\t\t\t\t\t\t\t\t*Np->inout_p == '<'))\n\t\t\t{\n\t\t\t\t*Np->number = '-';\t/* set - */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t\telse if (*Np->inout_p == '+')\n\t\t\t{\n\t\t\t\t*Np->number = '+';\t/* set + */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"Scan for numbers (%c), current number: '%s'\", *Np->inout_p, Np->number);\n#endif\n\n\t/*\n\t * read digit or decimal point\n\t */\n\tif (isdigit((unsigned char) *Np->inout_p))\n\t{\n\t\tif (Np->read_dec && Np->read_post == Np->Num->post)\n\t\t\treturn;\n\n\t\t*Np->number_p = *Np->inout_p;\n\t\tNp->number_p++;\n\n\t\tif (Np->read_dec)\n\t\t\tNp->read_post++;\n\t\telse\n\t\t\tNp->read_pre++;\n\n\t\tisread = true;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Read digit (%c)\", *Np->inout_p);\n#endif\n\t}\n\telse if (IS_DECIMAL(Np->Num) && Np->read_dec == false)\n\t{\n\t\t/*\n\t\t * We need not test IS_LDECIMAL(Np->Num) explicitly here, because\n\t\t * Np->decimal is always just \".\" if we don't have a D format token.\n\t\t * So we just unconditionally match to Np->decimal.\n\t\t */\n\t\tint\t\t\tx = strlen(Np->decimal);\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read decimal point (%c)\",\n\t\t\t *Np->inout_p);\n#endif\n\t\tif (x && AMOUNT_TEST(x) && strncmp(Np->inout_p, Np->decimal, x) == 0)\n\t\t{\n\t\t\tNp->inout_p += x - 1;\n\t\t\t*Np->number_p = '.';\n\t\t\tNp->number_p++;\n\t\t\tNp->read_dec = true;\n\t\t\tisread = true;\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * Read sign behind \"last\" number\n\t *\n\t * We need sign detection because determine exact position of post-sign is\n\t * difficult:\n\t *\n\t * FM9999.9999999S\t   -> 123.001- 9.9S\t\t\t   -> .5- FM9.999999MI ->\n\t * 5.01-\n\t */\n\tif (*Np->number == ' ' && Np->read_pre + Np->read_post > 0)\n\t{\n\t\t/*\n\t\t * locale sign (NUM_S) is always anchored behind a last number, if: -\n\t\t * locale sign expected - last read char was NUM_0/9 or NUM_DEC - and\n\t\t * next char is not digit\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && isread &&\n\t\t\t(Np->inout_p + 1) < Np->inout + input_len &&\n\t\t\t!isdigit((unsigned char) *(Np->inout_p + 1)))\n\t\t{\n\t\t\tint\t\t\tx;\n\t\t\tchar\t   *tmp = Np->inout_p++;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale post-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t\tif (*Np->number == ' ')\n\t\t\t\t/* no sign read */\n\t\t\t\tNp->inout_p = tmp;\n\t\t}\n\n\t\t/*\n\t\t * try read non-locale sign, it's happen only if format is not exact\n\t\t * and we cannot determine sign position of MI/PL/SG, an example:\n\t\t *\n\t\t * FM9.999999MI\t\t\t   -> 5.01-\n\t\t *\n\t\t * if (.... && IS_LSIGN(Np->Num)==false) prevents read wrong formats\n\t\t * like to_number('1 -', '9S') where sign is not anchored to last\n\t\t * number.\n\t\t */\n\t\telse if (isread == false && IS_LSIGN(Np->Num) == false &&\n\t\t\t\t (IS_PLUS(Np->Num) || IS_MINUS(Np->Num)))\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple post-sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + -\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || *Np->inout_p == '+')\n\t\t\t\t/* NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = *Np->inout_p;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)",
      "#define NUM_LSIGN_PRE\t(-1)",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static char *int_to_roman(int number);",
      "static void NUM_prepare_locale(NUMProc *Np);",
      "static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"Try read simple post-sign (%c)\"",
            "*Np->inout_p"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "Np->Num"
          ],
          "line": 4478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "Np->Num"
          ],
          "line": 4478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "Np->inout_p",
            "Np->L_positive_sign",
            "x"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "x"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Np->L_positive_sign"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "x"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *(Np->inout_p + 1)"
          ],
          "line": 4440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "x"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *Np->inout_p"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "Np->Num"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "x"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMOUNT_TEST",
          "args": [
            "x"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "Np->Num"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define OVERLOAD_TEST\t(Np->inout_p >= Np->inout + input_len)\n#define NUM_LSIGN_PRE\t(-1)\n#define DEBUG_elog_output\tDEBUG3\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\nstatic void NUM_numpart_from_char(NUMProc *Np, int id, int input_len);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUM_numpart_from_char(NUMProc *Np, int id, int input_len)\n{\n\tbool\t\tisread = false;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \" --- scan start --- id=%s\",\n\t\t (id == NUM_0 || id == NUM_9) ? \"NUM_0/9\" : id == NUM_DEC ? \"NUM_DEC\" : \"???\");\n#endif\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\tif (*Np->inout_p == ' ')\n\t\tNp->inout_p++;\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * read sign before number\n\t */\n\tif (*Np->number == ' ' && (id == NUM_0 || id == NUM_9) &&\n\t\t(Np->read_pre + Np->read_post) == 0)\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read sign (%c), locale positive: %s, negative: %s\",\n\t\t\t *Np->inout_p, Np->L_positive_sign, Np->L_negative_sign);\n#endif\n\n\t\t/*\n\t\t * locale sign\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && Np->Num->lsign == NUM_LSIGN_PRE)\n\t\t{\n\t\t\tint\t\t\tx = 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale pre-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x;\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + - < >\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || (IS_BRACKET(Np->Num) &&\n\t\t\t\t\t\t\t\t\t\t*Np->inout_p == '<'))\n\t\t\t{\n\t\t\t\t*Np->number = '-';\t/* set - */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t\telse if (*Np->inout_p == '+')\n\t\t\t{\n\t\t\t\t*Np->number = '+';\t/* set + */\n\t\t\t\tNp->inout_p++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"Scan for numbers (%c), current number: '%s'\", *Np->inout_p, Np->number);\n#endif\n\n\t/*\n\t * read digit or decimal point\n\t */\n\tif (isdigit((unsigned char) *Np->inout_p))\n\t{\n\t\tif (Np->read_dec && Np->read_post == Np->Num->post)\n\t\t\treturn;\n\n\t\t*Np->number_p = *Np->inout_p;\n\t\tNp->number_p++;\n\n\t\tif (Np->read_dec)\n\t\t\tNp->read_post++;\n\t\telse\n\t\t\tNp->read_pre++;\n\n\t\tisread = true;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Read digit (%c)\", *Np->inout_p);\n#endif\n\t}\n\telse if (IS_DECIMAL(Np->Num) && Np->read_dec == false)\n\t{\n\t\t/*\n\t\t * We need not test IS_LDECIMAL(Np->Num) explicitly here, because\n\t\t * Np->decimal is always just \".\" if we don't have a D format token.\n\t\t * So we just unconditionally match to Np->decimal.\n\t\t */\n\t\tint\t\t\tx = strlen(Np->decimal);\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Try read decimal point (%c)\",\n\t\t\t *Np->inout_p);\n#endif\n\t\tif (x && AMOUNT_TEST(x) && strncmp(Np->inout_p, Np->decimal, x) == 0)\n\t\t{\n\t\t\tNp->inout_p += x - 1;\n\t\t\t*Np->number_p = '.';\n\t\t\tNp->number_p++;\n\t\t\tNp->read_dec = true;\n\t\t\tisread = true;\n\t\t}\n\t}\n\n\tif (OVERLOAD_TEST)\n\t\treturn;\n\n\t/*\n\t * Read sign behind \"last\" number\n\t *\n\t * We need sign detection because determine exact position of post-sign is\n\t * difficult:\n\t *\n\t * FM9999.9999999S\t   -> 123.001- 9.9S\t\t\t   -> .5- FM9.999999MI ->\n\t * 5.01-\n\t */\n\tif (*Np->number == ' ' && Np->read_pre + Np->read_post > 0)\n\t{\n\t\t/*\n\t\t * locale sign (NUM_S) is always anchored behind a last number, if: -\n\t\t * locale sign expected - last read char was NUM_0/9 or NUM_DEC - and\n\t\t * next char is not digit\n\t\t */\n\t\tif (IS_LSIGN(Np->Num) && isread &&\n\t\t\t(Np->inout_p + 1) < Np->inout + input_len &&\n\t\t\t!isdigit((unsigned char) *(Np->inout_p + 1)))\n\t\t{\n\t\t\tint\t\t\tx;\n\t\t\tchar\t   *tmp = Np->inout_p++;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read locale post-sign (%c)\", *Np->inout_p);\n#endif\n\t\t\tif ((x = strlen(Np->L_negative_sign)) &&\n\t\t\t\tAMOUNT_TEST(x) &&\n\t\t\t\tstrncmp(Np->inout_p, Np->L_negative_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '-';\n\t\t\t}\n\t\t\telse if ((x = strlen(Np->L_positive_sign)) &&\n\t\t\t\t\t AMOUNT_TEST(x) &&\n\t\t\t\t\t strncmp(Np->inout_p, Np->L_positive_sign, x) == 0)\n\t\t\t{\n\t\t\t\tNp->inout_p += x - 1;\t/* -1 .. NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = '+';\n\t\t\t}\n\t\t\tif (*Np->number == ' ')\n\t\t\t\t/* no sign read */\n\t\t\t\tNp->inout_p = tmp;\n\t\t}\n\n\t\t/*\n\t\t * try read non-locale sign, it's happen only if format is not exact\n\t\t * and we cannot determine sign position of MI/PL/SG, an example:\n\t\t *\n\t\t * FM9.999999MI\t\t\t   -> 5.01-\n\t\t *\n\t\t * if (.... && IS_LSIGN(Np->Num)==false) prevents read wrong formats\n\t\t * like to_number('1 -', '9S') where sign is not anchored to last\n\t\t * number.\n\t\t */\n\t\telse if (isread == false && IS_LSIGN(Np->Num) == false &&\n\t\t\t\t (IS_PLUS(Np->Num) || IS_MINUS(Np->Num)))\n\t\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"Try read simple post-sign (%c)\", *Np->inout_p);\n#endif\n\n\t\t\t/*\n\t\t\t * simple + -\n\t\t\t */\n\t\t\tif (*Np->inout_p == '-' || *Np->inout_p == '+')\n\t\t\t\t/* NUM_processor() do inout_p++ */\n\t\t\t\t*Np->number = *Np->inout_p;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_last_relevant_decnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4253-4275",
    "snippet": "static char *\nget_last_relevant_decnum(char *num)\n{\n\tchar\t   *result,\n\t\t\t   *p = strchr(num, '.');\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"get_last_relevant_decnum()\");\n#endif\n\n\tif (!p)\n\t\treturn NULL;\n\n\tresult = p;\n\n\twhile (*(++p))\n\t{\n\t\tif (*p != '0')\n\t\t\tresult = p;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static char *get_last_relevant_decnum(char *num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"get_last_relevant_decnum()\""
          ],
          "line": 4260
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "num",
            "'.'"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DEBUG_elog_output\tDEBUG3\n\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nget_last_relevant_decnum(char *num)\n{\n\tchar\t   *result,\n\t\t\t   *p = strchr(num, '.');\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"get_last_relevant_decnum()\");\n#endif\n\n\tif (!p)\n\t\treturn NULL;\n\n\tresult = p;\n\n\twhile (*(++p))\n\t{\n\t\tif (*p != '0')\n\t\t\tresult = p;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "NUM_prepare_locale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4171-4243",
    "snippet": "static void\nNUM_prepare_locale(NUMProc *Np)\n{\n\tif (Np->Num->need_locale)\n\t{\n\t\tstruct lconv *lconv;\n\n\t\t/*\n\t\t * Get locales\n\t\t */\n\t\tlconv = PGLC_localeconv();\n\n\t\t/*\n\t\t * Positive / Negative number sign\n\t\t */\n\t\tif (lconv->negative_sign && *lconv->negative_sign)\n\t\t\tNp->L_negative_sign = lconv->negative_sign;\n\t\telse\n\t\t\tNp->L_negative_sign = \"-\";\n\n\t\tif (lconv->positive_sign && *lconv->positive_sign)\n\t\t\tNp->L_positive_sign = lconv->positive_sign;\n\t\telse\n\t\t\tNp->L_positive_sign = \"+\";\n\n\t\t/*\n\t\t * Number decimal point\n\t\t */\n\t\tif (lconv->decimal_point && *lconv->decimal_point)\n\t\t\tNp->decimal = lconv->decimal_point;\n\n\t\telse\n\t\t\tNp->decimal = \".\";\n\n\t\tif (!IS_LDECIMAL(Np->Num))\n\t\t\tNp->decimal = \".\";\n\n\t\t/*\n\t\t * Number thousands separator\n\t\t *\n\t\t * Some locales (e.g. broken glibc pt_BR), have a comma for decimal,\n\t\t * but \"\" for thousands_sep, so we set the thousands_sep too.\n\t\t * http://archives.postgresql.org/pgsql-hackers/2007-11/msg00772.php\n\t\t */\n\t\tif (lconv->thousands_sep && *lconv->thousands_sep)\n\t\t\tNp->L_thousands_sep = lconv->thousands_sep;\n\t\t/* Make sure thousands separator doesn't match decimal point symbol. */\n\t\telse if (strcmp(Np->decimal, \",\") !=0)\n\t\t\tNp->L_thousands_sep = \",\";\n\t\telse\n\t\t\tNp->L_thousands_sep = \".\";\n\n\t\t/*\n\t\t * Currency symbol\n\t\t */\n\t\tif (lconv->currency_symbol && *lconv->currency_symbol)\n\t\t\tNp->L_currency_symbol = lconv->currency_symbol;\n\t\telse\n\t\t\tNp->L_currency_symbol = \" \";\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Default values\n\t\t */\n\t\tNp->L_negative_sign = \"-\";\n\t\tNp->L_positive_sign = \"+\";\n\t\tNp->decimal = \".\";\n\n\t\tNp->L_thousands_sep = \",\";\n\t\tNp->L_currency_symbol = \" \";\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static char *int_to_roman(int number);",
      "static void NUM_prepare_locale(NUMProc *Np);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "Np->decimal",
            "\",\""
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LDECIMAL",
          "args": [
            "Np->Num"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PGLC_localeconv",
          "args": [],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "PGLC_localeconv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "483-676",
          "snippet": "struct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *locale_monetary;",
            "char\t   *locale_numeric;",
            "static bool CurrentLocaleConvValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nchar\t   *locale_monetary;\nchar\t   *locale_numeric;\nstatic bool CurrentLocaleConvValid = false;\n\nstruct lconv *\nPGLC_localeconv(void)\n{\n\tstatic struct lconv CurrentLocaleConv;\n\tstatic bool CurrentLocaleConvAllocated = false;\n\tstruct lconv *extlconv;\n\tstruct lconv worklconv;\n\tchar\t   *save_lc_monetary;\n\tchar\t   *save_lc_numeric;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* Did we do it already? */\n\tif (CurrentLocaleConvValid)\n\t\treturn &CurrentLocaleConv;\n\n\t/* Free any already-allocated storage */\n\tif (CurrentLocaleConvAllocated)\n\t{\n\t\tfree_struct_lconv(&CurrentLocaleConv);\n\t\tCurrentLocaleConvAllocated = false;\n\t}\n\n\t/*\n\t * This is tricky because we really don't want to risk throwing error\n\t * while the locale is set to other than our usual settings.  Therefore,\n\t * the process is: collect the usual settings, set locale to special\n\t * setting, copy relevant data into worklconv using strdup(), restore\n\t * normal settings, convert data to desired encoding, and finally stash\n\t * the collected data in CurrentLocaleConv.  This makes it safe if we\n\t * throw an error during encoding conversion or run out of memory anywhere\n\t * in the process.  All data pointed to by struct lconv members is\n\t * allocated with strdup, to avoid premature elog(ERROR) and to allow\n\t * using a single cleanup routine.\n\t */\n\tmemset(&worklconv, 0, sizeof(worklconv));\n\n\t/* Save prevailing values of monetary and numeric locales */\n\tsave_lc_monetary = setlocale(LC_MONETARY, NULL);\n\tif (!save_lc_monetary)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_monetary = pstrdup(save_lc_monetary);\n\n\tsave_lc_numeric = setlocale(LC_NUMERIC, NULL);\n\tif (!save_lc_numeric)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_numeric = pstrdup(save_lc_numeric);\n\n#ifdef WIN32\n\n\t/*\n\t * The POSIX standard explicitly says that it is undefined what happens if\n\t * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from\n\t * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to\n\t * believe that localeconv() should return strings that are encoded in the\n\t * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,\n\t * once we have successfully collected the localeconv() results, we will\n\t * convert them from that codeset to the desired server encoding.\n\t *\n\t * Windows, of course, resolutely does things its own way; on that\n\t * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane\n\t * results.  Hence, we must temporarily set that category as well.\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* Here begins the critical section where we must not throw error */\n\n\t/* use numeric to set the ctype */\n\tsetlocale(LC_CTYPE, locale_numeric);\n#endif\n\n\t/* Get formatting information for numeric */\n\tsetlocale(LC_NUMERIC, locale_numeric);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.decimal_point = strdup(extlconv->decimal_point);\n\tworklconv.thousands_sep = strdup(extlconv->thousands_sep);\n\tworklconv.grouping = strdup(extlconv->grouping);\n\n#ifdef WIN32\n\t/* use monetary to set the ctype */\n\tsetlocale(LC_CTYPE, locale_monetary);\n#endif\n\n\t/* Get formatting information for monetary */\n\tsetlocale(LC_MONETARY, locale_monetary);\n\textlconv = localeconv();\n\n\t/* Must copy data now in case setlocale() overwrites it */\n\tworklconv.int_curr_symbol = strdup(extlconv->int_curr_symbol);\n\tworklconv.currency_symbol = strdup(extlconv->currency_symbol);\n\tworklconv.mon_decimal_point = strdup(extlconv->mon_decimal_point);\n\tworklconv.mon_thousands_sep = strdup(extlconv->mon_thousands_sep);\n\tworklconv.mon_grouping = strdup(extlconv->mon_grouping);\n\tworklconv.positive_sign = strdup(extlconv->positive_sign);\n\tworklconv.negative_sign = strdup(extlconv->negative_sign);\n\t/* Copy scalar fields as well */\n\tworklconv.int_frac_digits = extlconv->int_frac_digits;\n\tworklconv.frac_digits = extlconv->frac_digits;\n\tworklconv.p_cs_precedes = extlconv->p_cs_precedes;\n\tworklconv.p_sep_by_space = extlconv->p_sep_by_space;\n\tworklconv.n_cs_precedes = extlconv->n_cs_precedes;\n\tworklconv.n_sep_by_space = extlconv->n_sep_by_space;\n\tworklconv.p_sign_posn = extlconv->p_sign_posn;\n\tworklconv.n_sign_posn = extlconv->n_sign_posn;\n\n\t/*\n\t * Restore the prevailing locale settings; failure to do so is fatal.\n\t * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,\n\t * but proceeding with the wrong value of LC_CTYPE would certainly be bad\n\t * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC\n\t * are almost certainly \"C\", there's really no reason that restoring those\n\t * should fail.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_MONETARY, save_lc_monetary))\n\t\telog(FATAL, \"failed to restore LC_MONETARY to \\\"%s\\\"\", save_lc_monetary);\n\tif (!setlocale(LC_NUMERIC, save_lc_numeric))\n\t\telog(FATAL, \"failed to restore LC_NUMERIC to \\\"%s\\\"\", save_lc_numeric);\n\n\t/*\n\t * At this point we've done our best to clean up, and can call functions\n\t * that might possibly throw errors with a clean conscience.  But let's\n\t * make sure we don't leak any already-strdup'd fields in worklconv.\n\t */\n\tPG_TRY();\n\t{\n\t\tint\t\t\tencoding;\n\n\t\t/* Release the pstrdup'd locale names */\n\t\tpfree(save_lc_monetary);\n\t\tpfree(save_lc_numeric);\n#ifdef WIN32\n\t\tpfree(save_lc_ctype);\n#endif\n\n\t\t/* If any of the preceding strdup calls failed, complain now. */\n\t\tif (!struct_lconv_is_valid(&worklconv))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t/*\n\t\t * Now we must perform encoding conversion from whatever's associated\n\t\t * with the locales into the database encoding.  If we can't identify\n\t\t * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),\n\t\t * use PG_SQL_ASCII, which will result in just validating that the\n\t\t * strings are OK in the database encoding.\n\t\t */\n\t\tencoding = pg_get_encoding_from_locale(locale_numeric, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.thousands_sep);\n\t\t/* grouping is not text and does not require conversion */\n\n\t\tencoding = pg_get_encoding_from_locale(locale_monetary, true);\n\t\tif (encoding < 0)\n\t\t\tencoding = PG_SQL_ASCII;\n\n\t\tdb_encoding_convert(encoding, &worklconv.int_curr_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.currency_symbol);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_decimal_point);\n\t\tdb_encoding_convert(encoding, &worklconv.mon_thousands_sep);\n\t\t/* mon_grouping is not text and does not require conversion */\n\t\tdb_encoding_convert(encoding, &worklconv.positive_sign);\n\t\tdb_encoding_convert(encoding, &worklconv.negative_sign);\n\t}\n\tPG_CATCH();\n\t{\n\t\tfree_struct_lconv(&worklconv);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\t/*\n\t * Everything is good, so save the results.\n\t */\n\tCurrentLocaleConv = worklconv;\n\tCurrentLocaleConvAllocated = true;\n\tCurrentLocaleConvValid = true;\n\treturn &CurrentLocaleConv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic char *int_to_roman(int number);\nstatic void NUM_prepare_locale(NUMProc *Np);\n\nstatic void\nNUM_prepare_locale(NUMProc *Np)\n{\n\tif (Np->Num->need_locale)\n\t{\n\t\tstruct lconv *lconv;\n\n\t\t/*\n\t\t * Get locales\n\t\t */\n\t\tlconv = PGLC_localeconv();\n\n\t\t/*\n\t\t * Positive / Negative number sign\n\t\t */\n\t\tif (lconv->negative_sign && *lconv->negative_sign)\n\t\t\tNp->L_negative_sign = lconv->negative_sign;\n\t\telse\n\t\t\tNp->L_negative_sign = \"-\";\n\n\t\tif (lconv->positive_sign && *lconv->positive_sign)\n\t\t\tNp->L_positive_sign = lconv->positive_sign;\n\t\telse\n\t\t\tNp->L_positive_sign = \"+\";\n\n\t\t/*\n\t\t * Number decimal point\n\t\t */\n\t\tif (lconv->decimal_point && *lconv->decimal_point)\n\t\t\tNp->decimal = lconv->decimal_point;\n\n\t\telse\n\t\t\tNp->decimal = \".\";\n\n\t\tif (!IS_LDECIMAL(Np->Num))\n\t\t\tNp->decimal = \".\";\n\n\t\t/*\n\t\t * Number thousands separator\n\t\t *\n\t\t * Some locales (e.g. broken glibc pt_BR), have a comma for decimal,\n\t\t * but \"\" for thousands_sep, so we set the thousands_sep too.\n\t\t * http://archives.postgresql.org/pgsql-hackers/2007-11/msg00772.php\n\t\t */\n\t\tif (lconv->thousands_sep && *lconv->thousands_sep)\n\t\t\tNp->L_thousands_sep = lconv->thousands_sep;\n\t\t/* Make sure thousands separator doesn't match decimal point symbol. */\n\t\telse if (strcmp(Np->decimal, \",\") !=0)\n\t\t\tNp->L_thousands_sep = \",\";\n\t\telse\n\t\t\tNp->L_thousands_sep = \".\";\n\n\t\t/*\n\t\t * Currency symbol\n\t\t */\n\t\tif (lconv->currency_symbol && *lconv->currency_symbol)\n\t\t\tNp->L_currency_symbol = lconv->currency_symbol;\n\t\telse\n\t\t\tNp->L_currency_symbol = \" \";\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Default values\n\t\t */\n\t\tNp->L_negative_sign = \"-\";\n\t\tNp->L_positive_sign = \"+\";\n\t\tNp->decimal = \".\";\n\n\t\tNp->L_thousands_sep = \",\";\n\t\tNp->L_currency_symbol = \" \";\n\t}\n}"
  },
  {
    "function_name": "int_to_roman",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4122-4163",
    "snippet": "static char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};",
      "static const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};",
      "static const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static char *int_to_roman(int number);",
      "static char *get_last_relevant_decnum(char *num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "result",
            "rm1[num]"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "numstr",
            "sizeof(numstr)",
            "\"%d\"",
            "number"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_str",
          "args": [
            "result",
            "'#'",
            "15"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "fill_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3924-3930",
          "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static char *fill_str(char *str, int c, int max);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "16"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char *const rm1[] = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", NULL};\nstatic const char *const rm10[] = {\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", NULL};\nstatic const char *const rm100[] = {\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", NULL};\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nint_to_roman(int number)\n{\n\tint\t\t\tlen = 0,\n\t\t\t\tnum = 0;\n\tchar\t   *p = NULL,\n\t\t\t   *result,\n\t\t\t\tnumstr[12];\n\n\tresult = (char *) palloc(16);\n\t*result = '\\0';\n\n\tif (number > 3999 || number < 1)\n\t{\n\t\tfill_str(result, '#', 15);\n\t\treturn result;\n\t}\n\tlen = snprintf(numstr, sizeof(numstr), \"%d\", number);\n\n\tfor (p = numstr; *p != '\\0'; p++, --len)\n\t{\n\t\tnum = *p - 49;\t\t\t/* 48 ascii + 1 */\n\t\tif (num < 0)\n\t\t\tcontinue;\n\n\t\tif (len > 3)\n\t\t{\n\t\t\twhile (num-- != -1)\n\t\t\t\tstrcat(result, \"M\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (len == 3)\n\t\t\t\tstrcat(result, rm100[num]);\n\t\t\telse if (len == 2)\n\t\t\t\tstrcat(result, rm10[num]);\n\t\t\telse if (len == 1)\n\t\t\t\tstrcat(result, rm1[num]);\n\t\t}\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "NUM_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4064-4119",
    "snippet": "static FormatNode *\nNUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree)\n{\n\tFormatNode *format = NULL;\n\tchar\t   *str;\n\n\tstr = text_to_cstring(pars_str);\n\n\tif (len > NUM_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tformat = (FormatNode *) palloc((len + 1) * sizeof(FormatNode));\n\n\t\t*shouldFree = true;\n\n\t\tzeroize_NUM(Num);\n\n\t\tparse_format(format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, Num);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tNUMCacheEntry *ent = NUM_cache_fetch(str);\n\n\t\t*shouldFree = false;\n\n\t\tformat = ent->format;\n\n\t\t/*\n\t\t * Copy cache to used struct\n\t\t */\n\t\tNum->flag = ent->Num.flag;\n\t\tNum->lsign = ent->Num.lsign;\n\t\tNum->pre = ent->Num.pre;\n\t\tNum->post = ent->Num.post;\n\t\tNum->pre_lsign_num = ent->Num.pre_lsign_num;\n\t\tNum->need_locale = ent->Num.need_locale;\n\t\tNum->multi = ent->Num.multi;\n\t\tNum->zero_start = ent->Num.zero_start;\n\t\tNum->zero_end = ent->Num.zero_end;\n\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t/* dump_node(format, len); */\n\tdump_index(NUM_keywords, NUM_index);\n#endif\n\n\tpfree(str);\n\treturn format;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CACHE_SIZE\t\t64",
      "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/"
    ],
    "globals_used": [
      "static const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};",
      "static const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static int\tstrspace_len(char *str);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_index",
          "args": [
            "NUM_keywords",
            "NUM_index"
          ],
          "line": 4114
        },
        "resolved": true,
        "details": {
          "function_name": "dump_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2031-2055",
          "snippet": "static void\ndump_index(const KeyWord *k, const int *index)\n{\n\tint\t\t\ti,\n\t\t\t\tcount = 0,\n\t\t\t\tfree_i = 0;\n\n\telog(DEBUG_elog_output, \"TO-FROM_CHAR: Dump KeyWord Index:\");\n\n\tfor (i = 0; i < KeyWord_INDEX_SIZE; i++)\n\t{\n\t\tif (index[i] != -1)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"\\t%c: %s, \", i + 32, k[index[i]].name);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree_i++;\n\t\t\telog(DEBUG_elog_output, \"\\t(%d) %c %d\", i, i + 32, index[i]);\n\t\t}\n\t}\n\telog(DEBUG_elog_output, \"\\n\\t\\tUsed positions: %d,\\n\\t\\tFree positions: %d\",\n\t\t count, free_i);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define KeyWord_INDEX_SIZE\t\t('~' - ' ')",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define KeyWord_INDEX_SIZE\t\t('~' - ' ')\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\n\nstatic void\ndump_index(const KeyWord *k, const int *index)\n{\n\tint\t\t\ti,\n\t\t\t\tcount = 0,\n\t\t\t\tfree_i = 0;\n\n\telog(DEBUG_elog_output, \"TO-FROM_CHAR: Dump KeyWord Index:\");\n\n\tfor (i = 0; i < KeyWord_INDEX_SIZE; i++)\n\t{\n\t\tif (index[i] != -1)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"\\t%c: %s, \", i + 32, k[index[i]].name);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree_i++;\n\t\t\telog(DEBUG_elog_output, \"\\t(%d) %c %d\", i, i + 32, index[i]);\n\t\t}\n\t}\n\telog(DEBUG_elog_output, \"\\n\\t\\tUsed positions: %d,\\n\\t\\tFree positions: %d\",\n\t\t count, free_i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUM_cache_fetch",
          "args": [
            "str"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_cache_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4036-4058",
          "snippet": "static NUMCacheEntry *\nNUM_cache_fetch(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\tif ((ent = NUM_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = NUM_cache_getnew(str);\n\n\t\tzeroize_NUM(&ent->Num);\n\n\t\tparse_format(ent->format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, &ent->Num);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/"
          ],
          "globals_used": [
            "static const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};",
            "static const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n\nstatic const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};\nstatic const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_fetch(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\tif ((ent = NUM_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = NUM_cache_getnew(str);\n\n\t\tzeroize_NUM(&ent->Num);\n\n\t\tparse_format(ent->format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, &ent->Num);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_format",
          "args": [
            "format",
            "str",
            "NUM_keywords",
            "NULL",
            "NUM_index",
            "NUM_TYPE",
            "Num"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1225-1334",
          "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SUFFTYPE_POSTFIX\t2",
            "#define SUFFTYPE_PREFIX\t\t1",
            "#define NODE_TYPE_CHAR\t\t3",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zeroize_NUM",
          "args": [
            "Num"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len + 1) * sizeof(FormatNode)"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "pars_str"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_CACHE_SIZE\t\t64\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n\nstatic const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};\nstatic const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic FormatNode *NUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic FormatNode *\nNUM_cache(int len, NUMDesc *Num, text *pars_str, bool *shouldFree)\n{\n\tFormatNode *format = NULL;\n\tchar\t   *str;\n\n\tstr = text_to_cstring(pars_str);\n\n\tif (len > NUM_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tformat = (FormatNode *) palloc((len + 1) * sizeof(FormatNode));\n\n\t\t*shouldFree = true;\n\n\t\tzeroize_NUM(Num);\n\n\t\tparse_format(format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, Num);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tNUMCacheEntry *ent = NUM_cache_fetch(str);\n\n\t\t*shouldFree = false;\n\n\t\tformat = ent->format;\n\n\t\t/*\n\t\t * Copy cache to used struct\n\t\t */\n\t\tNum->flag = ent->Num.flag;\n\t\tNum->lsign = ent->Num.lsign;\n\t\tNum->pre = ent->Num.pre;\n\t\tNum->post = ent->Num.post;\n\t\tNum->pre_lsign_num = ent->Num.pre_lsign_num;\n\t\tNum->need_locale = ent->Num.need_locale;\n\t\tNum->multi = ent->Num.multi;\n\t\tNum->zero_start = ent->Num.zero_start;\n\t\tNum->zero_end = ent->Num.zero_end;\n\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t/* dump_node(format, len); */\n\tdump_index(NUM_keywords, NUM_index);\n#endif\n\n\tpfree(str);\n\treturn format;\n}"
  },
  {
    "function_name": "NUM_cache_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4036-4058",
    "snippet": "static NUMCacheEntry *\nNUM_cache_fetch(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\tif ((ent = NUM_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = NUM_cache_getnew(str);\n\n\t\tzeroize_NUM(&ent->Num);\n\n\t\tparse_format(ent->format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, &ent->Num);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/"
    ],
    "globals_used": [
      "static const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};",
      "static const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_format",
          "args": [
            "ent->format",
            "str",
            "NUM_keywords",
            "NULL",
            "NUM_index",
            "NUM_TYPE",
            "&ent->Num"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1225-1334",
          "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SUFFTYPE_POSTFIX\t2",
            "#define SUFFTYPE_PREFIX\t\t1",
            "#define NODE_TYPE_CHAR\t\t3",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zeroize_NUM",
          "args": [
            "&ent->Num"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NUM_cache_getnew",
          "args": [
            "str"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_cache_getnew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3946-4005",
          "snippet": "static NUMCacheEntry *\nNUM_cache_getnew(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_NUMCache >= NUM_CACHE_ENTRIES)\n\t{\n\t\tNUMCacheEntry *old = NUMCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Cache is full (%d)\", n_NUMCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = NUMCache + 1; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: \\\"%s\\\" AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, NUM_CACHE_SIZE + 1);\n\t\told->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_NUMCache);\n#endif\n\t\tent = NUMCache + n_NUMCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, NUM_CACHE_SIZE + 1);\n\t\tent->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\t++n_NUMCache;\n\t\treturn ent;\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CACHE_ENTRIES\t20",
            "#define NUM_CACHE_SIZE\t\t64",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];",
            "static int\tn_NUMCache = 0;",
            "static int\tNUMCounter = 0;",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_CACHE_ENTRIES\t20\n#define NUM_CACHE_SIZE\t\t64\n#define DEBUG_elog_output\tDEBUG3\n\nstatic NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];\nstatic int\tn_NUMCache = 0;\nstatic int\tNUMCounter = 0;\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_getnew(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_NUMCache >= NUM_CACHE_ENTRIES)\n\t{\n\t\tNUMCacheEntry *old = NUMCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Cache is full (%d)\", n_NUMCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = NUMCache + 1; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: \\\"%s\\\" AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, NUM_CACHE_SIZE + 1);\n\t\told->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_NUMCache);\n#endif\n\t\tent = NUMCache + n_NUMCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, NUM_CACHE_SIZE + 1);\n\t\tent->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\t++n_NUMCache;\n\t\treturn ent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUM_cache_search",
          "args": [
            "str"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "NUM_cache_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "4008-4033",
          "snippet": "static NUMCacheEntry *\nNUM_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\tfor (i = 0, ent = NUMCache; i < n_NUMCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++NUMCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CACHE_ENTRIES\t20"
          ],
          "globals_used": [
            "static NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];",
            "static int\tn_NUMCache = 0;",
            "static int\tNUMCounter = 0;",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_CACHE_ENTRIES\t20\n\nstatic NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];\nstatic int\tn_NUMCache = 0;\nstatic int\tNUMCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\tfor (i = 0, ent = NUMCache; i < n_NUMCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++NUMCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n\nstatic const KeyWord NUM_keywords[] = {\n/*\tname, len, id\t\t\tis in Index */\n\t{\",\", 1, NUM_COMMA},\t\t/* , */\n\t{\".\", 1, NUM_DEC},\t\t\t/* . */\n\t{\"0\", 1, NUM_0},\t\t\t/* 0 */\n\t{\"9\", 1, NUM_9},\t\t\t/* 9 */\n\t{\"B\", 1, NUM_B},\t\t\t/* B */\n\t{\"C\", 1, NUM_C},\t\t\t/* C */\n\t{\"D\", 1, NUM_D},\t\t\t/* D */\n\t{\"EEEE\", 4, NUM_E},\t\t\t/* E */\n\t{\"FM\", 2, NUM_FM},\t\t\t/* F */\n\t{\"G\", 1, NUM_G},\t\t\t/* G */\n\t{\"L\", 1, NUM_L},\t\t\t/* L */\n\t{\"MI\", 2, NUM_MI},\t\t\t/* M */\n\t{\"PL\", 2, NUM_PL},\t\t\t/* P */\n\t{\"PR\", 2, NUM_PR},\n\t{\"RN\", 2, NUM_RN},\t\t\t/* R */\n\t{\"SG\", 2, NUM_SG},\t\t\t/* S */\n\t{\"SP\", 2, NUM_SP},\n\t{\"S\", 1, NUM_S},\n\t{\"TH\", 2, NUM_TH},\t\t\t/* T */\n\t{\"V\", 1, NUM_V},\t\t\t/* V */\n\t{\"b\", 1, NUM_B},\t\t\t/* b */\n\t{\"c\", 1, NUM_C},\t\t\t/* c */\n\t{\"d\", 1, NUM_D},\t\t\t/* d */\n\t{\"eeee\", 4, NUM_E},\t\t\t/* e */\n\t{\"fm\", 2, NUM_FM},\t\t\t/* f */\n\t{\"g\", 1, NUM_G},\t\t\t/* g */\n\t{\"l\", 1, NUM_L},\t\t\t/* l */\n\t{\"mi\", 2, NUM_MI},\t\t\t/* m */\n\t{\"pl\", 2, NUM_PL},\t\t\t/* p */\n\t{\"pr\", 2, NUM_PR},\n\t{\"rn\", 2, NUM_rn},\t\t\t/* r */\n\t{\"sg\", 2, NUM_SG},\t\t\t/* s */\n\t{\"sp\", 2, NUM_SP},\n\t{\"s\", 1, NUM_S},\n\t{\"th\", 2, NUM_th},\t\t\t/* t */\n\t{\"v\", 1, NUM_V},\t\t\t/* v */\n\n\t/* last */\n\t{NULL, 0, 0}\n};\nstatic const int NUM_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, NUM_COMMA, -1, NUM_DEC, -1, NUM_0, -1,\n\t-1, -1, -1, -1, -1, -1, -1, NUM_9, -1, -1,\n\t-1, -1, -1, -1, -1, -1, NUM_B, NUM_C, NUM_D, NUM_E,\n\tNUM_FM, NUM_G, -1, -1, -1, -1, NUM_L, NUM_MI, -1, -1,\n\tNUM_PL, -1, NUM_RN, NUM_SG, NUM_TH, -1, NUM_V, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, NUM_b, NUM_c,\n\tNUM_d, NUM_e, NUM_fm, NUM_g, -1, -1, -1, -1, NUM_l, NUM_mi,\n\t-1, -1, NUM_pl, -1, NUM_rn, NUM_sg, NUM_th, -1, NUM_v, -1,\n\t-1, -1, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_fetch(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\tif ((ent = NUM_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = NUM_cache_getnew(str);\n\n\t\tzeroize_NUM(&ent->Num);\n\n\t\tparse_format(ent->format, str, NUM_keywords,\n\t\t\t\t\t NULL, NUM_index, NUM_TYPE, &ent->Num);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}"
  },
  {
    "function_name": "NUM_cache_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "4008-4033",
    "snippet": "static NUMCacheEntry *\nNUM_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\tfor (i = 0, ent = NUMCache; i < n_NUMCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++NUMCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CACHE_ENTRIES\t20"
    ],
    "globals_used": [
      "static NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];",
      "static int\tn_NUMCache = 0;",
      "static int\tNUMCounter = 0;",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ent->str",
            "str"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_CACHE_ENTRIES\t20\n\nstatic NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];\nstatic int\tn_NUMCache = 0;\nstatic int\tNUMCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\tfor (i = 0, ent = NUMCache; i < n_NUMCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++NUMCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "NUM_cache_getnew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3946-4005",
    "snippet": "static NUMCacheEntry *\nNUM_cache_getnew(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_NUMCache >= NUM_CACHE_ENTRIES)\n\t{\n\t\tNUMCacheEntry *old = NUMCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Cache is full (%d)\", n_NUMCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = NUMCache + 1; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: \\\"%s\\\" AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, NUM_CACHE_SIZE + 1);\n\t\told->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_NUMCache);\n#endif\n\t\tent = NUMCache + n_NUMCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, NUM_CACHE_SIZE + 1);\n\t\tent->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\t++n_NUMCache;\n\t\treturn ent;\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CACHE_ENTRIES\t20",
      "#define NUM_CACHE_SIZE\t\t64",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];",
      "static int\tn_NUMCache = 0;",
      "static int\tNUMCounter = 0;",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "StrNCpy",
          "args": [
            "ent->str",
            "str",
            "NUM_CACHE_SIZE + 1"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"NEW (%d)\"",
            "n_NUMCache"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StrNCpy",
          "args": [
            "old->str",
            "str",
            "NUM_CACHE_SIZE + 1"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_CACHE_ENTRIES\t20\n#define NUM_CACHE_SIZE\t\t64\n#define DEBUG_elog_output\tDEBUG3\n\nstatic NUMCacheEntry NUMCache[NUM_CACHE_ENTRIES];\nstatic int\tn_NUMCache = 0;\nstatic int\tNUMCounter = 0;\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic NUMCacheEntry *\nNUM_cache_getnew(const char *str)\n{\n\tNUMCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_ENTRIES))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_NUMCache >= NUM_CACHE_ENTRIES)\n\t{\n\t\tNUMCacheEntry *old = NUMCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"Cache is full (%d)\", n_NUMCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = NUMCache + 1; ent < (NUMCache + NUM_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: \\\"%s\\\" AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, NUM_CACHE_SIZE + 1);\n\t\told->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_NUMCache);\n#endif\n\t\tent = NUMCache + n_NUMCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, NUM_CACHE_SIZE + 1);\n\t\tent->age = (++NUMCounter);\n\t\t/* caller is expected to fill format and Num, then set valid */\n\t\t++n_NUMCache;\n\t\treturn ent;\n\t}\n}"
  },
  {
    "function_name": "fill_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3924-3930",
    "snippet": "static char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tstrspace_len(char *str);",
      "static char *fill_str(char *str, int c, int max);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "str",
            "c",
            "max"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic char *fill_str(char *str, int c, int max);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic char *\nfill_str(char *str, int c, int max)\n{\n\tmemset(str, c, max);\n\t*(str + max) = '\\0';\n\treturn str;\n}"
  },
  {
    "function_name": "do_to_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3634-3916",
    "snippet": "static void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_CACHE_SIZE\t\t128",
      "#define CLOCK_12_HOUR\t\t1",
      "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
    ],
    "globals_used": [
      "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
      "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
      "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
      "static int\tadjust_partial_year_to_2020(int year);",
      "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);",
      "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "date_str"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_TM",
          "args": [
            "tm"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%c%02d:%02d\"",
            "tmfc.tzsign > 0 ? '+' : '-'",
            "tmfc.tzh",
            "tmfc.tzm"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "DTERR_TZDISP_OVERFLOW",
            "date_str",
            "\"timestamp\""
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValidateDate",
          "args": [
            "fmask",
            "true",
            "false",
            "false",
            "tm"
          ],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2465-2534",
          "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isleap",
          "args": [
            "tm->tm_year"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "j0 + tmfc.ddd",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isoweek2j",
          "args": [
            "tm->tm_year",
            "1"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4164-4177",
          "snippet": "int\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nisoweek2j(int year, int week)\n{\n\tint\t\t\tday0,\n\t\t\t\tday4;\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\treturn ((week - 1) * 7) + (day4 - day0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\"))"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot calculate day of year without year information\""
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "MONTH"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "DAY"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isoweek2date",
          "args": [
            "tmfc.ww",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "isoweek2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4184-4188",
          "snippet": "void\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweek2date(int woy, int *year, int *mon, int *mday)\n{\n\tj2date(isoweek2j(*year, woy), year, mon, mday);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isoweekdate2date",
          "args": [
            "tmfc.ww",
            "tmfc.d",
            "&tm->tm_year",
            "&tm->tm_mon",
            "&tm->tm_mday"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "isoweekdate2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4197-4209",
          "snippet": "void\nisoweekdate2date(int isoweek, int wday, int *year, int *mon, int *mday)\n{\n\tint\t\t\tjday;\n\n\tjday = isoweek2j(*year, isoweek);\n\t/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */\n\tif (wday > 1)\n\t\tjday += wday - 2;\n\telse\n\t\tjday += 6;\n\tj2date(jday, year, mon, mday);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nisoweekdate2date(int isoweek, int wday, int *year, int *mon, int *mday)\n{\n\tint\t\t\tjday;\n\n\tjday = isoweek2j(*year, isoweek);\n\t/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */\n\tif (wday > 1)\n\t\tjday += wday - 2;\n\telse\n\t\tjday += 6;\n\tj2date(jday, year, mon, mday);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTK_M",
          "args": [
            "YEAR"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\"))"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the 24-hour clock, or give an hour between 1 and 12.\""
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_TMFC",
          "args": [
            "&tmfc"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DCH_from_char",
          "args": [
            "format",
            "date_str",
            "&tmfc"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_from_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2981-3264",
          "snippet": "static void\nDCH_from_char(FormatNode *node, char *in, TmFromChar *out)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tint\t\t\tlen,\n\t\t\t\tvalue;\n\tbool\t\tfx_mode = false;\n\n\tfor (n = node, s = in; n->type != NODE_TYPE_END && *s != '\\0'; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Separator, so consume one character from input string.  Notice\n\t\t\t * we don't insist that the consumed character match the format's\n\t\t\t * character.\n\t\t\t */\n\t\t\ts += pg_mblen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore spaces before fields when not in FX (fixed width) mode */\n\t\tif (!fx_mode && n->key->id != DCH_FX)\n\t\t{\n\t\t\twhile (*s != '\\0' && isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\n\t\tfrom_char_set_mode(out, n->key->date_mode);\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_FX:\n\t\t\t\tfx_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tfrom_char_parse_int(&out->mi, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tfrom_char_parse_int(&out->ss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->ms, &s, 3, n);\n\n\t\t\t\t/*\n\t\t\t\t * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25\n\t\t\t\t */\n\t\t\t\tout->ms *= len == 1 ? 100 :\n\t\t\t\t\tlen == 2 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->us, &s, 6, n);\n\n\t\t\t\tout->us *= len == 1 ? 100000 :\n\t\t\t\t\tlen == 2 ? 10000 :\n\t\t\t\t\tlen == 3 ? 1000 :\n\t\t\t\t\tlen == 4 ? 100 :\n\t\t\t\t\tlen == 5 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tfrom_char_parse_int(&out->ssss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\tcase DCH_TZ:\n\t\t\tcase DCH_OF:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"formatting field \\\"%s\\\" is only supported in to_char\",\n\t\t\t\t\t\t\t\tn->key->name)));\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tout->tzsign = *s == '-' ? -1 : +1;\n\n\t\t\t\tif (*s == '+' || *s == '-' || *s == ' ')\n\t\t\t\t\ts++;\n\n\t\t\t\tfrom_char_parse_int_len(&out->tzh, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\t/* assign positive timezone sign if TZH was not seen before */\n\t\t\t\tif (!out->tzsign)\n\t\t\t\t\tout->tzsign = +1;\n\t\t\t\tfrom_char_parse_int_len(&out->tzm, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\tcase DCH_Month:\n\t\t\tcase DCH_month:\n\t\t\t\tfrom_char_seq_search(&value, &s, months_full, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MONTH_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\tcase DCH_Mon:\n\t\t\tcase DCH_mon:\n\t\t\t\tfrom_char_seq_search(&value, &s, months, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MON_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tfrom_char_parse_int(&out->mm, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\tcase DCH_Day:\n\t\t\tcase DCH_day:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DAY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\tcase DCH_Dy:\n\t\t\tcase DCH_dy:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\t\tfrom_char_parse_int(&out->ddd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IDDD:\n\t\t\t\tfrom_char_parse_int_len(&out->ddd, &s, 3, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tfrom_char_parse_int(&out->dd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tfrom_char_parse_int(&out->d, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tfrom_char_parse_int_len(&out->d, &s, 1, n);\n\t\t\t\t/* Shift numbering to match Gregorian where Sunday = 1 */\n\t\t\t\tif (++out->d > 7)\n\t\t\t\t\tout->d = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\tcase DCH_IW:\n\t\t\t\tfrom_char_parse_int(&out->ww, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\n\t\t\t\t/*\n\t\t\t\t * We ignore 'Q' when converting to date because it is unclear\n\t\t\t\t * which date in the quarter to use, and some people specify\n\t\t\t\t * both quarter and month, so if it was honored it might\n\t\t\t\t * conflict with the supplied month. That is also why we don't\n\t\t\t\t * throw an error.\n\t\t\t\t *\n\t\t\t\t * We still parse the source string for an integer, but it\n\t\t\t\t * isn't stored anywhere in 'out'.\n\t\t\t\t */\n\t\t\t\tfrom_char_parse_int((int *) NULL, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tfrom_char_parse_int(&out->cc, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched,\n\t\t\t\t\t\t\t\tyears,\n\t\t\t\t\t\t\t\tmillennia,\n\t\t\t\t\t\t\t\tnch;\n\n\t\t\t\t\tmatched = sscanf(s, \"%d,%03d%n\", &millennia, &years, &nch);\n\t\t\t\t\tif (matched < 2)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input string for \\\"Y,YYY\\\"\")));\n\t\t\t\t\tyears += (millennia * 1000);\n\t\t\t\t\tfrom_char_set_int(&out->year, years, n);\n\t\t\t\t\tout->yysz = 4;\n\t\t\t\t\ts += nch;\n\t\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tfrom_char_parse_int(&out->year, &s, n);\n\t\t\t\tout->yysz = 4;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 3;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 2;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_upper,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_lower,\n\t\t\t\t\t\t\t\t\t ALL_LOWER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tfrom_char_parse_int(&out->w, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tfrom_char_parse_int(&out->j, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RM_LEN\t\t4",
            "#define MAX_DY_LEN\t\t3",
            "#define MAX_DAY_LEN\t\t9",
            "#define MAX_MON_LEN\t\t3",
            "#define MAX_MONTH_LEN\t9",
            "#define ALL_LOWER\t\t3\t\t/* name */",
            "#define ALL_UPPER\t\t2\t\t/* NAME */",
            "#define ONE_UPPER\t\t1\t\t/* Name */",
            "#define CLOCK_12_HOUR\t\t1",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1"
          ],
          "globals_used": [
            "static const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};",
            "static const char *const adbc_strings[] = {ad_STR, bc_STR, AD_STR, BC_STR, NULL};",
            "static const char *const adbc_strings_long[] = {a_d_STR, b_c_STR, A_D_STR, B_C_STR, NULL};",
            "static const char *const ampm_strings[] = {am_STR, pm_STR, AM_STR, PM_STR, NULL};",
            "static const char *const ampm_strings_long[] = {a_m_STR, p_m_STR, A_M_STR, P_M_STR, NULL};",
            "static const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};",
            "static const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tadjust_partial_year_to_2020(int year);",
            "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_RM_LEN\t\t4\n#define MAX_DY_LEN\t\t3\n#define MAX_DAY_LEN\t\t9\n#define MAX_MON_LEN\t\t3\n#define MAX_MONTH_LEN\t9\n#define ALL_LOWER\t\t3\t\t/* name */\n#define ALL_UPPER\t\t2\t\t/* NAME */\n#define ONE_UPPER\t\t1\t\t/* Name */\n#define CLOCK_12_HOUR\t\t1\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n\nstatic const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};\nstatic const char *const adbc_strings[] = {ad_STR, bc_STR, AD_STR, BC_STR, NULL};\nstatic const char *const adbc_strings_long[] = {a_d_STR, b_c_STR, A_D_STR, B_C_STR, NULL};\nstatic const char *const ampm_strings[] = {am_STR, pm_STR, AM_STR, PM_STR, NULL};\nstatic const char *const ampm_strings_long[] = {a_m_STR, p_m_STR, A_M_STR, P_M_STR, NULL};\nstatic const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};\nstatic const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tadjust_partial_year_to_2020(int year);\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nDCH_from_char(FormatNode *node, char *in, TmFromChar *out)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tint\t\t\tlen,\n\t\t\t\tvalue;\n\tbool\t\tfx_mode = false;\n\n\tfor (n = node, s = in; n->type != NODE_TYPE_END && *s != '\\0'; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Separator, so consume one character from input string.  Notice\n\t\t\t * we don't insist that the consumed character match the format's\n\t\t\t * character.\n\t\t\t */\n\t\t\ts += pg_mblen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore spaces before fields when not in FX (fixed width) mode */\n\t\tif (!fx_mode && n->key->id != DCH_FX)\n\t\t{\n\t\t\twhile (*s != '\\0' && isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\n\t\tfrom_char_set_mode(out, n->key->date_mode);\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_FX:\n\t\t\t\tfx_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tfrom_char_parse_int(&out->mi, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tfrom_char_parse_int(&out->ss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->ms, &s, 3, n);\n\n\t\t\t\t/*\n\t\t\t\t * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25\n\t\t\t\t */\n\t\t\t\tout->ms *= len == 1 ? 100 :\n\t\t\t\t\tlen == 2 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->us, &s, 6, n);\n\n\t\t\t\tout->us *= len == 1 ? 100000 :\n\t\t\t\t\tlen == 2 ? 10000 :\n\t\t\t\t\tlen == 3 ? 1000 :\n\t\t\t\t\tlen == 4 ? 100 :\n\t\t\t\t\tlen == 5 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tfrom_char_parse_int(&out->ssss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\tcase DCH_TZ:\n\t\t\tcase DCH_OF:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"formatting field \\\"%s\\\" is only supported in to_char\",\n\t\t\t\t\t\t\t\tn->key->name)));\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tout->tzsign = *s == '-' ? -1 : +1;\n\n\t\t\t\tif (*s == '+' || *s == '-' || *s == ' ')\n\t\t\t\t\ts++;\n\n\t\t\t\tfrom_char_parse_int_len(&out->tzh, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\t/* assign positive timezone sign if TZH was not seen before */\n\t\t\t\tif (!out->tzsign)\n\t\t\t\t\tout->tzsign = +1;\n\t\t\t\tfrom_char_parse_int_len(&out->tzm, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\tcase DCH_Month:\n\t\t\tcase DCH_month:\n\t\t\t\tfrom_char_seq_search(&value, &s, months_full, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MONTH_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\tcase DCH_Mon:\n\t\t\tcase DCH_mon:\n\t\t\t\tfrom_char_seq_search(&value, &s, months, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MON_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tfrom_char_parse_int(&out->mm, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\tcase DCH_Day:\n\t\t\tcase DCH_day:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DAY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\tcase DCH_Dy:\n\t\t\tcase DCH_dy:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\t\tfrom_char_parse_int(&out->ddd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IDDD:\n\t\t\t\tfrom_char_parse_int_len(&out->ddd, &s, 3, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tfrom_char_parse_int(&out->dd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tfrom_char_parse_int(&out->d, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tfrom_char_parse_int_len(&out->d, &s, 1, n);\n\t\t\t\t/* Shift numbering to match Gregorian where Sunday = 1 */\n\t\t\t\tif (++out->d > 7)\n\t\t\t\t\tout->d = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\tcase DCH_IW:\n\t\t\t\tfrom_char_parse_int(&out->ww, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\n\t\t\t\t/*\n\t\t\t\t * We ignore 'Q' when converting to date because it is unclear\n\t\t\t\t * which date in the quarter to use, and some people specify\n\t\t\t\t * both quarter and month, so if it was honored it might\n\t\t\t\t * conflict with the supplied month. That is also why we don't\n\t\t\t\t * throw an error.\n\t\t\t\t *\n\t\t\t\t * We still parse the source string for an integer, but it\n\t\t\t\t * isn't stored anywhere in 'out'.\n\t\t\t\t */\n\t\t\t\tfrom_char_parse_int((int *) NULL, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tfrom_char_parse_int(&out->cc, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched,\n\t\t\t\t\t\t\t\tyears,\n\t\t\t\t\t\t\t\tmillennia,\n\t\t\t\t\t\t\t\tnch;\n\n\t\t\t\t\tmatched = sscanf(s, \"%d,%03d%n\", &millennia, &years, &nch);\n\t\t\t\t\tif (matched < 2)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input string for \\\"Y,YYY\\\"\")));\n\t\t\t\t\tyears += (millennia * 1000);\n\t\t\t\t\tfrom_char_set_int(&out->year, years, n);\n\t\t\t\t\tout->yysz = 4;\n\t\t\t\t\ts += nch;\n\t\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tfrom_char_parse_int(&out->year, &s, n);\n\t\t\t\tout->yysz = 4;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 3;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 2;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_upper,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_lower,\n\t\t\t\t\t\t\t\t\t ALL_LOWER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tfrom_char_parse_int(&out->w, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tfrom_char_parse_int(&out->j, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DCH_cache_fetch",
          "args": [
            "fmt_str"
          ],
          "line": 3678
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_cache_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3357-3377",
          "snippet": "static DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_format",
          "args": [
            "format",
            "fmt_str",
            "DCH_keywords",
            "DCH_suff",
            "DCH_index",
            "DCH_TYPE",
            "NULL"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1225-1334",
          "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SUFFTYPE_POSTFIX\t2",
            "#define SUFFTYPE_PREFIX\t\t1",
            "#define NODE_TYPE_CHAR\t\t3",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(fmt_len + 1) * sizeof(FormatNode)"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "fmt"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "fmt"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_tm",
          "args": [
            "tm"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_tmfc",
          "args": [
            "&tmfc"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define CLOCK_12_HOUR\t\t1\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tadjust_partial_year_to_2020(int year);\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\n\nstatic void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}"
  },
  {
    "function_name": "to_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3591-3619",
    "snippet": "Datum\nto_date(PG_FUNCTION_ARGS)\n{\n\ttext\t   *date_txt = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tDateADT\t\tresult;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tdo_to_timestamp(date_txt, fmt, &tm, &fsec);\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt))));\n\n\tresult = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt))));\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt)))"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range: \\\"%s\\\"\"",
            "text_to_cstring(date_txt)"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "date_txt"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "result"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt)))"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_to_timestamp",
          "args": [
            "date_txt",
            "fmt",
            "&tm",
            "&fsec"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "do_to_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3634-3916",
          "snippet": "static void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_SIZE\t\t128",
            "#define CLOCK_12_HOUR\t\t1",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static int\tadjust_partial_year_to_2020(int year);",
            "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);",
            "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define CLOCK_12_HOUR\t\t1\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tadjust_partial_year_to_2020(int year);\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\n\nstatic void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\n\nDatum\nto_date(PG_FUNCTION_ARGS)\n{\n\ttext\t   *date_txt = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tDateADT\t\tresult;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tdo_to_timestamp(date_txt, fmt, &tm, &fsec);\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt))));\n\n\tresult = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\",\n\t\t\t\t\t\ttext_to_cstring(date_txt))));\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "to_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3555-3584",
    "snippet": "Datum\nto_timestamp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *date_txt = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tdo_to_timestamp(date_txt, fmt, &tm, &fsec);\n\n\t/* Use the specified time zone, if any. */\n\tif (tm.tm_zone)\n\t{\n\t\tint\t\t\tdterr = DecodeTimezone((char *) tm.tm_zone, &tz);\n\n\t\tif (dterr)\n\t\t\tDateTimeParseError(dterr, text_to_cstring(date_txt), \"timestamptz\");\n\t}\n\telse\n\t\ttz = DetermineTimeZoneOffset(&tm, session_timezone);\n\n\tif (tm2timestamp(&tm, fsec, &tz, &result) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "&tm",
            "fsec",
            "&tz",
            "&result"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "&tm",
            "session_timezone"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "text_to_cstring(date_txt)",
            "\"timestamptz\""
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "date_txt"
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimezone",
          "args": [
            "(char *) tm.tm_zone",
            "&tz"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2892-2953",
          "snippet": "int\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nDecodeTimezone(char *str, int *tzp)\n{\n\tint\t\t\ttz;\n\tint\t\t\thr,\n\t\t\t\tmin,\n\t\t\t\tsec = 0;\n\tchar\t   *cp;\n\n\t/* leading character must be \"+\" or \"-\" */\n\tif (*str != '+' && *str != '-')\n\t\treturn DTERR_BAD_FORMAT;\n\n\terrno = 0;\n\thr = strtoint(str + 1, &cp, 10);\n\tif (errno == ERANGE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\t/* explicit delimiter? */\n\tif (*cp == ':')\n\t{\n\t\terrno = 0;\n\t\tmin = strtoint(cp + 1, &cp, 10);\n\t\tif (errno == ERANGE)\n\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\tif (*cp == ':')\n\t\t{\n\t\t\terrno = 0;\n\t\t\tsec = strtoint(cp + 1, &cp, 10);\n\t\t\tif (errno == ERANGE)\n\t\t\t\treturn DTERR_TZDISP_OVERFLOW;\n\t\t}\n\t}\n\t/* otherwise, might have run things together... */\n\telse if (*cp == '\\0' && strlen(str) > 3)\n\t{\n\t\tmin = hr % 100;\n\t\thr = hr / 100;\n\t\t/* we could, but don't, support a run-together hhmmss format */\n\t}\n\telse\n\t\tmin = 0;\n\n\t/* Range-check the values; see notes in datatype/timestamp.h */\n\tif (hr < 0 || hr > MAX_TZDISP_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (min < 0 || min >= MINS_PER_HOUR)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\tif (sec < 0 || sec >= SECS_PER_MINUTE)\n\t\treturn DTERR_TZDISP_OVERFLOW;\n\n\ttz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;\n\tif (*str == '-')\n\t\ttz = -tz;\n\n\t*tzp = -tz;\n\n\tif (*cp != '\\0')\n\t\treturn DTERR_BAD_FORMAT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_to_timestamp",
          "args": [
            "date_txt",
            "fmt",
            "&tm",
            "&fsec"
          ],
          "line": 3565
        },
        "resolved": true,
        "details": {
          "function_name": "do_to_timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3634-3916",
          "snippet": "static void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_SIZE\t\t128",
            "#define CLOCK_12_HOUR\t\t1",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static int\tadjust_partial_year_to_2020(int year);",
            "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);",
            "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define CLOCK_12_HOUR\t\t1\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tadjust_partial_year_to_2020(int year);\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\n\nstatic void\ndo_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec)\n{\n\tFormatNode *format;\n\tTmFromChar\ttmfc;\n\tint\t\t\tfmt_len;\n\tchar\t   *date_str;\n\tint\t\t\tfmask;\n\n\tdate_str = text_to_cstring(date_txt);\n\n\tZERO_tmfc(&tmfc);\n\tZERO_tm(tm);\n\t*fsec = 0;\n\tfmask = 0;\t\t\t\t\t/* bit mask for ValidateDate() */\n\n\tfmt_len = VARSIZE_ANY_EXHDR(fmt);\n\n\tif (fmt_len)\n\t{\n\t\tchar\t   *fmt_str;\n\t\tbool\t\tincache;\n\n\t\tfmt_str = text_to_cstring(fmt);\n\n\t\tif (fmt_len > DCH_CACHE_SIZE)\n\t\t{\n\t\t\t/*\n\t\t\t * Allocate new memory if format picture is bigger than static\n\t\t\t * cache and do not use cache (call parser always)\n\t\t\t */\n\t\t\tincache = false;\n\n\t\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Use cache buffers\n\t\t\t */\n\t\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\t\tincache = true;\n\t\t\tformat = ent->format;\n\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t/* dump_node(format, fmt_len); */\n\t\t/* dump_index(DCH_keywords, DCH_index); */\n#endif\n\n\t\tDCH_from_char(format, date_str, &tmfc);\n\n\t\tpfree(fmt_str);\n\t\tif (!incache)\n\t\t\tpfree(format);\n\t}\n\n\tDEBUG_TMFC(&tmfc);\n\n\t/*\n\t * Convert to_date/to_timestamp input fields to standard 'tm'\n\t */\n\tif (tmfc.ssss)\n\t{\n\t\tint\t\t\tx = tmfc.ssss;\n\n\t\ttm->tm_hour = x / SECS_PER_HOUR;\n\t\tx %= SECS_PER_HOUR;\n\t\ttm->tm_min = x / SECS_PER_MINUTE;\n\t\tx %= SECS_PER_MINUTE;\n\t\ttm->tm_sec = x;\n\t}\n\n\tif (tmfc.ss)\n\t\ttm->tm_sec = tmfc.ss;\n\tif (tmfc.mi)\n\t\ttm->tm_min = tmfc.mi;\n\tif (tmfc.hh)\n\t\ttm->tm_hour = tmfc.hh;\n\n\tif (tmfc.clock == CLOCK_12_HOUR)\n\t{\n\t\tif (tm->tm_hour < 1 || tm->tm_hour > HOURS_PER_DAY / 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"hour \\\"%d\\\" is invalid for the 12-hour clock\",\n\t\t\t\t\t\t\ttm->tm_hour),\n\t\t\t\t\t errhint(\"Use the 24-hour clock, or give an hour between 1 and 12.\")));\n\n\t\tif (tmfc.pm && tm->tm_hour < HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\t\telse if (!tmfc.pm && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\t\ttm->tm_hour = 0;\n\t}\n\n\tif (tmfc.year)\n\t{\n\t\t/*\n\t\t * If CC and YY (or Y) are provided, use YY as 2 low-order digits for\n\t\t * the year in the given century.  Keep in mind that the 21st century\n\t\t * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from\n\t\t * 600BC to 501BC.\n\t\t */\n\t\tif (tmfc.cc && tmfc.yysz <= 2)\n\t\t{\n\t\t\tif (tmfc.bc)\n\t\t\t\ttmfc.cc = -tmfc.cc;\n\t\t\ttm->tm_year = tmfc.year % 100;\n\t\t\tif (tm->tm_year)\n\t\t\t{\n\t\t\t\tif (tmfc.cc >= 0)\n\t\t\t\t\ttm->tm_year += (tmfc.cc - 1) * 100;\n\t\t\t\telse\n\t\t\t\t\ttm->tm_year = (tmfc.cc + 1) * 100 - tm->tm_year + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* find century year for dates ending in \"00\" */\n\t\t\t\ttm->tm_year = tmfc.cc * 100 + ((tmfc.cc >= 0) ? 0 : 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If a 4-digit year is provided, we use that and ignore CC. */\n\t\t\ttm->tm_year = tmfc.year;\n\t\t\tif (tmfc.bc && tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\telse if (tmfc.cc)\n\t{\n\t\t/* use first year of century */\n\t\tif (tmfc.bc)\n\t\t\ttmfc.cc = -tmfc.cc;\n\t\tif (tmfc.cc >= 0)\n\t\t\t/* +1 because 21st century started in 2001 */\n\t\t\ttm->tm_year = (tmfc.cc - 1) * 100 + 1;\n\t\telse\n\t\t\t/* +1 because year == 599 is 600 BC */\n\t\t\ttm->tm_year = tmfc.cc * 100 + 1;\n\t\tfmask |= DTK_M(YEAR);\n\t}\n\n\tif (tmfc.j)\n\t{\n\t\tj2date(tmfc.j, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\tfmask |= DTK_DATE_M;\n\t}\n\n\tif (tmfc.ww)\n\t{\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\t/*\n\t\t\t * If tmfc.d is not set, then the date is left at the beginning of\n\t\t\t * the ISO week (Monday).\n\t\t\t */\n\t\t\tif (tmfc.d)\n\t\t\t\tisoweekdate2date(tmfc.ww, tmfc.d, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\telse\n\t\t\t\tisoweek2date(tmfc.ww, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t\ttmfc.ddd = (tmfc.ww - 1) * 7 + 1;\n\t}\n\n\tif (tmfc.w)\n\t\ttmfc.dd = (tmfc.w - 1) * 7 + 1;\n\tif (tmfc.dd)\n\t{\n\t\ttm->tm_mday = tmfc.dd;\n\t\tfmask |= DTK_M(DAY);\n\t}\n\tif (tmfc.mm)\n\t{\n\t\ttm->tm_mon = tmfc.mm;\n\t\tfmask |= DTK_M(MONTH);\n\t}\n\n\tif (tmfc.ddd && (tm->tm_mon <= 1 || tm->tm_mday <= 1))\n\t{\n\t\t/*\n\t\t * The month and day field have not been set, so we use the\n\t\t * day-of-year field to populate them.  Depending on the date mode,\n\t\t * this field may be interpreted as a Gregorian day-of-year, or an ISO\n\t\t * week date day-of-year.\n\t\t */\n\n\t\tif (!tm->tm_year && !tmfc.bc)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"cannot calculate day of year without year information\")));\n\n\t\tif (tmfc.mode == FROM_CHAR_DATE_ISOWEEK)\n\t\t{\n\t\t\tint\t\t\tj0;\t\t/* zeroth day of the ISO year, in Julian */\n\n\t\t\tj0 = isoweek2j(tm->tm_year, 1) - 1;\n\n\t\t\tj2date(j0 + tmfc.ddd, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\tfmask |= DTK_DATE_M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst int  *y;\n\t\t\tint\t\t\ti;\n\n\t\t\tstatic const int ysum[2][13] = {\n\t\t\t\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\t\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};\n\n\t\t\ty = ysum[isleap(tm->tm_year)];\n\n\t\t\tfor (i = 1; i <= MONTHS_PER_YEAR; i++)\n\t\t\t{\n\t\t\t\tif (tmfc.ddd <= y[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tm->tm_mon <= 1)\n\t\t\t\ttm->tm_mon = i;\n\n\t\t\tif (tm->tm_mday <= 1)\n\t\t\t\ttm->tm_mday = tmfc.ddd - y[i - 1];\n\n\t\t\tfmask |= DTK_M(MONTH) | DTK_M(DAY);\n\t\t}\n\t}\n\n\tif (tmfc.ms)\n\t\t*fsec += tmfc.ms * 1000;\n\tif (tmfc.us)\n\t\t*fsec += tmfc.us;\n\n\t/* Range-check date fields according to bit mask computed above */\n\tif (fmask != 0)\n\t{\n\t\t/* We already dealt with AD/BC, so pass isjulian = true */\n\t\tint\t\t\tdterr = ValidateDate(fmask, true, false, false, tm);\n\n\t\tif (dterr != 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate\n\t\t\t * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an\n\t\t\t * irrelevant hint about datestyle.\n\t\t\t */\n\t\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\t\t}\n\t}\n\n\t/* Range-check time fields too */\n\tif (tm->tm_hour < 0 || tm->tm_hour >= HOURS_PER_DAY ||\n\t\ttm->tm_min < 0 || tm->tm_min >= MINS_PER_HOUR ||\n\t\ttm->tm_sec < 0 || tm->tm_sec >= SECS_PER_MINUTE ||\n\t\t*fsec < INT64CONST(0) || *fsec >= USECS_PER_SEC)\n\t\tDateTimeParseError(DTERR_FIELD_OVERFLOW, date_str, \"timestamp\");\n\n\t/* Save parsed time-zone into tm->tm_zone if it was specified */\n\tif (tmfc.tzsign)\n\t{\n\t\tchar\t   *tz;\n\n\t\tif (tmfc.tzh < 0 || tmfc.tzh > MAX_TZDISP_HOUR ||\n\t\t\ttmfc.tzm < 0 || tmfc.tzm >= MINS_PER_HOUR)\n\t\t\tDateTimeParseError(DTERR_TZDISP_OVERFLOW, date_str, \"timestamp\");\n\n\t\ttz = psprintf(\"%c%02d:%02d\",\n\t\t\t\t\t  tmfc.tzsign > 0 ? '+' : '-', tmfc.tzh, tmfc.tzm);\n\n\t\ttm->tm_zone = tz;\n\t}\n\n\tDEBUG_TM(tm);\n\n\tpfree(date_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\n\nDatum\nto_timestamp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *date_txt = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1);\n\tTimestamp\tresult;\n\tint\t\t\ttz;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\n\tdo_to_timestamp(date_txt, fmt, &tm, &fsec);\n\n\t/* Use the specified time zone, if any. */\n\tif (tm.tm_zone)\n\t{\n\t\tint\t\t\tdterr = DecodeTimezone((char *) tm.tm_zone, &tz);\n\n\t\tif (dterr)\n\t\t\tDateTimeParseError(dterr, text_to_cstring(date_txt), \"timestamptz\");\n\t}\n\telse\n\t\ttz = DetermineTimeZoneOffset(&tm, session_timezone);\n\n\tif (tm2timestamp(&tm, fsec, &tz, &result) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "interval_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3521-3546",
    "snippet": "Datum\ninterval_to_char(PG_FUNCTION_ARGS)\n{\n\tInterval   *it = PG_GETARG_INTERVAL_P(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tstruct pg_tm *tm;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0)\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (interval2tm(*it, tm, &tmtcFsec(&tmtc)) != 0)\n\t\tPG_RETURN_NULL();\n\n\t/* wday is meaningless, yday approximates the total span in days */\n\ttm->tm_yday = (tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon) * DAYS_PER_MONTH + tm->tm_mday;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, true, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "res"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datetime_to_char_body",
          "args": [
            "&tmtc",
            "fmt",
            "true",
            "PG_GET_COLLATION()"
          ],
          "line": 3542
        },
        "resolved": true,
        "details": {
          "function_name": "datetime_to_char_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3384-3443",
          "snippet": "static text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_SIZE\t\t128",
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interval2tm",
          "args": [
            "*it",
            "tm",
            "&tmtcFsec(&tmtc)"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "interval2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1901-1927",
          "snippet": "int\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ninterval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec)\n{\n\tTimeOffset\ttime;\n\tTimeOffset\ttfrac;\n\n\ttm->tm_year = span.month / MONTHS_PER_YEAR;\n\ttm->tm_mon = span.month % MONTHS_PER_YEAR;\n\ttm->tm_mday = span.day;\n\ttime = span.time;\n\n\ttfrac = time / USECS_PER_HOUR;\n\ttime -= tfrac * USECS_PER_HOUR;\n\ttm->tm_hour = tfrac;\n\tif (!SAMESIGN(tm->tm_hour, tfrac))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"interval out of range\")));\n\ttfrac = time / USECS_PER_MINUTE;\n\ttime -= tfrac * USECS_PER_MINUTE;\n\ttm->tm_min = tfrac;\n\ttfrac = time / USECS_PER_SEC;\n\t*fsec = time - (tfrac * USECS_PER_SEC);\n\ttm->tm_sec = tfrac;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmtcFsec",
          "args": [
            "&tmtc"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTm",
          "args": [
            "&tmtc"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_tmtc",
          "args": [
            "&tmtc"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "fmt"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_to_char(PG_FUNCTION_ARGS)\n{\n\tInterval   *it = PG_GETARG_INTERVAL_P(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tstruct pg_tm *tm;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0)\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (interval2tm(*it, tm, &tmtcFsec(&tmtc)) != 0)\n\t\tPG_RETURN_NULL();\n\n\t/* wday is meaningless, yday approximates the total span in days */\n\ttm->tm_yday = (tm->tm_year * MONTHS_PER_YEAR + tm->tm_mon) * DAYS_PER_MONTH + tm->tm_mday;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, true, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}"
  },
  {
    "function_name": "timestamptz_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3484-3514",
    "snippet": "Datum\ntimestamptz_to_char(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt = PG_GETARG_TIMESTAMP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tint\t\t\ttz;\n\tstruct pg_tm *tm;\n\tint\t\t\tthisdate;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0 || TIMESTAMP_NOT_FINITE(dt))\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (timestamp2tm(dt, &tz, tm, &tmtcFsec(&tmtc), &tmtcTzn(&tmtc), NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tthisdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\ttm->tm_wday = (thisdate + 1) % 7;\n\ttm->tm_yday = thisdate - date2j(tm->tm_year, 1, 1) + 1;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, false, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "res"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datetime_to_char_body",
          "args": [
            "&tmtc",
            "fmt",
            "false",
            "PG_GET_COLLATION()"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "datetime_to_char_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3384-3443",
          "snippet": "static text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_SIZE\t\t128",
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "1",
            "1"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3503
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "dt",
            "&tz",
            "tm",
            "&tmtcFsec(&tmtc)",
            "&tmtcTzn(&tmtc)",
            "NULL"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmtcTzn",
          "args": [
            "&tmtc"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcFsec",
          "args": [
            "&tmtc"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTm",
          "args": [
            "&tmtc"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_tmtc",
          "args": [
            "&tmtc"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "dt"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "fmt"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\n\nDatum\ntimestamptz_to_char(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt = PG_GETARG_TIMESTAMP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tint\t\t\ttz;\n\tstruct pg_tm *tm;\n\tint\t\t\tthisdate;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0 || TIMESTAMP_NOT_FINITE(dt))\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (timestamp2tm(dt, &tz, tm, &tmtcFsec(&tmtc), &tmtcTzn(&tmtc), NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tthisdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\ttm->tm_wday = (thisdate + 1) % 7;\n\ttm->tm_yday = thisdate - date2j(tm->tm_year, 1, 1) + 1;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, false, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}"
  },
  {
    "function_name": "timestamp_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3453-3482",
    "snippet": "Datum\ntimestamp_to_char(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt = PG_GETARG_TIMESTAMP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tstruct pg_tm *tm;\n\tint\t\t\tthisdate;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0 || TIMESTAMP_NOT_FINITE(dt))\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (timestamp2tm(dt, NULL, tm, &tmtcFsec(&tmtc), NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tthisdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\ttm->tm_wday = (thisdate + 1) % 7;\n\ttm->tm_yday = thisdate - date2j(tm->tm_year, 1, 1) + 1;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, false, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "res"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datetime_to_char_body",
          "args": [
            "&tmtc",
            "fmt",
            "false",
            "PG_GET_COLLATION()"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "datetime_to_char_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3384-3443",
          "snippet": "static text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_SIZE\t\t128",
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "1",
            "1"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "dt",
            "NULL",
            "tm",
            "&tmtcFsec(&tmtc)",
            "NULL",
            "NULL"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmtcFsec",
          "args": [
            "&tmtc"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTm",
          "args": [
            "&tmtc"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_tmtc",
          "args": [
            "&tmtc"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "dt"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "fmt"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\n\nDatum\ntimestamp_to_char(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt = PG_GETARG_TIMESTAMP(0);\n\ttext\t   *fmt = PG_GETARG_TEXT_PP(1),\n\t\t\t   *res;\n\tTmToChar\ttmtc;\n\tstruct pg_tm *tm;\n\tint\t\t\tthisdate;\n\n\tif (VARSIZE_ANY_EXHDR(fmt) <= 0 || TIMESTAMP_NOT_FINITE(dt))\n\t\tPG_RETURN_NULL();\n\n\tZERO_tmtc(&tmtc);\n\ttm = tmtcTm(&tmtc);\n\n\tif (timestamp2tm(dt, NULL, tm, &tmtcFsec(&tmtc), NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tthisdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\ttm->tm_wday = (thisdate + 1) % 7;\n\ttm->tm_yday = thisdate - date2j(tm->tm_year, 1, 1) + 1;\n\n\tif (!(res = datetime_to_char_body(&tmtc, fmt, false, PG_GET_COLLATION())))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(res);\n}"
  },
  {
    "function_name": "datetime_to_char_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3384-3443",
    "snippet": "static text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_CACHE_SIZE\t\t128",
      "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/",
      "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
    ],
    "globals_used": [
      "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
      "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
      "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "result"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DCH_to_char",
          "args": [
            "format",
            "is_interval",
            "tmtc",
            "result",
            "collid"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_to_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2401-2971",
          "snippet": "static void\nDCH_to_char(FormatNode *node, bool is_interval, TmToChar *in, char *out, Oid collid)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tstruct pg_tm *tm = &in->tm;\n\tint\t\t\ti;\n\n\t/* cache localized days and months */\n\tcache_locale_time();\n\n\ts = out;\n\tfor (n = node; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\tstrcpy(s, n->character);\n\t\t\ts += strlen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? P_M_STR : A_M_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? PM_STR : AM_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? p_m_STR : a_m_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? pm_STR : am_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\n\t\t\t\t/*\n\t\t\t\t * display time as shown on a 12-hour clock, even for\n\t\t\t\t * intervals\n\t\t\t\t */\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 :\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_min >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_min);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_sec >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tsprintf(s, \"%03d\", (int) (in->fsec / INT64CONST(1000)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tsprintf(s, \"%06d\", (int) in->fsec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tsprintf(s, \"%d\", tm->tm_hour * SECS_PER_HOUR +\n\t\t\t\t\t\ttm->tm_min * SECS_PER_MINUTE +\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\t/* We assume here that timezone names aren't localized */\n\t\t\t\t\tchar\t   *p = asc_tolower_z(tmtcTzn(in));\n\n\t\t\t\t\tstrcpy(s, p);\n\t\t\t\t\tpfree(p);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZ:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, tmtcTzn(in));\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%02d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%02d\",\n\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_OF:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%0*d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tif (abs((int) tm->tm_gmtoff) % SECS_PER_HOUR != 0)\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \":%02d\",\n\t\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? B_C_STR : A_D_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? BC_STR : AD_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? b_c_STR : a_d_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? bc_STR : ad_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tmonths_full[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, months[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_mon >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_mon);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tdays[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, days_short[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\tcase DCH_IDDD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_DDD) ?\n\t\t\t\t\t\ttm->tm_yday :\n\t\t\t\t\t\tdate2isoyearday(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2, tm->tm_mday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", tm->tm_wday + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_wday == 0) ? 7 : tm->tm_wday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\t(tm->tm_yday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tdate2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mon - 1) / 3 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tif (is_interval)\t/* straight calculation */\n\t\t\t\t\ti = tm->tm_year / 100;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\t/* Century 20 == 1901 - 2000 */\n\t\t\t\t\t\ti = (tm->tm_year - 1) / 100 + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Century 6BC == 600BC - 501BC */\n\t\t\t\t\t\ti = tm->tm_year / 100 - 1;\n\t\t\t\t}\n\t\t\t\tif (i <= 99 && i >= -99)\n\t\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (i >= 0) ? 2 : 3, i);\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%d\", i);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\ti = ADJUST_YEAR(tm->tm_year, is_interval) / 1000;\n\t\t\t\tsprintf(s, \"%d,%03d\", i,\n\t\t\t\t\t\tADJUST_YEAR(tm->tm_year, is_interval) - (i * 1000));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 4 : 5,\n\t\t\t\t\t\t(n->key->id == DCH_YYYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 3 : 4,\n\t\t\t\t\t\t(n->key->id == DCH_YYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 1000);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 2 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_YY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 100);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tsprintf(s, \"%1d\",\n\t\t\t\t\t\t(n->key->id == DCH_Y ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 10);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_upper[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_lower[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tsprintf(s, \"%d\", date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*s = '\\0';\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TM_SUFFIX_LEN\t2",
            "#define INVALID_FOR_INTERVAL  \\\ndo { \\\n\tif (is_interval) \\\n\t\tereport(ERROR, \\\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT), \\\n\t\t\t\t errmsg(\"invalid format specification for an interval value\"), \\\n\t\t\t\t errhint(\"Intervals are not tied to specific calendar dates.\"))); \\\n} while(0)",
            "#define pm_STR\t\t\"pm\"",
            "#define PM_STR\t\t\"PM\"",
            "#define p_m_STR\t\t\"p.m.\"",
            "#define P_M_STR\t\t\"P.M.\"",
            "#define am_STR\t\t\"am\"",
            "#define AM_STR\t\t\"AM\"",
            "#define a_m_STR\t\t\"a.m.\"",
            "#define A_M_STR\t\t\"A.M.\"",
            "#define bc_STR\t\t\"bc\"",
            "#define BC_STR\t\t\"BC\"",
            "#define b_c_STR\t\t\"b.c.\"",
            "#define B_C_STR\t\t\"B.C.\"",
            "#define ad_STR\t\t\"ad\"",
            "#define AD_STR\t\t\"AD\"",
            "#define a_d_STR\t\t\"a.d.\"",
            "#define A_D_STR\t\t\"A.D.\"",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
          ],
          "globals_used": [
            "static const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};",
            "static const char *const days_short[] = {\n\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", NULL\n};",
            "static const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};",
            "static const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TM_SUFFIX_LEN\t2\n#define INVALID_FOR_INTERVAL  \\\ndo { \\\n\tif (is_interval) \\\n\t\tereport(ERROR, \\\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT), \\\n\t\t\t\t errmsg(\"invalid format specification for an interval value\"), \\\n\t\t\t\t errhint(\"Intervals are not tied to specific calendar dates.\"))); \\\n} while(0)\n#define pm_STR\t\t\"pm\"\n#define PM_STR\t\t\"PM\"\n#define p_m_STR\t\t\"p.m.\"\n#define P_M_STR\t\t\"P.M.\"\n#define am_STR\t\t\"am\"\n#define AM_STR\t\t\"AM\"\n#define a_m_STR\t\t\"a.m.\"\n#define A_M_STR\t\t\"A.M.\"\n#define bc_STR\t\t\"bc\"\n#define BC_STR\t\t\"BC\"\n#define b_c_STR\t\t\"b.c.\"\n#define B_C_STR\t\t\"B.C.\"\n#define ad_STR\t\t\"ad\"\n#define AD_STR\t\t\"AD\"\n#define a_d_STR\t\t\"a.d.\"\n#define A_D_STR\t\t\"A.D.\"\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};\nstatic const char *const days_short[] = {\n\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", NULL\n};\nstatic const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};\nstatic const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nDCH_to_char(FormatNode *node, bool is_interval, TmToChar *in, char *out, Oid collid)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tstruct pg_tm *tm = &in->tm;\n\tint\t\t\ti;\n\n\t/* cache localized days and months */\n\tcache_locale_time();\n\n\ts = out;\n\tfor (n = node; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\tstrcpy(s, n->character);\n\t\t\ts += strlen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? P_M_STR : A_M_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? PM_STR : AM_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? p_m_STR : a_m_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? pm_STR : am_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\n\t\t\t\t/*\n\t\t\t\t * display time as shown on a 12-hour clock, even for\n\t\t\t\t * intervals\n\t\t\t\t */\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 :\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_min >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_min);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_sec >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tsprintf(s, \"%03d\", (int) (in->fsec / INT64CONST(1000)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tsprintf(s, \"%06d\", (int) in->fsec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tsprintf(s, \"%d\", tm->tm_hour * SECS_PER_HOUR +\n\t\t\t\t\t\ttm->tm_min * SECS_PER_MINUTE +\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\t/* We assume here that timezone names aren't localized */\n\t\t\t\t\tchar\t   *p = asc_tolower_z(tmtcTzn(in));\n\n\t\t\t\t\tstrcpy(s, p);\n\t\t\t\t\tpfree(p);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZ:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, tmtcTzn(in));\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%02d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%02d\",\n\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_OF:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%0*d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tif (abs((int) tm->tm_gmtoff) % SECS_PER_HOUR != 0)\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \":%02d\",\n\t\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? B_C_STR : A_D_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? BC_STR : AD_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? b_c_STR : a_d_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? bc_STR : ad_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tmonths_full[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, months[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_mon >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_mon);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tdays[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, days_short[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\tcase DCH_IDDD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_DDD) ?\n\t\t\t\t\t\ttm->tm_yday :\n\t\t\t\t\t\tdate2isoyearday(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2, tm->tm_mday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", tm->tm_wday + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_wday == 0) ? 7 : tm->tm_wday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\t(tm->tm_yday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tdate2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mon - 1) / 3 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tif (is_interval)\t/* straight calculation */\n\t\t\t\t\ti = tm->tm_year / 100;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\t/* Century 20 == 1901 - 2000 */\n\t\t\t\t\t\ti = (tm->tm_year - 1) / 100 + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Century 6BC == 600BC - 501BC */\n\t\t\t\t\t\ti = tm->tm_year / 100 - 1;\n\t\t\t\t}\n\t\t\t\tif (i <= 99 && i >= -99)\n\t\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (i >= 0) ? 2 : 3, i);\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%d\", i);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\ti = ADJUST_YEAR(tm->tm_year, is_interval) / 1000;\n\t\t\t\tsprintf(s, \"%d,%03d\", i,\n\t\t\t\t\t\tADJUST_YEAR(tm->tm_year, is_interval) - (i * 1000));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 4 : 5,\n\t\t\t\t\t\t(n->key->id == DCH_YYYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 3 : 4,\n\t\t\t\t\t\t(n->key->id == DCH_YYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 1000);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 2 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_YY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 100);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tsprintf(s, \"%1d\",\n\t\t\t\t\t\t(n->key->id == DCH_Y ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 10);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_upper[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_lower[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tsprintf(s, \"%d\", date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*s = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "DCH_cache_fetch",
          "args": [
            "fmt_str"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_cache_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3357-3377",
          "snippet": "static DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
          ],
          "globals_used": [
            "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
            "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
            "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_format",
          "args": [
            "format",
            "fmt_str",
            "DCH_keywords",
            "DCH_suff",
            "DCH_index",
            "DCH_TYPE",
            "NULL"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1225-1334",
          "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SUFFTYPE_POSTFIX\t2",
            "#define SUFFTYPE_PREFIX\t\t1",
            "#define NODE_TYPE_CHAR\t\t3",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(fmt_len + 1) * sizeof(FormatNode)"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fmt_str"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "fmt"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_SIZE\t\t128\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic text *\ndatetime_to_char_body(TmToChar *tmtc, text *fmt, bool is_interval, Oid collid)\n{\n\tFormatNode *format;\n\tchar\t   *fmt_str,\n\t\t\t   *result;\n\tbool\t\tincache;\n\tint\t\t\tfmt_len;\n\ttext\t   *res;\n\n\t/*\n\t * Convert fmt to C string\n\t */\n\tfmt_str = text_to_cstring(fmt);\n\tfmt_len = strlen(fmt_str);\n\n\t/*\n\t * Allocate workspace for result as C string\n\t */\n\tresult = palloc((fmt_len * DCH_MAX_ITEM_SIZ) + 1);\n\t*result = '\\0';\n\n\tif (fmt_len > DCH_CACHE_SIZE)\n\t{\n\t\t/*\n\t\t * Allocate new memory if format picture is bigger than static cache\n\t\t * and do not use cache (call parser always)\n\t\t */\n\t\tincache = false;\n\n\t\tformat = (FormatNode *) palloc((fmt_len + 1) * sizeof(FormatNode));\n\n\t\tparse_format(format, fmt_str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Use cache buffers\n\t\t */\n\t\tDCHCacheEntry *ent = DCH_cache_fetch(fmt_str);\n\n\t\tincache = true;\n\t\tformat = ent->format;\n\t}\n\n\t/* The real work is here */\n\tDCH_to_char(format, is_interval, tmtc, result, collid);\n\n\tif (!incache)\n\t\tpfree(format);\n\n\tpfree(fmt_str);\n\n\t/* convert C-string result to TEXT format */\n\tres = cstring_to_text(result);\n\n\tpfree(result);\n\treturn res;\n}"
  },
  {
    "function_name": "DCH_cache_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3357-3377",
    "snippet": "static DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/"
    ],
    "globals_used": [
      "static const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};",
      "static const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};",
      "static const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_format",
          "args": [
            "ent->format",
            "str",
            "DCH_keywords",
            "DCH_suff",
            "DCH_index",
            "DCH_TYPE",
            "NULL"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1225-1334",
          "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SUFFTYPE_POSTFIX\t2",
            "#define SUFFTYPE_PREFIX\t\t1",
            "#define NODE_TYPE_CHAR\t\t3",
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1",
            "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
            "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DCH_cache_getnew",
          "args": [
            "str"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_cache_getnew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3267-3326",
          "snippet": "static DCHCacheEntry *\nDCH_cache_getnew(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_DCHCache >= DCH_CACHE_ENTRIES)\n\t{\n\t\tDCHCacheEntry *old = DCHCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"cache is full (%d)\", n_DCHCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = DCHCache + 1; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: '%s' AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, DCH_CACHE_SIZE + 1);\n\t\told->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_DCHCache);\n#endif\n\t\tent = DCHCache + n_DCHCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, DCH_CACHE_SIZE + 1);\n\t\tent->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\t++n_DCHCache;\n\t\treturn ent;\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_ENTRIES\t20",
            "#define DCH_CACHE_SIZE\t\t128",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];",
            "static int\tn_DCHCache = 0;",
            "static int\tDCHCounter = 0;",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_ENTRIES\t20\n#define DCH_CACHE_SIZE\t\t128\n#define DEBUG_elog_output\tDEBUG3\n\nstatic DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];\nstatic int\tn_DCHCache = 0;\nstatic int\tDCHCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_getnew(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_DCHCache >= DCH_CACHE_ENTRIES)\n\t{\n\t\tDCHCacheEntry *old = DCHCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"cache is full (%d)\", n_DCHCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = DCHCache + 1; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: '%s' AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, DCH_CACHE_SIZE + 1);\n\t\told->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_DCHCache);\n#endif\n\t\tent = DCHCache + n_DCHCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, DCH_CACHE_SIZE + 1);\n\t\tent->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\t++n_DCHCache;\n\t\treturn ent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DCH_cache_search",
          "args": [
            "str"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "DCH_cache_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "3329-3354",
          "snippet": "static DCHCacheEntry *\nDCH_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\tfor (i = 0, ent = DCHCache; i < n_DCHCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++DCHCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_CACHE_ENTRIES\t20"
          ],
          "globals_used": [
            "static DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];",
            "static int\tn_DCHCache = 0;",
            "static int\tDCHCounter = 0;",
            "static int\tstrspace_len(char *str);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_ENTRIES\t20\n\nstatic DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];\nstatic int\tn_DCHCache = 0;\nstatic int\tDCHCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\tfor (i = 0, ent = DCHCache; i < n_DCHCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++DCHCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n\nstatic const KeySuffix DCH_suff[] = {\n\t{\"FM\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"fm\", 2, DCH_S_FM, SUFFTYPE_PREFIX},\n\t{\"TM\", TM_SUFFIX_LEN, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"tm\", 2, DCH_S_TM, SUFFTYPE_PREFIX},\n\t{\"TH\", 2, DCH_S_TH, SUFFTYPE_POSTFIX},\n\t{\"th\", 2, DCH_S_th, SUFFTYPE_POSTFIX},\n\t{\"SP\", 2, DCH_S_SP, SUFFTYPE_POSTFIX},\n\t/* last */\n\t{NULL, 0, 0, 0}\n};\nstatic const KeyWord DCH_keywords[] = {\n/*\tname, len, id, is_digit, date_mode */\n\t{\"A.D.\", 4, DCH_A_D, false, FROM_CHAR_DATE_NONE},\t/* A */\n\t{\"A.M.\", 4, DCH_A_M, false, FROM_CHAR_DATE_NONE},\n\t{\"AD\", 2, DCH_AD, false, FROM_CHAR_DATE_NONE},\n\t{\"AM\", 2, DCH_AM, false, FROM_CHAR_DATE_NONE},\n\t{\"B.C.\", 4, DCH_B_C, false, FROM_CHAR_DATE_NONE},\t/* B */\n\t{\"BC\", 2, DCH_BC, false, FROM_CHAR_DATE_NONE},\n\t{\"CC\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* C */\n\t{\"DAY\", 3, DCH_DAY, false, FROM_CHAR_DATE_NONE},\t/* D */\n\t{\"DDD\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DD\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"DY\", 2, DCH_DY, false, FROM_CHAR_DATE_NONE},\n\t{\"Day\", 3, DCH_Day, false, FROM_CHAR_DATE_NONE},\n\t{\"Dy\", 2, DCH_Dy, false, FROM_CHAR_DATE_NONE},\n\t{\"D\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"FX\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* F */\n\t{\"HH24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* H */\n\t{\"HH12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"HH\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"IDDD\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* I */\n\t{\"ID\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IW\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYYY\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IYY\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"IY\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"I\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"J\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* J */\n\t{\"MI\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* M */\n\t{\"MM\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MONTH\", 5, DCH_MONTH, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MON\", 3, DCH_MON, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"MS\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"Month\", 5, DCH_Month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Mon\", 3, DCH_Mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"OF\", 2, DCH_OF, false, FROM_CHAR_DATE_NONE},\t/* O */\n\t{\"P.M.\", 4, DCH_P_M, false, FROM_CHAR_DATE_NONE},\t/* P */\n\t{\"PM\", 2, DCH_PM, false, FROM_CHAR_DATE_NONE},\n\t{\"Q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* Q */\n\t{\"RM\", 2, DCH_RM, false, FROM_CHAR_DATE_GREGORIAN}, /* R */\n\t{\"SSSS\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* S */\n\t{\"SS\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"TZH\", 3, DCH_TZH, false, FROM_CHAR_DATE_NONE},\t/* T */\n\t{\"TZM\", 3, DCH_TZM, true, FROM_CHAR_DATE_NONE},\n\t{\"TZ\", 2, DCH_TZ, false, FROM_CHAR_DATE_NONE},\n\t{\"US\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* U */\n\t{\"WW\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* W */\n\t{\"W\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y,YYY\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* Y */\n\t{\"YYYY\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YYY\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"YY\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"Y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"a.d.\", 4, DCH_a_d, false, FROM_CHAR_DATE_NONE},\t/* a */\n\t{\"a.m.\", 4, DCH_a_m, false, FROM_CHAR_DATE_NONE},\n\t{\"ad\", 2, DCH_ad, false, FROM_CHAR_DATE_NONE},\n\t{\"am\", 2, DCH_am, false, FROM_CHAR_DATE_NONE},\n\t{\"b.c.\", 4, DCH_b_c, false, FROM_CHAR_DATE_NONE},\t/* b */\n\t{\"bc\", 2, DCH_bc, false, FROM_CHAR_DATE_NONE},\n\t{\"cc\", 2, DCH_CC, true, FROM_CHAR_DATE_NONE},\t/* c */\n\t{\"day\", 3, DCH_day, false, FROM_CHAR_DATE_NONE},\t/* d */\n\t{\"ddd\", 3, DCH_DDD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dd\", 2, DCH_DD, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"dy\", 2, DCH_dy, false, FROM_CHAR_DATE_NONE},\n\t{\"d\", 1, DCH_D, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"fx\", 2, DCH_FX, false, FROM_CHAR_DATE_NONE},\t/* f */\n\t{\"hh24\", 4, DCH_HH24, true, FROM_CHAR_DATE_NONE},\t/* h */\n\t{\"hh12\", 4, DCH_HH12, true, FROM_CHAR_DATE_NONE},\n\t{\"hh\", 2, DCH_HH, true, FROM_CHAR_DATE_NONE},\n\t{\"iddd\", 4, DCH_IDDD, true, FROM_CHAR_DATE_ISOWEEK},\t/* i */\n\t{\"id\", 2, DCH_ID, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iw\", 2, DCH_IW, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyyy\", 4, DCH_IYYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iyy\", 3, DCH_IYY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"iy\", 2, DCH_IY, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"i\", 1, DCH_I, true, FROM_CHAR_DATE_ISOWEEK},\n\t{\"j\", 1, DCH_J, true, FROM_CHAR_DATE_NONE}, /* j */\n\t{\"mi\", 2, DCH_MI, true, FROM_CHAR_DATE_NONE},\t/* m */\n\t{\"mm\", 2, DCH_MM, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"month\", 5, DCH_month, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"mon\", 3, DCH_mon, false, FROM_CHAR_DATE_GREGORIAN},\n\t{\"ms\", 2, DCH_MS, true, FROM_CHAR_DATE_NONE},\n\t{\"p.m.\", 4, DCH_p_m, false, FROM_CHAR_DATE_NONE},\t/* p */\n\t{\"pm\", 2, DCH_pm, false, FROM_CHAR_DATE_NONE},\n\t{\"q\", 1, DCH_Q, true, FROM_CHAR_DATE_NONE}, /* q */\n\t{\"rm\", 2, DCH_rm, false, FROM_CHAR_DATE_GREGORIAN}, /* r */\n\t{\"ssss\", 4, DCH_SSSS, true, FROM_CHAR_DATE_NONE},\t/* s */\n\t{\"ss\", 2, DCH_SS, true, FROM_CHAR_DATE_NONE},\n\t{\"tz\", 2, DCH_tz, false, FROM_CHAR_DATE_NONE},\t/* t */\n\t{\"us\", 2, DCH_US, true, FROM_CHAR_DATE_NONE},\t/* u */\n\t{\"ww\", 2, DCH_WW, true, FROM_CHAR_DATE_GREGORIAN},\t/* w */\n\t{\"w\", 1, DCH_W, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y,yyy\", 5, DCH_Y_YYY, true, FROM_CHAR_DATE_GREGORIAN},\t/* y */\n\t{\"yyyy\", 4, DCH_YYYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yyy\", 3, DCH_YYY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"yy\", 2, DCH_YY, true, FROM_CHAR_DATE_GREGORIAN},\n\t{\"y\", 1, DCH_Y, true, FROM_CHAR_DATE_GREGORIAN},\n\n\t/* last */\n\t{NULL, 0, 0, 0, 0}\n};\nstatic const int DCH_index[KeyWord_INDEX_SIZE] = {\n/*\n0\t1\t2\t3\t4\t5\t6\t7\t8\t9\n*/\n\t/*---- first 0..31 chars are skipped ----*/\n\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, DCH_A_D, DCH_B_C, DCH_CC, DCH_DAY, -1,\n\tDCH_FX, -1, DCH_HH24, DCH_IDDD, DCH_J, -1, -1, DCH_MI, -1, DCH_OF,\n\tDCH_P_M, DCH_Q, DCH_RM, DCH_SSSS, DCH_TZH, DCH_US, -1, DCH_WW, -1, DCH_Y_YYY,\n\t-1, -1, -1, -1, -1, -1, -1, DCH_a_d, DCH_b_c, DCH_cc,\n\tDCH_day, -1, DCH_fx, -1, DCH_hh24, DCH_iddd, DCH_j, -1, -1, DCH_mi,\n\t-1, -1, DCH_p_m, DCH_q, DCH_rm, DCH_ssss, DCH_tz, DCH_us, -1, DCH_ww,\n\t-1, DCH_y_yyy, -1, -1, -1, -1\n\n\t/*---- chars over 126 are skipped ----*/\n};\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_fetch(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\tif ((ent = DCH_cache_search(str)) == NULL)\n\t{\n\t\t/*\n\t\t * Not in the cache, must run parser and save a new format-picture to\n\t\t * the cache.  Do not mark the cache entry valid until parsing\n\t\t * succeeds.\n\t\t */\n\t\tent = DCH_cache_getnew(str);\n\n\t\tparse_format(ent->format, str, DCH_keywords,\n\t\t\t\t\t DCH_suff, DCH_index, DCH_TYPE, NULL);\n\n\t\tent->valid = true;\n\t}\n\treturn ent;\n}"
  },
  {
    "function_name": "DCH_cache_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3329-3354",
    "snippet": "static DCHCacheEntry *\nDCH_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\tfor (i = 0, ent = DCHCache; i < n_DCHCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++DCHCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_CACHE_ENTRIES\t20"
    ],
    "globals_used": [
      "static DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];",
      "static int\tn_DCHCache = 0;",
      "static int\tDCHCounter = 0;",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ent->str",
            "str"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_ENTRIES\t20\n\nstatic DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];\nstatic int\tn_DCHCache = 0;\nstatic int\tDCHCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_search(const char *str)\n{\n\tint\t\t\ti;\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\tfor (i = 0, ent = DCHCache; i < n_DCHCache; i++, ent++)\n\t{\n\t\tif (ent->valid && strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++DCHCounter);\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "DCH_cache_getnew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "3267-3326",
    "snippet": "static DCHCacheEntry *\nDCH_cache_getnew(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_DCHCache >= DCH_CACHE_ENTRIES)\n\t{\n\t\tDCHCacheEntry *old = DCHCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"cache is full (%d)\", n_DCHCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = DCHCache + 1; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: '%s' AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, DCH_CACHE_SIZE + 1);\n\t\told->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_DCHCache);\n#endif\n\t\tent = DCHCache + n_DCHCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, DCH_CACHE_SIZE + 1);\n\t\tent->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\t++n_DCHCache;\n\t\treturn ent;\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_CACHE_ENTRIES\t20",
      "#define DCH_CACHE_SIZE\t\t128",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];",
      "static int\tn_DCHCache = 0;",
      "static int\tDCHCounter = 0;",
      "static int\tstrspace_len(char *str);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "StrNCpy",
          "args": [
            "ent->str",
            "str",
            "DCH_CACHE_SIZE + 1"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"NEW (%d)\"",
            "n_DCHCache"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StrNCpy",
          "args": [
            "old->str",
            "str",
            "DCH_CACHE_SIZE + 1"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_CACHE_ENTRIES\t20\n#define DCH_CACHE_SIZE\t\t128\n#define DEBUG_elog_output\tDEBUG3\n\nstatic DCHCacheEntry DCHCache[DCH_CACHE_ENTRIES];\nstatic int\tn_DCHCache = 0;\nstatic int\tDCHCounter = 0;\nstatic int\tstrspace_len(char *str);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic DCHCacheEntry *\nDCH_cache_getnew(const char *str)\n{\n\tDCHCacheEntry *ent;\n\n\t/* counter overflow check - paranoia? */\n\tif (DCHCounter >= (INT_MAX - DCH_CACHE_ENTRIES))\n\t{\n\t\tDCHCounter = 0;\n\n\t\tfor (ent = DCHCache; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\tent->age = (++DCHCounter);\n\t}\n\n\t/*\n\t * If cache is full, remove oldest entry (or recycle first not-valid one)\n\t */\n\tif (n_DCHCache >= DCH_CACHE_ENTRIES)\n\t{\n\t\tDCHCacheEntry *old = DCHCache + 0;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"cache is full (%d)\", n_DCHCache);\n#endif\n\t\tif (old->valid)\n\t\t{\n\t\t\tfor (ent = DCHCache + 1; ent < (DCHCache + DCH_CACHE_ENTRIES); ent++)\n\t\t\t{\n\t\t\t\tif (!ent->valid)\n\t\t\t\t{\n\t\t\t\t\told = ent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ent->age < old->age)\n\t\t\t\t\told = ent;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"OLD: '%s' AGE: %d\", old->str, old->age);\n#endif\n\t\told->valid = false;\n\t\tStrNCpy(old->str, str, DCH_CACHE_SIZE + 1);\n\t\told->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\treturn old;\n\t}\n\telse\n\t{\n#ifdef DEBUG_TO_FROM_CHAR\n\t\telog(DEBUG_elog_output, \"NEW (%d)\", n_DCHCache);\n#endif\n\t\tent = DCHCache + n_DCHCache;\n\t\tent->valid = false;\n\t\tStrNCpy(ent->str, str, DCH_CACHE_SIZE + 1);\n\t\tent->age = (++DCHCounter);\n\t\t/* caller is expected to fill format, then set valid */\n\t\t++n_DCHCache;\n\t\treturn ent;\n\t}\n}"
  },
  {
    "function_name": "DCH_from_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2981-3264",
    "snippet": "static void\nDCH_from_char(FormatNode *node, char *in, TmFromChar *out)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tint\t\t\tlen,\n\t\t\t\tvalue;\n\tbool\t\tfx_mode = false;\n\n\tfor (n = node, s = in; n->type != NODE_TYPE_END && *s != '\\0'; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Separator, so consume one character from input string.  Notice\n\t\t\t * we don't insist that the consumed character match the format's\n\t\t\t * character.\n\t\t\t */\n\t\t\ts += pg_mblen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore spaces before fields when not in FX (fixed width) mode */\n\t\tif (!fx_mode && n->key->id != DCH_FX)\n\t\t{\n\t\t\twhile (*s != '\\0' && isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\n\t\tfrom_char_set_mode(out, n->key->date_mode);\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_FX:\n\t\t\t\tfx_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tfrom_char_parse_int(&out->mi, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tfrom_char_parse_int(&out->ss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->ms, &s, 3, n);\n\n\t\t\t\t/*\n\t\t\t\t * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25\n\t\t\t\t */\n\t\t\t\tout->ms *= len == 1 ? 100 :\n\t\t\t\t\tlen == 2 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->us, &s, 6, n);\n\n\t\t\t\tout->us *= len == 1 ? 100000 :\n\t\t\t\t\tlen == 2 ? 10000 :\n\t\t\t\t\tlen == 3 ? 1000 :\n\t\t\t\t\tlen == 4 ? 100 :\n\t\t\t\t\tlen == 5 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tfrom_char_parse_int(&out->ssss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\tcase DCH_TZ:\n\t\t\tcase DCH_OF:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"formatting field \\\"%s\\\" is only supported in to_char\",\n\t\t\t\t\t\t\t\tn->key->name)));\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tout->tzsign = *s == '-' ? -1 : +1;\n\n\t\t\t\tif (*s == '+' || *s == '-' || *s == ' ')\n\t\t\t\t\ts++;\n\n\t\t\t\tfrom_char_parse_int_len(&out->tzh, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\t/* assign positive timezone sign if TZH was not seen before */\n\t\t\t\tif (!out->tzsign)\n\t\t\t\t\tout->tzsign = +1;\n\t\t\t\tfrom_char_parse_int_len(&out->tzm, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\tcase DCH_Month:\n\t\t\tcase DCH_month:\n\t\t\t\tfrom_char_seq_search(&value, &s, months_full, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MONTH_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\tcase DCH_Mon:\n\t\t\tcase DCH_mon:\n\t\t\t\tfrom_char_seq_search(&value, &s, months, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MON_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tfrom_char_parse_int(&out->mm, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\tcase DCH_Day:\n\t\t\tcase DCH_day:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DAY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\tcase DCH_Dy:\n\t\t\tcase DCH_dy:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\t\tfrom_char_parse_int(&out->ddd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IDDD:\n\t\t\t\tfrom_char_parse_int_len(&out->ddd, &s, 3, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tfrom_char_parse_int(&out->dd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tfrom_char_parse_int(&out->d, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tfrom_char_parse_int_len(&out->d, &s, 1, n);\n\t\t\t\t/* Shift numbering to match Gregorian where Sunday = 1 */\n\t\t\t\tif (++out->d > 7)\n\t\t\t\t\tout->d = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\tcase DCH_IW:\n\t\t\t\tfrom_char_parse_int(&out->ww, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\n\t\t\t\t/*\n\t\t\t\t * We ignore 'Q' when converting to date because it is unclear\n\t\t\t\t * which date in the quarter to use, and some people specify\n\t\t\t\t * both quarter and month, so if it was honored it might\n\t\t\t\t * conflict with the supplied month. That is also why we don't\n\t\t\t\t * throw an error.\n\t\t\t\t *\n\t\t\t\t * We still parse the source string for an integer, but it\n\t\t\t\t * isn't stored anywhere in 'out'.\n\t\t\t\t */\n\t\t\t\tfrom_char_parse_int((int *) NULL, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tfrom_char_parse_int(&out->cc, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched,\n\t\t\t\t\t\t\t\tyears,\n\t\t\t\t\t\t\t\tmillennia,\n\t\t\t\t\t\t\t\tnch;\n\n\t\t\t\t\tmatched = sscanf(s, \"%d,%03d%n\", &millennia, &years, &nch);\n\t\t\t\t\tif (matched < 2)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input string for \\\"Y,YYY\\\"\")));\n\t\t\t\t\tyears += (millennia * 1000);\n\t\t\t\t\tfrom_char_set_int(&out->year, years, n);\n\t\t\t\t\tout->yysz = 4;\n\t\t\t\t\ts += nch;\n\t\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tfrom_char_parse_int(&out->year, &s, n);\n\t\t\t\tout->yysz = 4;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 3;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 2;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_upper,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_lower,\n\t\t\t\t\t\t\t\t\t ALL_LOWER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tfrom_char_parse_int(&out->w, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tfrom_char_parse_int(&out->j, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RM_LEN\t\t4",
      "#define MAX_DY_LEN\t\t3",
      "#define MAX_DAY_LEN\t\t9",
      "#define MAX_MON_LEN\t\t3",
      "#define MAX_MONTH_LEN\t9",
      "#define ALL_LOWER\t\t3\t\t/* name */",
      "#define ALL_UPPER\t\t2\t\t/* NAME */",
      "#define ONE_UPPER\t\t1\t\t/* Name */",
      "#define CLOCK_12_HOUR\t\t1",
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1"
    ],
    "globals_used": [
      "static const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};",
      "static const char *const adbc_strings[] = {ad_STR, bc_STR, AD_STR, BC_STR, NULL};",
      "static const char *const adbc_strings_long[] = {a_d_STR, b_c_STR, A_D_STR, B_C_STR, NULL};",
      "static const char *const ampm_strings[] = {am_STR, pm_STR, AM_STR, PM_STR, NULL};",
      "static const char *const ampm_strings_long[] = {a_m_STR, p_m_STR, A_M_STR, P_M_STR, NULL};",
      "static const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};",
      "static const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};",
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tadjust_partial_year_to_2020(int year);",
      "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_char_parse_int",
          "args": [
            "&out->j",
            "&s",
            "n"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_parse_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2283-2287",
          "snippet": "static int\nfrom_char_parse_int(int *dest, char **src, FormatNode *node)\n{\n\treturn from_char_parse_int_len(dest, src, node->key->len, node);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic int\nfrom_char_parse_int(int *dest, char **src, FormatNode *node)\n{\n\treturn from_char_parse_int_len(dest, src, node->key->len, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_char_set_int",
          "args": [
            "&out->mm",
            "MONTHS_PER_YEAR - value",
            "n"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_set_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2160-2171",
          "snippet": "static void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_char_seq_search",
          "args": [
            "&value",
            "&s",
            "rm_months_lower",
            "ALL_LOWER",
            "MAX_RM_LEN",
            "n"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2371-2394",
          "snippet": "static int\nfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max,\n\t\t\t\t\t FormatNode *node)\n{\n\tint\t\t\tlen;\n\n\t*dest = seq_search(*src, array, type, max, &len);\n\tif (len <= 0)\n\t{\n\t\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\n\t\tAssert(max <= DCH_MAX_ITEM_SIZ);\n\t\tstrlcpy(copy, *src, max + 1);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\")));\n\t}\n\t*src += len;\n\treturn len;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
          ],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *fill_str(char *str, int c, int max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *fill_str(char *str, int c, int max);\n\nstatic int\nfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max,\n\t\t\t\t\t FormatNode *node)\n{\n\tint\t\t\tlen;\n\n\t*dest = seq_search(*src, array, type, max, &len);\n\tif (len <= 0)\n\t{\n\t\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\n\t\tAssert(max <= DCH_MAX_ITEM_SIZ);\n\t\tstrlcpy(copy, *src, max + 1);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\")));\n\t}\n\t*src += len;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_partial_year_to_2020",
          "args": [
            "out->year"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_partial_year_to_2020",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2095-2116",
          "snippet": "static int\nadjust_partial_year_to_2020(int year)\n{\n\t/*\n\t * Adjust all dates toward 2020; this is effectively what happens when we\n\t * assume '70' is 1970 and '69' is 2069.\n\t */\n\t/* Force 0-69 into the 2000's */\n\tif (year < 70)\n\t\treturn year + 2000;\n\t/* Force 70-99 into the 1900's */\n\telse if (year < 100)\n\t\treturn year + 1900;\n\t/* Force 100-519 into the 2000's */\n\telse if (year < 520)\n\t\treturn year + 2000;\n\t/* Force 520-999 into the 1000's */\n\telse if (year < 1000)\n\t\treturn year + 1000;\n\telse\n\t\treturn year;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tadjust_partial_year_to_2020(int year);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tadjust_partial_year_to_2020(int year);\n\nstatic int\nadjust_partial_year_to_2020(int year)\n{\n\t/*\n\t * Adjust all dates toward 2020; this is effectively what happens when we\n\t * assume '70' is 1970 and '69' is 2069.\n\t */\n\t/* Force 0-69 into the 2000's */\n\tif (year < 70)\n\t\treturn year + 2000;\n\t/* Force 70-99 into the 1900's */\n\telse if (year < 100)\n\t\treturn year + 1900;\n\t/* Force 100-519 into the 2000's */\n\telse if (year < 520)\n\t\treturn year + 2000;\n\t/* Force 520-999 into the 1000's */\n\telse if (year < 1000)\n\t\treturn year + 1000;\n\telse\n\t\treturn year;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input string for \\\"Y,YYY\\\"\"))"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input string for \\\"Y,YYY\\\"\""
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%d,%03d%n\"",
            "&millennia",
            "&years",
            "&nch"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_char_parse_int_len",
          "args": [
            "&out->d",
            "&s",
            "1",
            "n"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_parse_int_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2193-2272",
          "snippet": "static int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
          ],
          "globals_used": [
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\n\nstatic int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"formatting field \\\"%s\\\" is only supported in to_char\",\n\t\t\t\t\t\t\t\tn->key->name))"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SKIP_THth",
          "args": [
            "s",
            "n->suffix"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_char_set_mode",
          "args": [
            "out",
            "n->key->date_mode"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_set_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2138-2152",
          "snippet": "static void\nfrom_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode)\n{\n\tif (mode != FROM_CHAR_DATE_NONE)\n\t{\n\t\tif (tmfc->mode == FROM_CHAR_DATE_NONE)\n\t\t\ttmfc->mode = mode;\n\t\telse if (tmfc->mode != mode)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid combination of date conventions\"),\n\t\t\t\t\t errhint(\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\")));\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\n\nstatic void\nfrom_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode)\n{\n\tif (mode != FROM_CHAR_DATE_NONE)\n\t{\n\t\tif (tmfc->mode == FROM_CHAR_DATE_NONE)\n\t\t\ttmfc->mode = mode;\n\t\telse if (tmfc->mode != mode)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid combination of date conventions\"),\n\t\t\t\t\t errhint(\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\")));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *s"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "s"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_RM_LEN\t\t4\n#define MAX_DY_LEN\t\t3\n#define MAX_DAY_LEN\t\t9\n#define MAX_MON_LEN\t\t3\n#define MAX_MONTH_LEN\t9\n#define ALL_LOWER\t\t3\t\t/* name */\n#define ALL_UPPER\t\t2\t\t/* NAME */\n#define ONE_UPPER\t\t1\t\t/* Name */\n#define CLOCK_12_HOUR\t\t1\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n\nstatic const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};\nstatic const char *const adbc_strings[] = {ad_STR, bc_STR, AD_STR, BC_STR, NULL};\nstatic const char *const adbc_strings_long[] = {a_d_STR, b_c_STR, A_D_STR, B_C_STR, NULL};\nstatic const char *const ampm_strings[] = {am_STR, pm_STR, AM_STR, PM_STR, NULL};\nstatic const char *const ampm_strings_long[] = {a_m_STR, p_m_STR, A_M_STR, P_M_STR, NULL};\nstatic const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};\nstatic const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tadjust_partial_year_to_2020(int year);\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nDCH_from_char(FormatNode *node, char *in, TmFromChar *out)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tint\t\t\tlen,\n\t\t\t\tvalue;\n\tbool\t\tfx_mode = false;\n\n\tfor (n = node, s = in; n->type != NODE_TYPE_END && *s != '\\0'; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\t/*\n\t\t\t * Separator, so consume one character from input string.  Notice\n\t\t\t * we don't insist that the consumed character match the format's\n\t\t\t * character.\n\t\t\t */\n\t\t\ts += pg_mblen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore spaces before fields when not in FX (fixed width) mode */\n\t\tif (!fx_mode && n->key->id != DCH_FX)\n\t\t{\n\t\t\twhile (*s != '\\0' && isspace((unsigned char) *s))\n\t\t\t\ts++;\n\t\t}\n\n\t\tfrom_char_set_mode(out, n->key->date_mode);\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_FX:\n\t\t\t\tfx_mode = true;\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tfrom_char_seq_search(&value, &s, ampm_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->pm, value % 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tout->clock = CLOCK_12_HOUR;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tfrom_char_parse_int_len(&out->hh, &s, 2, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tfrom_char_parse_int(&out->mi, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tfrom_char_parse_int(&out->ss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->ms, &s, 3, n);\n\n\t\t\t\t/*\n\t\t\t\t * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25\n\t\t\t\t */\n\t\t\t\tout->ms *= len == 1 ? 100 :\n\t\t\t\t\tlen == 2 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tlen = from_char_parse_int_len(&out->us, &s, 6, n);\n\n\t\t\t\tout->us *= len == 1 ? 100000 :\n\t\t\t\t\tlen == 2 ? 10000 :\n\t\t\t\t\tlen == 3 ? 1000 :\n\t\t\t\t\tlen == 4 ? 100 :\n\t\t\t\t\tlen == 5 ? 10 : 1;\n\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tfrom_char_parse_int(&out->ssss, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\tcase DCH_TZ:\n\t\t\tcase DCH_OF:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"formatting field \\\"%s\\\" is only supported in to_char\",\n\t\t\t\t\t\t\t\tn->key->name)));\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tout->tzsign = *s == '-' ? -1 : +1;\n\n\t\t\t\tif (*s == '+' || *s == '-' || *s == ' ')\n\t\t\t\t\ts++;\n\n\t\t\t\tfrom_char_parse_int_len(&out->tzh, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\t/* assign positive timezone sign if TZH was not seen before */\n\t\t\t\tif (!out->tzsign)\n\t\t\t\t\tout->tzsign = +1;\n\t\t\t\tfrom_char_parse_int_len(&out->tzm, &s, 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings_long,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tfrom_char_seq_search(&value, &s, adbc_strings,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, n->key->len, n);\n\t\t\t\tfrom_char_set_int(&out->bc, value % 2, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\tcase DCH_Month:\n\t\t\tcase DCH_month:\n\t\t\t\tfrom_char_seq_search(&value, &s, months_full, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MONTH_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\tcase DCH_Mon:\n\t\t\tcase DCH_mon:\n\t\t\t\tfrom_char_seq_search(&value, &s, months, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_MON_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, value + 1, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tfrom_char_parse_int(&out->mm, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\tcase DCH_Day:\n\t\t\tcase DCH_day:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DAY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\tcase DCH_Dy:\n\t\t\tcase DCH_dy:\n\t\t\t\tfrom_char_seq_search(&value, &s, days, ONE_UPPER,\n\t\t\t\t\t\t\t\t\t MAX_DY_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->d, value, n);\n\t\t\t\tout->d++;\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\t\tfrom_char_parse_int(&out->ddd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IDDD:\n\t\t\t\tfrom_char_parse_int_len(&out->ddd, &s, 3, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tfrom_char_parse_int(&out->dd, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tfrom_char_parse_int(&out->d, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tfrom_char_parse_int_len(&out->d, &s, 1, n);\n\t\t\t\t/* Shift numbering to match Gregorian where Sunday = 1 */\n\t\t\t\tif (++out->d > 7)\n\t\t\t\t\tout->d = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\tcase DCH_IW:\n\t\t\t\tfrom_char_parse_int(&out->ww, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\n\t\t\t\t/*\n\t\t\t\t * We ignore 'Q' when converting to date because it is unclear\n\t\t\t\t * which date in the quarter to use, and some people specify\n\t\t\t\t * both quarter and month, so if it was honored it might\n\t\t\t\t * conflict with the supplied month. That is also why we don't\n\t\t\t\t * throw an error.\n\t\t\t\t *\n\t\t\t\t * We still parse the source string for an integer, but it\n\t\t\t\t * isn't stored anywhere in 'out'.\n\t\t\t\t */\n\t\t\t\tfrom_char_parse_int((int *) NULL, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tfrom_char_parse_int(&out->cc, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched,\n\t\t\t\t\t\t\t\tyears,\n\t\t\t\t\t\t\t\tmillennia,\n\t\t\t\t\t\t\t\tnch;\n\n\t\t\t\t\tmatched = sscanf(s, \"%d,%03d%n\", &millennia, &years, &nch);\n\t\t\t\t\tif (matched < 2)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input string for \\\"Y,YYY\\\"\")));\n\t\t\t\t\tyears += (millennia * 1000);\n\t\t\t\t\tfrom_char_set_int(&out->year, years, n);\n\t\t\t\t\tout->yysz = 4;\n\t\t\t\t\ts += nch;\n\t\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tfrom_char_parse_int(&out->year, &s, n);\n\t\t\t\tout->yysz = 4;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 3;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 2;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tif (from_char_parse_int(&out->year, &s, n) < 4)\n\t\t\t\t\tout->year = adjust_partial_year_to_2020(out->year);\n\t\t\t\tout->yysz = 1;\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_upper,\n\t\t\t\t\t\t\t\t\t ALL_UPPER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tfrom_char_seq_search(&value, &s, rm_months_lower,\n\t\t\t\t\t\t\t\t\t ALL_LOWER, MAX_RM_LEN, n);\n\t\t\t\tfrom_char_set_int(&out->mm, MONTHS_PER_YEAR - value, n);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tfrom_char_parse_int(&out->w, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tfrom_char_parse_int(&out->j, &s, n);\n\t\t\t\tSKIP_THth(s, n->suffix);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "DCH_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2401-2971",
    "snippet": "static void\nDCH_to_char(FormatNode *node, bool is_interval, TmToChar *in, char *out, Oid collid)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tstruct pg_tm *tm = &in->tm;\n\tint\t\t\ti;\n\n\t/* cache localized days and months */\n\tcache_locale_time();\n\n\ts = out;\n\tfor (n = node; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\tstrcpy(s, n->character);\n\t\t\ts += strlen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? P_M_STR : A_M_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? PM_STR : AM_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? p_m_STR : a_m_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? pm_STR : am_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\n\t\t\t\t/*\n\t\t\t\t * display time as shown on a 12-hour clock, even for\n\t\t\t\t * intervals\n\t\t\t\t */\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 :\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_min >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_min);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_sec >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tsprintf(s, \"%03d\", (int) (in->fsec / INT64CONST(1000)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tsprintf(s, \"%06d\", (int) in->fsec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tsprintf(s, \"%d\", tm->tm_hour * SECS_PER_HOUR +\n\t\t\t\t\t\ttm->tm_min * SECS_PER_MINUTE +\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\t/* We assume here that timezone names aren't localized */\n\t\t\t\t\tchar\t   *p = asc_tolower_z(tmtcTzn(in));\n\n\t\t\t\t\tstrcpy(s, p);\n\t\t\t\t\tpfree(p);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZ:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, tmtcTzn(in));\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%02d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%02d\",\n\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_OF:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%0*d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tif (abs((int) tm->tm_gmtoff) % SECS_PER_HOUR != 0)\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \":%02d\",\n\t\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? B_C_STR : A_D_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? BC_STR : AD_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? b_c_STR : a_d_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? bc_STR : ad_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tmonths_full[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, months[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_mon >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_mon);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tdays[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, days_short[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\tcase DCH_IDDD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_DDD) ?\n\t\t\t\t\t\ttm->tm_yday :\n\t\t\t\t\t\tdate2isoyearday(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2, tm->tm_mday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", tm->tm_wday + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_wday == 0) ? 7 : tm->tm_wday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\t(tm->tm_yday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tdate2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mon - 1) / 3 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tif (is_interval)\t/* straight calculation */\n\t\t\t\t\ti = tm->tm_year / 100;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\t/* Century 20 == 1901 - 2000 */\n\t\t\t\t\t\ti = (tm->tm_year - 1) / 100 + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Century 6BC == 600BC - 501BC */\n\t\t\t\t\t\ti = tm->tm_year / 100 - 1;\n\t\t\t\t}\n\t\t\t\tif (i <= 99 && i >= -99)\n\t\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (i >= 0) ? 2 : 3, i);\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%d\", i);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\ti = ADJUST_YEAR(tm->tm_year, is_interval) / 1000;\n\t\t\t\tsprintf(s, \"%d,%03d\", i,\n\t\t\t\t\t\tADJUST_YEAR(tm->tm_year, is_interval) - (i * 1000));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 4 : 5,\n\t\t\t\t\t\t(n->key->id == DCH_YYYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 3 : 4,\n\t\t\t\t\t\t(n->key->id == DCH_YYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 1000);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 2 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_YY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 100);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tsprintf(s, \"%1d\",\n\t\t\t\t\t\t(n->key->id == DCH_Y ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 10);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_upper[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_lower[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tsprintf(s, \"%d\", date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*s = '\\0';\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TM_SUFFIX_LEN\t2",
      "#define INVALID_FOR_INTERVAL  \\\ndo { \\\n\tif (is_interval) \\\n\t\tereport(ERROR, \\\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT), \\\n\t\t\t\t errmsg(\"invalid format specification for an interval value\"), \\\n\t\t\t\t errhint(\"Intervals are not tied to specific calendar dates.\"))); \\\n} while(0)",
      "#define pm_STR\t\t\"pm\"",
      "#define PM_STR\t\t\"PM\"",
      "#define p_m_STR\t\t\"p.m.\"",
      "#define P_M_STR\t\t\"P.M.\"",
      "#define am_STR\t\t\"am\"",
      "#define AM_STR\t\t\"AM\"",
      "#define a_m_STR\t\t\"a.m.\"",
      "#define A_M_STR\t\t\"A.M.\"",
      "#define bc_STR\t\t\"bc\"",
      "#define BC_STR\t\t\"BC\"",
      "#define b_c_STR\t\t\"b.c.\"",
      "#define B_C_STR\t\t\"B.C.\"",
      "#define ad_STR\t\t\"ad\"",
      "#define AD_STR\t\t\"AD\"",
      "#define a_d_STR\t\t\"a.d.\"",
      "#define A_D_STR\t\t\"A.D.\"",
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1",
      "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
    ],
    "globals_used": [
      "static const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};",
      "static const char *const days_short[] = {\n\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", NULL\n};",
      "static const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};",
      "static const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};",
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tstrspace_len(char *str);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_numth",
          "args": [
            "s",
            "s",
            "S_TH_TYPE(n->suffix)"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "str_numth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1427-1434",
          "snippet": "static char *\nstr_numth(char *dest, char *num, int type)\n{\n\tif (dest != num)\n\t\tstrcpy(dest, num);\n\tstrcat(dest, get_th(num, type));\n\treturn dest;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nstr_numth(char *dest, char *num, int type)\n{\n\tif (dest != num)\n\t\tstrcpy(dest, num);\n\tstrcat(dest, get_th(num, type));\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "date2j(tm->tm_year, tm->tm_mon, tm->tm_mday)"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "(tm->tm_mday - 1) / 7 + 1"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -4",
            "rm_months_lower[MONTHS_PER_YEAR - tm->tm_mon]"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -4",
            "rm_months_upper[MONTHS_PER_YEAR - tm->tm_mon]"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%1d\"",
            "(n->key->id == DCH_Y ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 10"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday)",
            "is_interval"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2isoyear",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoyearday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4326-4330",
          "snippet": "int\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoyearday(int year, int mon, int mday)\n{\n\treturn date2j(year, mon, mday) - isoweek2j(date2isoyear(year, mon, mday), 1) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 2 : 3",
            "(n->key->id == DCH_YY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 100"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday)",
            "is_interval"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 3 : 4",
            "(n->key->id == DCH_YYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 1000"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday)",
            "is_interval"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 4 : 5",
            "(n->key->id == DCH_YYYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval))"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday)",
            "is_interval"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d,%03d\"",
            "i",
            "ADJUST_YEAR(tm->tm_year, is_interval) - (i * 1000)"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADJUST_YEAR",
          "args": [
            "tm->tm_year",
            "is_interval"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "i"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (i >= 0) ? 2 : 3",
            "i"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "(tm->tm_mon - 1) / 3 + 1"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : 2",
            "date2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday)"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2isoweek",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "date2isoweek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "4215-4262",
          "snippet": "int\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2isoweek(int year, int mon, int mday)\n{\n\tfloat8\t\tresult;\n\tint\t\t\tday0,\n\t\t\t\tday4,\n\t\t\t\tdayn;\n\n\t/* current day */\n\tdayn = date2j(year, mon, mday);\n\n\t/* fourth day of current year */\n\tday4 = date2j(year, 1, 4);\n\n\t/* day0 == offset to first day of week (Monday) */\n\tday0 = j2day(day4 - 1);\n\n\t/*\n\t * We need the first week containing a Thursday, otherwise this day falls\n\t * into the previous year for purposes of counting weeks\n\t */\n\tif (dayn < day4 - day0)\n\t{\n\t\tday4 = date2j(year - 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\t}\n\n\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\n\t/*\n\t * Sometimes the last few days in a year will fall into the first week of\n\t * the next year, so check for this.\n\t */\n\tif (result >= 52)\n\t{\n\t\tday4 = date2j(year + 1, 1, 4);\n\n\t\t/* day0 == offset to first day of week (Monday) */\n\t\tday0 = j2day(day4 - 1);\n\n\t\tif (dayn >= day4 - day0)\n\t\t\tresult = (dayn - (day4 - day0)) / 7 + 1;\n\t}\n\n\treturn (int) result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : 2",
            "(tm->tm_yday - 1) / 7 + 1"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "(tm->tm_wday == 0) ? 7 : tm->tm_wday"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "tm->tm_wday + 1"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : 2",
            "tm->tm_mday"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : 3",
            "(n->key->id == DCH_DDD) ?\n\t\t\t\t\t\ttm->tm_yday :\n\t\t\t\t\t\tdate2isoyearday(tm->tm_year, tm->tm_mon, tm->tm_mday)"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s",
            "asc_tolower_z(days_short[tm->tm_wday])"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "asc_tolower_z",
          "args": [
            "days_short[tm->tm_wday]"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "asc_tolower_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1994-1998",
          "snippet": "static char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"localized string format value too long\""
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_tolower_z",
          "args": [
            "localized_abbrev_days[tm->tm_wday]",
            "collid"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "str_tolower_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1976-1980",
          "snippet": "static char *\nstr_tolower_z(const char *buff, Oid collid)\n{\n\treturn str_tolower(buff, strlen(buff), collid);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_tolower_z(const char *buff, Oid collid)\n{\n\treturn str_tolower(buff, strlen(buff), collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_initcap_z",
          "args": [
            "localized_abbrev_days[tm->tm_wday]",
            "collid"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "str_initcap_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1988-1992",
          "snippet": "static char *\nstr_initcap_z(const char *buff, Oid collid)\n{\n\treturn str_initcap(buff, strlen(buff), collid);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_initcap_z(const char *buff, Oid collid)\n{\n\treturn str_initcap(buff, strlen(buff), collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_toupper_z",
          "args": [
            "days_short[tm->tm_wday]"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "asc_toupper_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2000-2004",
          "snippet": "static char *\nasc_toupper_z(const char *buff)\n{\n\treturn asc_toupper(buff, strlen(buff));\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_toupper_z(const char *buff)\n{\n\treturn asc_toupper(buff, strlen(buff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_toupper_z",
          "args": [
            "localized_abbrev_days[tm->tm_wday]",
            "collid"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "str_toupper_z",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1982-1986",
          "snippet": "static char *\nstr_toupper_z(const char *buff, Oid collid)\n{\n\treturn str_toupper(buff, strlen(buff), collid);\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_toupper_z(const char *buff, Oid collid)\n{\n\treturn str_toupper(buff, strlen(buff), collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "asc_tolower_z(days[tm->tm_wday])"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "days[tm->tm_wday]"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "asc_toupper_z(days[tm->tm_wday])"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (tm->tm_mon >= 0) ? 2 : 3",
            "tm->tm_mon"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "asc_tolower_z(months_full[tm->tm_mon - 1])"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "months_full[tm->tm_mon - 1]"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%*s\"",
            "S_FM(n->suffix) ? 0 : -9",
            "asc_toupper_z(months_full[tm->tm_mon - 1])"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\"))"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TM",
          "args": [
            "n->suffix"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\":%02d\"",
            "(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "(int) tm->tm_gmtoff"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "float8abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "726-732",
          "snippet": "Datum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nfloat8abs(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(fabs(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%c%0*d\"",
            "(tm->tm_gmtoff >= 0) ? '+' : '-'",
            "S_FM(n->suffix) ? 0 : 2",
            "abs((int) tm->tm_gmtoff) / SECS_PER_HOUR"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%02d\"",
            "(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%c%02d\"",
            "(tm->tm_gmtoff >= 0) ? '+' : '-'",
            "abs((int) tm->tm_gmtoff) / SECS_PER_HOUR"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTzn",
          "args": [
            "in"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTzn",
          "args": [
            "in"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "p"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmtcTzn",
          "args": [
            "in"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmtcTzn",
          "args": [
            "in"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%d\"",
            "tm->tm_hour * SECS_PER_HOUR +\n\t\t\t\t\t\ttm->tm_min * SECS_PER_MINUTE +\n\t\t\t\t\t\ttm->tm_sec"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%06d\"",
            "(int) in->fsec"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%03d\"",
            "(int) (in->fsec / INT64CONST(1000))"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (tm->tm_sec >= 0) ? 2 : 3",
            "tm->tm_sec"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (tm->tm_min >= 0) ? 2 : 3",
            "tm->tm_min"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3",
            "tm->tm_hour"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_TH_TYPE",
          "args": [
            "n->suffix"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%0*d\"",
            "S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3",
            "tm->tm_hour % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 :\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2)"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "n->suffix"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_locale_time",
          "args": [],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "cache_locale_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "765-928",
          "snippet": "void\ncache_locale_time(void)\n{\n\tchar\t\tbuf[(2 * 7 + 2 * 12) * MAX_L10N_DATA];\n\tchar\t   *bufptr;\n\ttime_t\t\ttimenow;\n\tstruct tm  *timeinfo;\n\tbool\t\tstrftimefail = false;\n\tint\t\t\tencoding;\n\tint\t\t\ti;\n\tchar\t   *save_lc_time;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* did we do this already? */\n\tif (CurrentLCTimeValid)\n\t\treturn;\n\n\telog(DEBUG3, \"cache_locale_time() executed; locale: \\\"%s\\\"\", locale_time);\n\n\t/*\n\t * As in PGLC_localeconv(), it's critical that we not throw error while\n\t * libc's locale settings have nondefault values.  Hence, we just call\n\t * strftime() within the critical section, and then convert and save its\n\t * results afterwards.\n\t */\n\n\t/* Save prevailing value of time locale */\n\tsave_lc_time = setlocale(LC_TIME, NULL);\n\tif (!save_lc_time)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_time = pstrdup(save_lc_time);\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we\n\t * must set it here.  This code looks the same as what PGLC_localeconv()\n\t * does, but the underlying reason is different: this does NOT determine\n\t * the encoding we'll get back from strftime_win32().\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* use lc_time to set the ctype */\n\tsetlocale(LC_CTYPE, locale_time);\n#endif\n\n\tsetlocale(LC_TIME, locale_time);\n\n\t/* We use times close to current time as data for strftime(). */\n\ttimenow = time(NULL);\n\ttimeinfo = localtime(&timenow);\n\n\t/* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */\n\tbufptr = buf;\n\n\t/*\n\t * MAX_L10N_DATA is sufficient buffer space for every known locale, and\n\t * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an\n\t * error.)  An implementation might report errors (e.g. ENOMEM) by\n\t * returning 0 (or, less plausibly, a negative value) and setting errno.\n\t * Report errno just in case the implementation did that, but clear it in\n\t * advance of the calls so we don't emit a stale, unrelated errno.\n\t */\n\terrno = 0;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\ttimeinfo->tm_wday = i;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%a\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%A\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\ttimeinfo->tm_mon = i;\n\t\ttimeinfo->tm_mday = 1;\t/* make sure we don't have invalid date */\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%b\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%B\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/*\n\t * Restore the prevailing locale settings; as in PGLC_localeconv(),\n\t * failure to do so is fatal.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_TIME, save_lc_time))\n\t\telog(FATAL, \"failed to restore LC_TIME to \\\"%s\\\"\", save_lc_time);\n\n\t/*\n\t * At this point we've done our best to clean up, and can throw errors, or\n\t * call functions that might throw errors, with a clean conscience.\n\t */\n\tif (strftimefail)\n\t\telog(ERROR, \"strftime() failed: %m\");\n\n\t/* Release the pstrdup'd locale names */\n\tpfree(save_lc_time);\n#ifdef WIN32\n\tpfree(save_lc_ctype);\n#endif\n\n#ifndef WIN32\n\n\t/*\n\t * As in PGLC_localeconv(), we must convert strftime()'s output from the\n\t * encoding implied by LC_TIME to the database encoding.  If we can't\n\t * identify the LC_TIME encoding, just perform encoding validation.\n\t */\n\tencoding = pg_get_encoding_from_locale(locale_time, true);\n\tif (encoding < 0)\n\t\tencoding = PG_SQL_ASCII;\n\n#else\n\n\t/*\n\t * On Windows, strftime_win32() always returns UTF8 data, so convert from\n\t * that if necessary.\n\t */\n\tencoding = PG_UTF8;\n\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tbufptr = buf;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\tCurrentLCTimeValid = true;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define\t\tMAX_L10N_DATA\t\t80"
          ],
          "globals_used": [
            "char\t   *locale_time;",
            "char\t   *localized_abbrev_days[7];",
            "char\t   *localized_full_days[7];",
            "char\t   *localized_abbrev_months[12];",
            "char\t   *localized_full_months[12];",
            "static bool CurrentLCTimeValid = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define\t\tMAX_L10N_DATA\t\t80\n\nchar\t   *locale_time;\nchar\t   *localized_abbrev_days[7];\nchar\t   *localized_full_days[7];\nchar\t   *localized_abbrev_months[12];\nchar\t   *localized_full_months[12];\nstatic bool CurrentLCTimeValid = false;\n\nvoid\ncache_locale_time(void)\n{\n\tchar\t\tbuf[(2 * 7 + 2 * 12) * MAX_L10N_DATA];\n\tchar\t   *bufptr;\n\ttime_t\t\ttimenow;\n\tstruct tm  *timeinfo;\n\tbool\t\tstrftimefail = false;\n\tint\t\t\tencoding;\n\tint\t\t\ti;\n\tchar\t   *save_lc_time;\n#ifdef WIN32\n\tchar\t   *save_lc_ctype;\n#endif\n\n\t/* did we do this already? */\n\tif (CurrentLCTimeValid)\n\t\treturn;\n\n\telog(DEBUG3, \"cache_locale_time() executed; locale: \\\"%s\\\"\", locale_time);\n\n\t/*\n\t * As in PGLC_localeconv(), it's critical that we not throw error while\n\t * libc's locale settings have nondefault values.  Hence, we just call\n\t * strftime() within the critical section, and then convert and save its\n\t * results afterwards.\n\t */\n\n\t/* Save prevailing value of time locale */\n\tsave_lc_time = setlocale(LC_TIME, NULL);\n\tif (!save_lc_time)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_time = pstrdup(save_lc_time);\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we\n\t * must set it here.  This code looks the same as what PGLC_localeconv()\n\t * does, but the underlying reason is different: this does NOT determine\n\t * the encoding we'll get back from strftime_win32().\n\t */\n\n\t/* Save prevailing value of ctype locale */\n\tsave_lc_ctype = setlocale(LC_CTYPE, NULL);\n\tif (!save_lc_ctype)\n\t\telog(ERROR, \"setlocale(NULL) failed\");\n\tsave_lc_ctype = pstrdup(save_lc_ctype);\n\n\t/* use lc_time to set the ctype */\n\tsetlocale(LC_CTYPE, locale_time);\n#endif\n\n\tsetlocale(LC_TIME, locale_time);\n\n\t/* We use times close to current time as data for strftime(). */\n\ttimenow = time(NULL);\n\ttimeinfo = localtime(&timenow);\n\n\t/* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */\n\tbufptr = buf;\n\n\t/*\n\t * MAX_L10N_DATA is sufficient buffer space for every known locale, and\n\t * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an\n\t * error.)  An implementation might report errors (e.g. ENOMEM) by\n\t * returning 0 (or, less plausibly, a negative value) and setting errno.\n\t * Report errno just in case the implementation did that, but clear it in\n\t * advance of the calls so we don't emit a stale, unrelated errno.\n\t */\n\terrno = 0;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\ttimeinfo->tm_wday = i;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%a\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%A\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\ttimeinfo->tm_mon = i;\n\t\ttimeinfo->tm_mday = 1;\t/* make sure we don't have invalid date */\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%b\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t\tif (strftime(bufptr, MAX_L10N_DATA, \"%B\", timeinfo) <= 0)\n\t\t\tstrftimefail = true;\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/*\n\t * Restore the prevailing locale settings; as in PGLC_localeconv(),\n\t * failure to do so is fatal.\n\t */\n#ifdef WIN32\n\tif (!setlocale(LC_CTYPE, save_lc_ctype))\n\t\telog(FATAL, \"failed to restore LC_CTYPE to \\\"%s\\\"\", save_lc_ctype);\n#endif\n\tif (!setlocale(LC_TIME, save_lc_time))\n\t\telog(FATAL, \"failed to restore LC_TIME to \\\"%s\\\"\", save_lc_time);\n\n\t/*\n\t * At this point we've done our best to clean up, and can throw errors, or\n\t * call functions that might throw errors, with a clean conscience.\n\t */\n\tif (strftimefail)\n\t\telog(ERROR, \"strftime() failed: %m\");\n\n\t/* Release the pstrdup'd locale names */\n\tpfree(save_lc_time);\n#ifdef WIN32\n\tpfree(save_lc_ctype);\n#endif\n\n#ifndef WIN32\n\n\t/*\n\t * As in PGLC_localeconv(), we must convert strftime()'s output from the\n\t * encoding implied by LC_TIME to the database encoding.  If we can't\n\t * identify the LC_TIME encoding, just perform encoding validation.\n\t */\n\tencoding = pg_get_encoding_from_locale(locale_time, true);\n\tif (encoding < 0)\n\t\tencoding = PG_SQL_ASCII;\n\n#else\n\n\t/*\n\t * On Windows, strftime_win32() always returns UTF8 data, so convert from\n\t * that if necessary.\n\t */\n\tencoding = PG_UTF8;\n\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tbufptr = buf;\n\n\t/* localized days */\n\tfor (i = 0; i < 7; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_days[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\t/* localized months */\n\tfor (i = 0; i < 12; i++)\n\t{\n\t\tcache_single_string(&localized_abbrev_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t\tcache_single_string(&localized_full_months[i], bufptr, encoding);\n\t\tbufptr += MAX_L10N_DATA;\n\t}\n\n\tCurrentLCTimeValid = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TM_SUFFIX_LEN\t2\n#define INVALID_FOR_INTERVAL  \\\ndo { \\\n\tif (is_interval) \\\n\t\tereport(ERROR, \\\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT), \\\n\t\t\t\t errmsg(\"invalid format specification for an interval value\"), \\\n\t\t\t\t errhint(\"Intervals are not tied to specific calendar dates.\"))); \\\n} while(0)\n#define pm_STR\t\t\"pm\"\n#define PM_STR\t\t\"PM\"\n#define p_m_STR\t\t\"p.m.\"\n#define P_M_STR\t\t\"P.M.\"\n#define am_STR\t\t\"am\"\n#define AM_STR\t\t\"AM\"\n#define a_m_STR\t\t\"a.m.\"\n#define A_M_STR\t\t\"A.M.\"\n#define bc_STR\t\t\"bc\"\n#define BC_STR\t\t\"BC\"\n#define b_c_STR\t\t\"b.c.\"\n#define B_C_STR\t\t\"B.C.\"\n#define ad_STR\t\t\"ad\"\n#define AD_STR\t\t\"AD\"\n#define a_d_STR\t\t\"a.d.\"\n#define A_D_STR\t\t\"A.D.\"\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic const char *const months_full[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n\t\"August\", \"September\", \"October\", \"November\", \"December\", NULL\n};\nstatic const char *const days_short[] = {\n\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", NULL\n};\nstatic const char *const rm_months_upper[] =\n{\"XII\", \"XI\", \"X\", \"IX\", \"VIII\", \"VII\", \"VI\", \"V\", \"IV\", \"III\", \"II\", \"I\", NULL};\nstatic const char *const rm_months_lower[] =\n{\"xii\", \"xi\", \"x\", \"ix\", \"viii\", \"vii\", \"vi\", \"v\", \"iv\", \"iii\", \"ii\", \"i\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic void do_to_timestamp(text *date_txt, text *fmt,\n\t\t\t\tstruct pg_tm *tm, fsec_t *fsec);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nDCH_to_char(FormatNode *node, bool is_interval, TmToChar *in, char *out, Oid collid)\n{\n\tFormatNode *n;\n\tchar\t   *s;\n\tstruct pg_tm *tm = &in->tm;\n\tint\t\t\ti;\n\n\t/* cache localized days and months */\n\tcache_locale_time();\n\n\ts = out;\n\tfor (n = node; n->type != NODE_TYPE_END; n++)\n\t{\n\t\tif (n->type != NODE_TYPE_ACTION)\n\t\t{\n\t\t\tstrcpy(s, n->character);\n\t\t\ts += strlen(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n->key->id)\n\t\t{\n\t\t\tcase DCH_A_M:\n\t\t\tcase DCH_P_M:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? P_M_STR : A_M_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AM:\n\t\t\tcase DCH_PM:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? PM_STR : AM_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_m:\n\t\t\tcase DCH_p_m:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? p_m_STR : a_m_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_am:\n\t\t\tcase DCH_pm:\n\t\t\t\tstrcpy(s, (tm->tm_hour % HOURS_PER_DAY >= HOURS_PER_DAY / 2)\n\t\t\t\t\t   ? pm_STR : am_STR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH:\n\t\t\tcase DCH_HH12:\n\n\t\t\t\t/*\n\t\t\t\t * display time as shown on a 12-hour clock, even for\n\t\t\t\t * intervals\n\t\t\t\t */\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2) == 0 ? HOURS_PER_DAY / 2 :\n\t\t\t\t\t\ttm->tm_hour % (HOURS_PER_DAY / 2));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_HH24:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_hour >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_hour);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MI:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_min >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_min);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SS:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_sec >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MS:\t\t/* millisecond */\n\t\t\t\tsprintf(s, \"%03d\", (int) (in->fsec / INT64CONST(1000)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_US:\t\t/* microsecond */\n\t\t\t\tsprintf(s, \"%06d\", (int) in->fsec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_SSSS:\n\t\t\t\tsprintf(s, \"%d\", tm->tm_hour * SECS_PER_HOUR +\n\t\t\t\t\t\ttm->tm_min * SECS_PER_MINUTE +\n\t\t\t\t\t\ttm->tm_sec);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_tz:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\t/* We assume here that timezone names aren't localized */\n\t\t\t\t\tchar\t   *p = asc_tolower_z(tmtcTzn(in));\n\n\t\t\t\t\tstrcpy(s, p);\n\t\t\t\t\tpfree(p);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZ:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (tmtcTzn(in))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, tmtcTzn(in));\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%02d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_TZM:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%02d\",\n\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_OF:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%c%0*d\",\n\t\t\t\t\t\t(tm->tm_gmtoff >= 0) ? '+' : '-',\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tabs((int) tm->tm_gmtoff) / SECS_PER_HOUR);\n\t\t\t\ts += strlen(s);\n\t\t\t\tif (abs((int) tm->tm_gmtoff) % SECS_PER_HOUR != 0)\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \":%02d\",\n\t\t\t\t\t\t\t(abs((int) tm->tm_gmtoff) % SECS_PER_HOUR) / SECS_PER_MINUTE);\n\t\t\t\t\ts += strlen(s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DCH_A_D:\n\t\t\tcase DCH_B_C:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? B_C_STR : A_D_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_AD:\n\t\t\tcase DCH_BC:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? BC_STR : AD_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_a_d:\n\t\t\tcase DCH_b_c:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? b_c_STR : a_d_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ad:\n\t\t\tcase DCH_bc:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tstrcpy(s, (tm->tm_year <= 0 ? bc_STR : ad_STR));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MONTH:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tmonths_full[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_month:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(months_full[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MON:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, months[tm->tm_mon - 1]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_mon:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_months[tm->tm_mon - 1], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(months[tm->tm_mon - 1]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_MM:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (tm->tm_mon >= 0) ? 2 : 3,\n\t\t\t\t\t\ttm->tm_mon);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DAY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_toupper_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tdays[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_day:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_full_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -9,\n\t\t\t\t\t\t\tasc_tolower_z(days[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DY:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_toupper_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_toupper_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_initcap_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, days_short[tm->tm_wday]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_dy:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tif (S_TM(n->suffix))\n\t\t\t\t{\n\t\t\t\t\tchar\t   *str = str_tolower_z(localized_abbrev_days[tm->tm_wday], collid);\n\n\t\t\t\t\tif (strlen(str) <= (n->key->len + TM_SUFFIX_LEN) * DCH_MAX_ITEM_SIZ)\n\t\t\t\t\t\tstrcpy(s, str);\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t\t errmsg(\"localized string format value too long\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstrcpy(s, asc_tolower_z(days_short[tm->tm_wday]));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DDD:\n\t\t\tcase DCH_IDDD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_DDD) ?\n\t\t\t\t\t\ttm->tm_yday :\n\t\t\t\t\t\tdate2isoyearday(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_DD:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2, tm->tm_mday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_D:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", tm->tm_wday + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_ID:\n\t\t\t\tINVALID_FOR_INTERVAL;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_wday == 0) ? 7 : tm->tm_wday);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_WW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\t(tm->tm_yday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_IW:\n\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : 2,\n\t\t\t\t\t\tdate2isoweek(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Q:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mon - 1) / 3 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_CC:\n\t\t\t\tif (is_interval)\t/* straight calculation */\n\t\t\t\t\ti = tm->tm_year / 100;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tm->tm_year > 0)\n\t\t\t\t\t\t/* Century 20 == 1901 - 2000 */\n\t\t\t\t\t\ti = (tm->tm_year - 1) / 100 + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Century 6BC == 600BC - 501BC */\n\t\t\t\t\t\ti = tm->tm_year / 100 - 1;\n\t\t\t\t}\n\t\t\t\tif (i <= 99 && i >= -99)\n\t\t\t\t\tsprintf(s, \"%0*d\", S_FM(n->suffix) ? 0 : (i >= 0) ? 2 : 3, i);\n\t\t\t\telse\n\t\t\t\t\tsprintf(s, \"%d\", i);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y_YYY:\n\t\t\t\ti = ADJUST_YEAR(tm->tm_year, is_interval) / 1000;\n\t\t\t\tsprintf(s, \"%d,%03d\", i,\n\t\t\t\t\t\tADJUST_YEAR(tm->tm_year, is_interval) - (i * 1000));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYYY:\n\t\t\tcase DCH_IYYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 4 : 5,\n\t\t\t\t\t\t(n->key->id == DCH_YYYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YYY:\n\t\t\tcase DCH_IYY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 3 : 4,\n\t\t\t\t\t\t(n->key->id == DCH_YYY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 1000);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_YY:\n\t\t\tcase DCH_IY:\n\t\t\t\tsprintf(s, \"%0*d\",\n\t\t\t\t\t\tS_FM(n->suffix) ? 0 :\n\t\t\t\t\t\t(ADJUST_YEAR(tm->tm_year, is_interval) >= 0) ? 2 : 3,\n\t\t\t\t\t\t(n->key->id == DCH_YY ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 100);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_Y:\n\t\t\tcase DCH_I:\n\t\t\t\tsprintf(s, \"%1d\",\n\t\t\t\t\t\t(n->key->id == DCH_Y ?\n\t\t\t\t\t\t ADJUST_YEAR(tm->tm_year, is_interval) :\n\t\t\t\t\t\t ADJUST_YEAR(date2isoyear(tm->tm_year,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mon,\n\t\t\t\t\t\t\t\t\t\t\t\t  tm->tm_mday),\n\t\t\t\t\t\t\t\t\t is_interval)) % 10);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_RM:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_upper[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_rm:\n\t\t\t\tif (!tm->tm_mon)\n\t\t\t\t\tbreak;\n\t\t\t\tsprintf(s, \"%*s\", S_FM(n->suffix) ? 0 : -4,\n\t\t\t\t\t\trm_months_lower[MONTHS_PER_YEAR - tm->tm_mon]);\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_W:\n\t\t\t\tsprintf(s, \"%d\", (tm->tm_mday - 1) / 7 + 1);\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t\tcase DCH_J:\n\t\t\t\tsprintf(s, \"%d\", date2j(tm->tm_year, tm->tm_mon, tm->tm_mday));\n\t\t\t\tif (S_THth(n->suffix))\n\t\t\t\t\tstr_numth(s, s, S_TH_TYPE(n->suffix));\n\t\t\t\ts += strlen(s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*s = '\\0';\n}"
  },
  {
    "function_name": "from_char_seq_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2371-2394",
    "snippet": "static int\nfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max,\n\t\t\t\t\t FormatNode *node)\n{\n\tint\t\t\tlen;\n\n\t*dest = seq_search(*src, array, type, max, &len);\n\tif (len <= 0)\n\t{\n\t\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\n\t\tAssert(max <= DCH_MAX_ITEM_SIZ);\n\t\tstrlcpy(copy, *src, max + 1);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\")));\n\t}\n\t*src += len;\n\treturn len;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static char *fill_str(char *str, int c, int max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\"))"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\""
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid value \\\"%s\\\" for \\\"%s\\\"\"",
            "copy",
            "node->key->name"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "copy",
            "*src",
            "max + 1"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "max <= DCH_MAX_ITEM_SIZ"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_search",
          "args": [
            "*src",
            "array",
            "type",
            "max",
            "&len"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2293-2359",
          "snippet": "static int\nseq_search(char *name, const char *const *array, int type, int max, int *len)\n{\n\tconst char *p;\n\tconst char *const *a;\n\tchar\t   *n;\n\tint\t\t\tlast,\n\t\t\t\ti;\n\n\t*len = 0;\n\n\tif (!*name)\n\t\treturn -1;\n\n\t/* set first char */\n\tif (type == ONE_UPPER || type == ALL_UPPER)\n\t\t*name = pg_toupper((unsigned char) *name);\n\telse if (type == ALL_LOWER)\n\t\t*name = pg_tolower((unsigned char) *name);\n\n\tfor (last = 0, a = array; *a != NULL; a++)\n\t{\n\t\t/* compare first chars */\n\t\tif (*name != **a)\n\t\t\tcontinue;\n\n\t\tfor (i = 1, p = *a + 1, n = name + 1;; n++, p++, i++)\n\t\t{\n\t\t\t/* search fragment (max) only */\n\t\t\tif (max && i == max)\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* full size */\n\t\t\tif (*p == '\\0')\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* Not found in array 'a' */\n\t\t\tif (*n == '\\0')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Convert (but convert new chars only)\n\t\t\t */\n\t\t\tif (i > last)\n\t\t\t{\n\t\t\t\tif (type == ONE_UPPER || type == ALL_LOWER)\n\t\t\t\t\t*n = pg_tolower((unsigned char) *n);\n\t\t\t\telse if (type == ALL_UPPER)\n\t\t\t\t\t*n = pg_toupper((unsigned char) *n);\n\t\t\t\tlast = i;\n\t\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"N: %c, P: %c, A: %s (%s)\",\n\t\t\t\t *n, *p, *a, name);\n#endif\n\t\t\tif (*n != *p)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ALL_LOWER\t\t3\t\t/* name */",
            "#define ALL_UPPER\t\t2\t\t/* NAME */",
            "#define ONE_UPPER\t\t1\t\t/* Name */",
            "#define DEBUG_elog_output\tDEBUG3"
          ],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *fill_str(char *str, int c, int max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define ALL_LOWER\t\t3\t\t/* name */\n#define ALL_UPPER\t\t2\t\t/* NAME */\n#define ONE_UPPER\t\t1\t\t/* Name */\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *fill_str(char *str, int c, int max);\n\nstatic int\nseq_search(char *name, const char *const *array, int type, int max, int *len)\n{\n\tconst char *p;\n\tconst char *const *a;\n\tchar\t   *n;\n\tint\t\t\tlast,\n\t\t\t\ti;\n\n\t*len = 0;\n\n\tif (!*name)\n\t\treturn -1;\n\n\t/* set first char */\n\tif (type == ONE_UPPER || type == ALL_UPPER)\n\t\t*name = pg_toupper((unsigned char) *name);\n\telse if (type == ALL_LOWER)\n\t\t*name = pg_tolower((unsigned char) *name);\n\n\tfor (last = 0, a = array; *a != NULL; a++)\n\t{\n\t\t/* compare first chars */\n\t\tif (*name != **a)\n\t\t\tcontinue;\n\n\t\tfor (i = 1, p = *a + 1, n = name + 1;; n++, p++, i++)\n\t\t{\n\t\t\t/* search fragment (max) only */\n\t\t\tif (max && i == max)\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* full size */\n\t\t\tif (*p == '\\0')\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* Not found in array 'a' */\n\t\t\tif (*n == '\\0')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Convert (but convert new chars only)\n\t\t\t */\n\t\t\tif (i > last)\n\t\t\t{\n\t\t\t\tif (type == ONE_UPPER || type == ALL_LOWER)\n\t\t\t\t\t*n = pg_tolower((unsigned char) *n);\n\t\t\t\telse if (type == ALL_UPPER)\n\t\t\t\t\t*n = pg_toupper((unsigned char) *n);\n\t\t\t\tlast = i;\n\t\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"N: %c, P: %c, A: %s (%s)\",\n\t\t\t\t *n, *p, *a, name);\n#endif\n\t\t\tif (*n != *p)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *fill_str(char *str, int c, int max);\n\nstatic int\nfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max,\n\t\t\t\t\t FormatNode *node)\n{\n\tint\t\t\tlen;\n\n\t*dest = seq_search(*src, array, type, max, &len);\n\tif (len <= 0)\n\t{\n\t\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\n\t\tAssert(max <= DCH_MAX_ITEM_SIZ);\n\t\tstrlcpy(copy, *src, max + 1);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"The given value did not match any of the allowed \"\n\t\t\t\t\t\t   \"values for this field.\")));\n\t}\n\t*src += len;\n\treturn len;\n}"
  },
  {
    "function_name": "seq_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2293-2359",
    "snippet": "static int\nseq_search(char *name, const char *const *array, int type, int max, int *len)\n{\n\tconst char *p;\n\tconst char *const *a;\n\tchar\t   *n;\n\tint\t\t\tlast,\n\t\t\t\ti;\n\n\t*len = 0;\n\n\tif (!*name)\n\t\treturn -1;\n\n\t/* set first char */\n\tif (type == ONE_UPPER || type == ALL_UPPER)\n\t\t*name = pg_toupper((unsigned char) *name);\n\telse if (type == ALL_LOWER)\n\t\t*name = pg_tolower((unsigned char) *name);\n\n\tfor (last = 0, a = array; *a != NULL; a++)\n\t{\n\t\t/* compare first chars */\n\t\tif (*name != **a)\n\t\t\tcontinue;\n\n\t\tfor (i = 1, p = *a + 1, n = name + 1;; n++, p++, i++)\n\t\t{\n\t\t\t/* search fragment (max) only */\n\t\t\tif (max && i == max)\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* full size */\n\t\t\tif (*p == '\\0')\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* Not found in array 'a' */\n\t\t\tif (*n == '\\0')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Convert (but convert new chars only)\n\t\t\t */\n\t\t\tif (i > last)\n\t\t\t{\n\t\t\t\tif (type == ONE_UPPER || type == ALL_LOWER)\n\t\t\t\t\t*n = pg_tolower((unsigned char) *n);\n\t\t\t\telse if (type == ALL_UPPER)\n\t\t\t\t\t*n = pg_toupper((unsigned char) *n);\n\t\t\t\tlast = i;\n\t\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"N: %c, P: %c, A: %s (%s)\",\n\t\t\t\t *n, *p, *a, name);\n#endif\n\t\t\tif (*n != *p)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ALL_LOWER\t\t3\t\t/* name */",
      "#define ALL_UPPER\t\t2\t\t/* NAME */",
      "#define ONE_UPPER\t\t1\t\t/* Name */",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static char *fill_str(char *str, int c, int max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"N: %c, P: %c, A: %s (%s)\"",
            "*n",
            "*p",
            "*a",
            "name"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "(unsigned char) *n"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *n"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *name"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "(unsigned char) *name"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define ALL_LOWER\t\t3\t\t/* name */\n#define ALL_UPPER\t\t2\t\t/* NAME */\n#define ONE_UPPER\t\t1\t\t/* Name */\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *fill_str(char *str, int c, int max);\n\nstatic int\nseq_search(char *name, const char *const *array, int type, int max, int *len)\n{\n\tconst char *p;\n\tconst char *const *a;\n\tchar\t   *n;\n\tint\t\t\tlast,\n\t\t\t\ti;\n\n\t*len = 0;\n\n\tif (!*name)\n\t\treturn -1;\n\n\t/* set first char */\n\tif (type == ONE_UPPER || type == ALL_UPPER)\n\t\t*name = pg_toupper((unsigned char) *name);\n\telse if (type == ALL_LOWER)\n\t\t*name = pg_tolower((unsigned char) *name);\n\n\tfor (last = 0, a = array; *a != NULL; a++)\n\t{\n\t\t/* compare first chars */\n\t\tif (*name != **a)\n\t\t\tcontinue;\n\n\t\tfor (i = 1, p = *a + 1, n = name + 1;; n++, p++, i++)\n\t\t{\n\t\t\t/* search fragment (max) only */\n\t\t\tif (max && i == max)\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* full size */\n\t\t\tif (*p == '\\0')\n\t\t\t{\n\t\t\t\t*len = i;\n\t\t\t\treturn a - array;\n\t\t\t}\n\t\t\t/* Not found in array 'a' */\n\t\t\tif (*n == '\\0')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Convert (but convert new chars only)\n\t\t\t */\n\t\t\tif (i > last)\n\t\t\t{\n\t\t\t\tif (type == ONE_UPPER || type == ALL_LOWER)\n\t\t\t\t\t*n = pg_tolower((unsigned char) *n);\n\t\t\t\telse if (type == ALL_UPPER)\n\t\t\t\t\t*n = pg_toupper((unsigned char) *n);\n\t\t\t\tlast = i;\n\t\t\t}\n\n#ifdef DEBUG_TO_FROM_CHAR\n\t\t\telog(DEBUG_elog_output, \"N: %c, P: %c, A: %s (%s)\",\n\t\t\t\t *n, *p, *a, name);\n#endif\n\t\t\tif (*n != *p)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "from_char_parse_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2283-2287",
    "snippet": "static int\nfrom_char_parse_int(int *dest, char **src, FormatNode *node)\n{\n\treturn from_char_parse_int_len(dest, src, node->key->len, node);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_char_parse_int_len",
          "args": [
            "dest",
            "src",
            "node->key->len",
            "node"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_parse_int_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2193-2272",
          "snippet": "static int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
          ],
          "globals_used": [
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
            "static char *int_to_roman(int number);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\n\nstatic int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic int\nfrom_char_parse_int(int *dest, char **src, FormatNode *node)\n{\n\treturn from_char_parse_int_len(dest, src, node->key->len, node);\n}"
  },
  {
    "function_name": "from_char_parse_int_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2193-2272",
    "snippet": "static int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/"
    ],
    "globals_used": [
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static char *int_to_roman(int number);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_char_set_int",
          "args": [
            "dest",
            "(int) result",
            "node"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "from_char_set_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2160-2171",
          "snippet": "static void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX))"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Value must be in the range %d to %d.\"",
            "INT_MIN",
            "INT_MAX"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value for \\\"%s\\\" in source string is out of range\"",
            "node->key->name"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\"))"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\"))"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\""
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "copy",
            "&last",
            "10"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\"))"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "init",
            "src",
            "10"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_next_separator",
          "args": [
            "node"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "is_next_separator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2062-2092",
          "snippet": "static bool\nis_next_separator(FormatNode *n)\n{\n\tif (n->type == NODE_TYPE_END)\n\t\treturn false;\n\n\tif (n->type == NODE_TYPE_ACTION && S_THth(n->suffix))\n\t\treturn true;\n\n\t/*\n\t * Next node\n\t */\n\tn++;\n\n\t/* end of format string is treated like a non-digit separator */\n\tif (n->type == NODE_TYPE_END)\n\t\treturn true;\n\n\tif (n->type == NODE_TYPE_ACTION)\n\t{\n\t\tif (n->key->is_digit)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\telse if (n->character[1] == '\\0' &&\n\t\t\t isdigit((unsigned char) n->character[0]))\n\t\treturn false;\n\n\treturn true;\t\t\t\t/* some non-digit input (separator) */\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NODE_TYPE_ACTION\t2",
            "#define NODE_TYPE_END\t\t1"
          ],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
            "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
            "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
            "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic bool\nis_next_separator(FormatNode *n)\n{\n\tif (n->type == NODE_TYPE_END)\n\t\treturn false;\n\n\tif (n->type == NODE_TYPE_ACTION && S_THth(n->suffix))\n\t\treturn true;\n\n\t/*\n\t * Next node\n\t */\n\tn++;\n\n\t/* end of format string is treated like a non-digit separator */\n\tif (n->type == NODE_TYPE_END)\n\t\treturn true;\n\n\tif (n->type == NODE_TYPE_ACTION)\n\t{\n\t\tif (n->key->is_digit)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\telse if (n->character[1] == '\\0' &&\n\t\t\t isdigit((unsigned char) n->character[0]))\n\t\treturn false;\n\n\treturn true;\t\t\t\t/* some non-digit input (separator) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_FM",
          "args": [
            "node->suffix"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "copy",
            "*src",
            "len + 1"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "len <= DCH_MAX_ITEM_SIZ"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspace_len",
          "args": [
            "*src"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "strspace_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "2119-2130",
          "snippet": "static int\nstrspace_len(char *str)\n{\n\tint\t\t\tlen = 0;\n\n\twhile (*str && isspace((unsigned char) *str))\n\t{\n\t\tstr++;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tstrspace_len(char *str);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic int\nstrspace_len(char *str)\n{\n\tint\t\t\tlen = 0;\n\n\twhile (*str && isspace((unsigned char) *str))\n\t{\n\t\tstr++;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define DCH_MAX_ITEM_SIZ\t   12\t/* max localized day name\t\t*/\n\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\n\nstatic int\nfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node)\n{\n\tlong\t\tresult;\n\tchar\t\tcopy[DCH_MAX_ITEM_SIZ + 1];\n\tchar\t   *init = *src;\n\tint\t\t\tused;\n\n\t/*\n\t * Skip any whitespace before parsing the integer.\n\t */\n\t*src += strspace_len(*src);\n\n\tAssert(len <= DCH_MAX_ITEM_SIZ);\n\tused = (int) strlcpy(copy, *src, len + 1);\n\n\tif (S_FM(node->suffix) || is_next_separator(node))\n\t{\n\t\t/*\n\t\t * This node is in Fill Mode, or the next node is known to be a\n\t\t * non-digit value, so we just slurp as many characters as we can get.\n\t\t */\n\t\terrno = 0;\n\t\tresult = strtol(init, src, 10);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need to pull exactly the number of characters given in 'len' out\n\t\t * of the string, and convert those.\n\t\t */\n\t\tchar\t   *last;\n\n\t\tif (used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"source string too short for \\\"%s\\\" formatting field\",\n\t\t\t\t\t\t\tnode->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"remain.\",\n\t\t\t\t\t\t\t   len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\terrno = 0;\n\t\tresult = strtol(copy, &last, 10);\n\t\tused = last - copy;\n\n\t\tif (used > 0 && used < len)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t\t errdetail(\"Field requires %d characters, but only %d \"\n\t\t\t\t\t\t\t   \"could be parsed.\", len, used),\n\t\t\t\t\t errhint(\"If your source string is not fixed-width, try \"\n\t\t\t\t\t\t\t \"using the \\\"FM\\\" modifier.\")));\n\n\t\t*src += used;\n\t}\n\n\tif (*src == init)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"invalid value \\\"%s\\\" for \\\"%s\\\"\",\n\t\t\t\t\t\tcopy, node->key->name),\n\t\t\t\t errdetail(\"Value must be an integer.\")));\n\n\tif (errno == ERANGE || result < INT_MIN || result > INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value for \\\"%s\\\" in source string is out of range\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"Value must be in the range %d to %d.\",\n\t\t\t\t\t\t   INT_MIN, INT_MAX)));\n\n\tif (dest != NULL)\n\t\tfrom_char_set_int(dest, (int) result, node);\n\treturn *src - init;\n}"
  },
  {
    "function_name": "from_char_set_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2160-2171",
    "snippet": "static void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\"))"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\""
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"conflicting values for \\\"%s\\\" field in formatting string\"",
            "node->key->name"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic void\nfrom_char_set_int(int *dest, const int value, const FormatNode *node)\n{\n\tif (*dest != 0 && *dest != value)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t errmsg(\"conflicting values for \\\"%s\\\" field in formatting string\",\n\t\t\t\t\t\tnode->key->name),\n\t\t\t\t errdetail(\"This value contradicts a previous setting for \"\n\t\t\t\t\t\t   \"the same field type.\")));\n\t*dest = value;\n}"
  },
  {
    "function_name": "from_char_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2138-2152",
    "snippet": "static void\nfrom_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode)\n{\n\tif (mode != FROM_CHAR_DATE_NONE)\n\t{\n\t\tif (tmfc->mode == FROM_CHAR_DATE_NONE)\n\t\t\ttmfc->mode = mode;\n\t\telse if (tmfc->mode != mode)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid combination of date conventions\"),\n\t\t\t\t\t errhint(\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\")));\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid combination of date conventions\"),\n\t\t\t\t\t errhint(\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\"))"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\""
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid combination of date conventions\""
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void from_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode);\n\nstatic void\nfrom_char_set_mode(TmFromChar *tmfc, const FromCharDateMode mode)\n{\n\tif (mode != FROM_CHAR_DATE_NONE)\n\t{\n\t\tif (tmfc->mode == FROM_CHAR_DATE_NONE)\n\t\t\ttmfc->mode = mode;\n\t\telse if (tmfc->mode != mode)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid combination of date conventions\"),\n\t\t\t\t\t errhint(\"Do not mix Gregorian and ISO week date \"\n\t\t\t\t\t\t\t \"conventions in a formatting template.\")));\n\t}\n}"
  },
  {
    "function_name": "strspace_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2119-2130",
    "snippet": "static int\nstrspace_len(char *str)\n{\n\tint\t\t\tlen = 0;\n\n\twhile (*str && isspace((unsigned char) *str))\n\t{\n\t\tstr++;\n\t\tlen++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tstrspace_len(char *str);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *str"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic int\nstrspace_len(char *str)\n{\n\tint\t\t\tlen = 0;\n\n\twhile (*str && isspace((unsigned char) *str))\n\t{\n\t\tstr++;\n\t\tlen++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "adjust_partial_year_to_2020",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2095-2116",
    "snippet": "static int\nadjust_partial_year_to_2020(int year)\n{\n\t/*\n\t * Adjust all dates toward 2020; this is effectively what happens when we\n\t * assume '70' is 1970 and '69' is 2069.\n\t */\n\t/* Force 0-69 into the 2000's */\n\tif (year < 70)\n\t\treturn year + 2000;\n\t/* Force 70-99 into the 1900's */\n\telse if (year < 100)\n\t\treturn year + 1900;\n\t/* Force 100-519 into the 2000's */\n\telse if (year < 520)\n\t\treturn year + 2000;\n\t/* Force 520-999 into the 1000's */\n\telse if (year < 1000)\n\t\treturn year + 1000;\n\telse\n\t\treturn year;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tadjust_partial_year_to_2020(int year);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tadjust_partial_year_to_2020(int year);\n\nstatic int\nadjust_partial_year_to_2020(int year)\n{\n\t/*\n\t * Adjust all dates toward 2020; this is effectively what happens when we\n\t * assume '70' is 1970 and '69' is 2069.\n\t */\n\t/* Force 0-69 into the 2000's */\n\tif (year < 70)\n\t\treturn year + 2000;\n\t/* Force 70-99 into the 1900's */\n\telse if (year < 100)\n\t\treturn year + 1900;\n\t/* Force 100-519 into the 2000's */\n\telse if (year < 520)\n\t\treturn year + 2000;\n\t/* Force 520-999 into the 1000's */\n\telse if (year < 1000)\n\t\treturn year + 1000;\n\telse\n\t\treturn year;\n}"
  },
  {
    "function_name": "is_next_separator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2062-2092",
    "snippet": "static bool\nis_next_separator(FormatNode *n)\n{\n\tif (n->type == NODE_TYPE_END)\n\t\treturn false;\n\n\tif (n->type == NODE_TYPE_ACTION && S_THth(n->suffix))\n\t\treturn true;\n\n\t/*\n\t * Next node\n\t */\n\tn++;\n\n\t/* end of format string is treated like a non-digit separator */\n\tif (n->type == NODE_TYPE_END)\n\t\treturn true;\n\n\tif (n->type == NODE_TYPE_ACTION)\n\t{\n\t\tif (n->key->is_digit)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\telse if (n->character[1] == '\\0' &&\n\t\t\t isdigit((unsigned char) n->character[0]))\n\t\treturn false;\n\n\treturn true;\t\t\t\t/* some non-digit input (separator) */\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) n->character[0]"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_THth",
          "args": [
            "n->suffix"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\n\nstatic bool\nis_next_separator(FormatNode *n)\n{\n\tif (n->type == NODE_TYPE_END)\n\t\treturn false;\n\n\tif (n->type == NODE_TYPE_ACTION && S_THth(n->suffix))\n\t\treturn true;\n\n\t/*\n\t * Next node\n\t */\n\tn++;\n\n\t/* end of format string is treated like a non-digit separator */\n\tif (n->type == NODE_TYPE_END)\n\t\treturn true;\n\n\tif (n->type == NODE_TYPE_ACTION)\n\t{\n\t\tif (n->key->is_digit)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\telse if (n->character[1] == '\\0' &&\n\t\t\t isdigit((unsigned char) n->character[0]))\n\t\treturn false;\n\n\treturn true;\t\t\t\t/* some non-digit input (separator) */\n}"
  },
  {
    "function_name": "dump_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2031-2055",
    "snippet": "static void\ndump_index(const KeyWord *k, const int *index)\n{\n\tint\t\t\ti,\n\t\t\t\tcount = 0,\n\t\t\t\tfree_i = 0;\n\n\telog(DEBUG_elog_output, \"TO-FROM_CHAR: Dump KeyWord Index:\");\n\n\tfor (i = 0; i < KeyWord_INDEX_SIZE; i++)\n\t{\n\t\tif (index[i] != -1)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"\\t%c: %s, \", i + 32, k[index[i]].name);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree_i++;\n\t\t\telog(DEBUG_elog_output, \"\\t(%d) %c %d\", i, i + 32, index[i]);\n\t\t}\n\t}\n\telog(DEBUG_elog_output, \"\\n\\t\\tUsed positions: %d,\\n\\t\\tFree positions: %d\",\n\t\t count, free_i);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define KeyWord_INDEX_SIZE\t\t('~' - ' ')",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"\\n\\t\\tUsed positions: %d,\\n\\t\\tFree positions: %d\"",
            "count",
            "free_i"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define KeyWord_INDEX_SIZE\t\t('~' - ' ')\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\n\nstatic void\ndump_index(const KeyWord *k, const int *index)\n{\n\tint\t\t\ti,\n\t\t\t\tcount = 0,\n\t\t\t\tfree_i = 0;\n\n\telog(DEBUG_elog_output, \"TO-FROM_CHAR: Dump KeyWord Index:\");\n\n\tfor (i = 0; i < KeyWord_INDEX_SIZE; i++)\n\t{\n\t\tif (index[i] != -1)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"\\t%c: %s, \", i + 32, k[index[i]].name);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfree_i++;\n\t\t\telog(DEBUG_elog_output, \"\\t(%d) %c %d\", i, i + 32, index[i]);\n\t\t}\n\t}\n\telog(DEBUG_elog_output, \"\\n\\t\\tUsed positions: %d,\\n\\t\\tFree positions: %d\",\n\t\t count, free_i);\n}"
  },
  {
    "function_name": "asc_toupper_z",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "2000-2004",
    "snippet": "static char *\nasc_toupper_z(const char *buff)\n{\n\treturn asc_toupper(buff, strlen(buff));\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asc_toupper",
          "args": [
            "buff",
            "strlen(buff)"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "asc_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1922-1937",
          "snippet": "char *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buff"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_toupper_z(const char *buff)\n{\n\treturn asc_toupper(buff, strlen(buff));\n}"
  },
  {
    "function_name": "asc_tolower_z",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1994-1998",
    "snippet": "static char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asc_tolower",
          "args": [
            "buff",
            "strlen(buff)"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "asc_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1899-1914",
          "snippet": "char *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buff"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *\nasc_tolower_z(const char *buff)\n{\n\treturn asc_tolower(buff, strlen(buff));\n}"
  },
  {
    "function_name": "str_initcap_z",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1988-1992",
    "snippet": "static char *\nstr_initcap_z(const char *buff, Oid collid)\n{\n\treturn str_initcap(buff, strlen(buff), collid);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "str_initcap",
          "args": [
            "buff",
            "strlen(buff)",
            "collid"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "str_initcap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1752-1891",
          "snippet": "char *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buff"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_initcap_z(const char *buff, Oid collid)\n{\n\treturn str_initcap(buff, strlen(buff), collid);\n}"
  },
  {
    "function_name": "str_toupper_z",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1982-1986",
    "snippet": "static char *\nstr_toupper_z(const char *buff, Oid collid)\n{\n\treturn str_toupper(buff, strlen(buff), collid);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "str_toupper",
          "args": [
            "buff",
            "strlen(buff)",
            "collid"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "str_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1630-1744",
          "snippet": "char *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buff"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_toupper_z(const char *buff, Oid collid)\n{\n\treturn str_toupper(buff, strlen(buff), collid);\n}"
  },
  {
    "function_name": "str_tolower_z",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1976-1980",
    "snippet": "static char *\nstr_tolower_z(const char *buff, Oid collid)\n{\n\treturn str_tolower(buff, strlen(buff), collid);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "str_tolower",
          "args": [
            "buff",
            "strlen(buff)",
            "collid"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "str_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1508-1622",
          "snippet": "char *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buff"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nstatic char *\nstr_tolower_z(const char *buff, Oid collid)\n{\n\treturn str_tolower(buff, strlen(buff), collid);\n}"
  },
  {
    "function_name": "asc_initcap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1945-1972",
    "snippet": "char *\nasc_initcap(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t{\n\t\tchar\t\tc;\n\n\t\tif (wasalnum)\n\t\t\t*p = c = pg_ascii_tolower((unsigned char) *p);\n\t\telse\n\t\t\t*p = c = pg_ascii_toupper((unsigned char) *p);\n\t\t/* we don't trust isalnum() here */\n\t\twasalnum = ((c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t(c >= 'a' && c <= 'z') ||\n\t\t\t\t\t(c >= '0' && c <= '9'));\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ascii_toupper",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_ascii_tolower",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_initcap(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t{\n\t\tchar\t\tc;\n\n\t\tif (wasalnum)\n\t\t\t*p = c = pg_ascii_tolower((unsigned char) *p);\n\t\telse\n\t\t\t*p = c = pg_ascii_toupper((unsigned char) *p);\n\t\t/* we don't trust isalnum() here */\n\t\twasalnum = ((c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t(c >= 'a' && c <= 'z') ||\n\t\t\t\t\t(c >= '0' && c <= '9'));\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "asc_toupper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1922-1937",
    "snippet": "char *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ascii_toupper",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}"
  },
  {
    "function_name": "asc_tolower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1899-1914",
    "snippet": "char *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_ascii_tolower",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}"
  },
  {
    "function_name": "str_initcap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1752-1891",
    "snippet": "char *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static char *int_to_roman(int number);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum_l",
          "args": [
            "(unsigned char) *p",
            "mylocale->info.lt"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper_l",
          "args": [
            "(unsigned char) *p",
            "mylocale->info.lt"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower_l",
          "args": [
            "(unsigned char) *p",
            "mylocale->info.lt"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "workspace"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wchar2char",
          "args": [
            "result",
            "workspace",
            "result_size",
            "mylocale"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1664-1724",
          "snippet": "size_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "result_size"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iswalnum",
          "args": [
            "workspace[curr_char]"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towupper",
          "args": [
            "workspace[curr_char]"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towlower",
          "args": [
            "workspace[curr_char]"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iswalnum_l",
          "args": [
            "workspace[curr_char]",
            "mylocale->info.lt"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towupper_l",
          "args": [
            "workspace[curr_char]",
            "mylocale->info.lt"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towlower_l",
          "args": [
            "workspace[curr_char]",
            "mylocale->info.lt"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char2wchar",
          "args": [
            "workspace",
            "nbytes + 1",
            "buff",
            "nbytes",
            "mylocale"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "char2wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1735-1822",
          "snippet": "size_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_from_uchar",
          "args": [
            "&result",
            "buff_conv",
            "len_conv"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "icu_from_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1623-1648",
          "snippet": "int32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_convert_case",
          "args": [
            "u_strToTitle_default_BI",
            "mylocale",
            "&buff_conv",
            "buff_uchar",
            "len_uchar"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "icu_convert_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1447-1472",
          "snippet": "static int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&buff_uchar",
            "buff",
            "nbytes"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collid"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_initcap",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "asc_initcap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1945-1972",
          "snippet": "char *\nasc_initcap(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t{\n\t\tchar\t\tc;\n\n\t\tif (wasalnum)\n\t\t\t*p = c = pg_ascii_tolower((unsigned char) *p);\n\t\telse\n\t\t\t*p = c = pg_ascii_toupper((unsigned char) *p);\n\t\t/* we don't trust isalnum() here */\n\t\twasalnum = ((c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t(c >= 'a' && c <= 'z') ||\n\t\t\t\t\t(c >= '0' && c <= '9'));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_initcap(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t{\n\t\tchar\t\tc;\n\n\t\tif (wasalnum)\n\t\t\t*p = c = pg_ascii_tolower((unsigned char) *p);\n\t\telse\n\t\t\t*p = c = pg_ascii_toupper((unsigned char) *p);\n\t\t/* we don't trust isalnum() here */\n\t\twasalnum = ((c >= 'A' && c <= 'Z') ||\n\t\t\t\t\t(c >= 'a' && c <= 'z') ||\n\t\t\t\t\t(c >= '0' && c <= '9'));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lc_ctype_is_c",
          "args": [
            "collid"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "lc_ctype_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1236-1281",
          "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "str_toupper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1630-1744",
    "snippet": "char *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static char *int_to_roman(int number);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_toupper",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper_l",
          "args": [
            "(unsigned char) *p",
            "mylocale->info.lt"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "workspace"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wchar2char",
          "args": [
            "result",
            "workspace",
            "result_size",
            "mylocale"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1664-1724",
          "snippet": "size_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "result_size"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "towupper",
          "args": [
            "workspace[curr_char]"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towupper_l",
          "args": [
            "workspace[curr_char]",
            "mylocale->info.lt"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char2wchar",
          "args": [
            "workspace",
            "nbytes + 1",
            "buff",
            "nbytes",
            "mylocale"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "char2wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1735-1822",
          "snippet": "size_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_from_uchar",
          "args": [
            "&result",
            "buff_conv",
            "len_conv"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "icu_from_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1623-1648",
          "snippet": "int32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_convert_case",
          "args": [
            "u_strToUpper",
            "mylocale",
            "&buff_conv",
            "buff_uchar",
            "len_uchar"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "icu_convert_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1447-1472",
          "snippet": "static int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&buff_uchar",
            "buff",
            "nbytes"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collid"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_toupper",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "asc_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1922-1937",
          "snippet": "char *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_toupper(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_toupper((unsigned char) *p);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lc_ctype_is_c",
          "args": [
            "collid"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "lc_ctype_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1236-1281",
          "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "str_tolower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1508-1622",
    "snippet": "char *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
      "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
      "static char *int_to_roman(int number);",
      "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_tolower",
          "args": [
            "(unsigned char) *p"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower_l",
          "args": [
            "(unsigned char) *p",
            "mylocale->info.lt"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "workspace"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wchar2char",
          "args": [
            "result",
            "workspace",
            "result_size",
            "mylocale"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "wchar2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1664-1724",
          "snippet": "size_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nwchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows, the \"Unicode\" locales assume UTF16 not UTF8 encoding, and\n\t * for some reason mbstowcs and wcstombs won't do this for us, so we use\n\t * MultiByteToWideChar().\n\t */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\tresult = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,\n\t\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t/* A zero return is failure */\n\t\tif (result <= 0)\n\t\t\tresult = -1;\n\t\telse\n\t\t{\n\t\t\tAssert(result <= tolen);\n\t\t\t/* Microsoft counts the zero terminator in the result */\n\t\t\tresult--;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\tif (locale == (pg_locale_t) 0)\n\t{\n\t\t/* Use wcstombs directly for the default locale */\n\t\tresult = wcstombs(to, from, tolen);\n\t}\n\telse\n\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_WCSTOMBS_L\n\t\t/* Use wcstombs_l for nondefault locales */\n\t\tresult = wcstombs_l(to, from, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_WCSTOMBS_L */\n\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\tresult = wcstombs(to, from, tolen);\n\n\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_WCSTOMBS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\telog(ERROR, \"wcstombs_l is not available\");\n\t\tresult = 0;\t\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "result_size"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "towlower",
          "args": [
            "workspace[curr_char]"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "towlower_l",
          "args": [
            "workspace[curr_char]",
            "mylocale->info.lt"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "char2wchar",
          "args": [
            "workspace",
            "nbytes + 1",
            "buff",
            "nbytes",
            "mylocale"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "char2wchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1735-1822",
          "snippet": "size_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nsize_t\nchar2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,\n\t\t   pg_locale_t locale)\n{\n\tsize_t\t\tresult;\n\n\tAssert(!locale || locale->provider == COLLPROVIDER_LIBC);\n\n\tif (tolen == 0)\n\t\treturn 0;\n\n#ifdef WIN32\n\t/* See WIN32 \"Unicode\" comment above */\n\tif (GetDatabaseEncoding() == PG_UTF8)\n\t{\n\t\t/* Win32 API does not work for zero-length input */\n\t\tif (fromlen == 0)\n\t\t\tresult = 0;\n\t\telse\n\t\t{\n\t\t\tresult = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);\n\t\t\t/* A zero return is failure */\n\t\t\tif (result == 0)\n\t\t\t\tresult = -1;\n\t\t}\n\n\t\tif (result != -1)\n\t\t{\n\t\t\tAssert(result < tolen);\n\t\t\t/* Append trailing null wchar (MultiByteToWideChar() does not) */\n\t\t\tto[result] = 0;\n\t\t}\n\t}\n\telse\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t{\n\t\t/* mbstowcs requires ending '\\0' */\n\t\tchar\t   *str = pnstrdup(from, fromlen);\n\n\t\tif (locale == (pg_locale_t) 0)\n\t\t{\n\t\t\t/* Use mbstowcs directly for the default locale */\n\t\t\tresult = mbstowcs(to, str, tolen);\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n#ifdef HAVE_MBSTOWCS_L\n\t\t\t/* Use mbstowcs_l for nondefault locales */\n\t\t\tresult = mbstowcs_l(to, str, tolen, locale->info.lt);\n#else\t\t\t\t\t\t\t/* !HAVE_MBSTOWCS_L */\n\t\t\t/* We have to temporarily set the locale as current ... ugh */\n\t\t\tlocale_t\tsave_locale = uselocale(locale->info.lt);\n\n\t\t\tresult = mbstowcs(to, str, tolen);\n\n\t\t\tuselocale(save_locale);\n#endif\t\t\t\t\t\t\t/* HAVE_MBSTOWCS_L */\n#else\t\t\t\t\t\t\t/* !HAVE_LOCALE_T */\n\t\t\t/* Can't have locale != 0 without HAVE_LOCALE_T */\n\t\t\telog(ERROR, \"mbstowcs_l is not available\");\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n#endif\t\t\t\t\t\t\t/* HAVE_LOCALE_T */\n\t\t}\n\n\t\tpfree(str);\n\t}\n\n\tif (result == -1)\n\t{\n\t\t/*\n\t\t * Invalid multibyte character encountered.  We try to give a useful\n\t\t * error message by letting pg_verifymbstr check the string.  But it's\n\t\t * possible that the string is OK to us, and not OK to mbstowcs ---\n\t\t * this suggests that the LC_CTYPE locale is different from the\n\t\t * database encoding.  Give a generic error message if verifymbstr\n\t\t * can't find anything wrong.\n\t\t */\n\t\tpg_verifymbstr(from, fromlen, false);\t/* might not return */\n\t\t/* but if it does ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t errmsg(\"invalid multibyte character for locale\"),\n\t\t\t\t errhint(\"The server's LC_CTYPE locale is probably incompatible with the database encoding.\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\"))"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_from_uchar",
          "args": [
            "&result",
            "buff_conv",
            "len_conv"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "icu_from_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1623-1648",
          "snippet": "int32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_result;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\t*result = palloc(len_result + 1);\n\n\tstatus = U_ZERO_ERROR;\n\tlen_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,\n\t\t\t\t\t\t\t\t buff_uchar, len_uchar, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_fromUChars failed: %s\", u_errorName(status))));\n\n\treturn len_result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_convert_case",
          "args": [
            "u_strToLower",
            "mylocale",
            "&buff_conv",
            "buff_uchar",
            "len_uchar"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "icu_convert_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1447-1472",
          "snippet": "static int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&buff_uchar",
            "buff",
            "nbytes"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collid"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc_tolower",
          "args": [
            "buff",
            "nbytes"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "asc_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1899-1914",
          "snippet": "char *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nasc_tolower(const char *buff, size_t nbytes)\n{\n\tchar\t   *result;\n\tchar\t   *p;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\tresult = pnstrdup(buff, nbytes);\n\n\tfor (p = result; *p; p++)\n\t\t*p = pg_ascii_tolower((unsigned char) *p);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lc_ctype_is_c",
          "args": [
            "collid"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "lc_ctype_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1236-1281",
          "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "u_strToTitle_default_BI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1474-1482",
    "snippet": "static int32_t\nu_strToTitle_default_BI(UChar *dest, int32_t destCapacity,\n\t\t\t\t\t\tconst UChar *src, int32_t srcLength,\n\t\t\t\t\t\tconst char *locale,\n\t\t\t\t\t\tUErrorCode *pErrorCode)\n{\n\treturn u_strToTitle(dest, destCapacity, src, srcLength,\n\t\t\t\t\t\tNULL, locale, pErrorCode);\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u_strToTitle",
          "args": [
            "dest",
            "destCapacity",
            "src",
            "srcLength",
            "NULL",
            "locale",
            "pErrorCode"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32_t\nu_strToTitle_default_BI(UChar *dest, int32_t destCapacity,\n\t\t\t\t\t\tconst UChar *src, int32_t srcLength,\n\t\t\t\t\t\tconst char *locale,\n\t\t\t\t\t\tUErrorCode *pErrorCode)\n{\n\treturn u_strToTitle(dest, destCapacity, src, srcLength,\n\t\t\t\t\t\tNULL, locale, pErrorCode);\n}"
  },
  {
    "function_name": "icu_convert_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1447-1472",
    "snippet": "static int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"case conversion failed: %s\", u_errorName(status)))"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"case conversion failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "*buff_dest",
            "len_dest",
            "buff_source",
            "len_source",
            "mylocale->info.icu.locale",
            "&status"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len_dest * sizeof(**buff_dest)"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "*buff_dest"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "*buff_dest",
            "len_dest",
            "buff_source",
            "len_source",
            "mylocale->info.icu.locale",
            "&status"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32_t\nicu_convert_case(ICU_Convert_Func func, pg_locale_t mylocale,\n\t\t\t\t UChar **buff_dest, UChar *buff_source, int32_t len_source)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_dest;\n\n\tlen_dest = len_source;\t\t/* try first with same length */\n\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\tstatus = U_ZERO_ERROR;\n\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\tmylocale->info.icu.locale, &status);\n\tif (status == U_BUFFER_OVERFLOW_ERROR)\n\t{\n\t\t/* try again with adjusted length */\n\t\tpfree(*buff_dest);\n\t\t*buff_dest = palloc(len_dest * sizeof(**buff_dest));\n\t\tstatus = U_ZERO_ERROR;\n\t\tlen_dest = func(*buff_dest, len_dest, buff_source, len_source,\n\t\t\t\t\t\tmylocale->info.icu.locale, &status);\n\t}\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"case conversion failed: %s\", u_errorName(status))));\n\treturn len_dest;\n}"
  },
  {
    "function_name": "str_numth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1427-1434",
    "snippet": "static char *\nstr_numth(char *dest, char *num, int type)\n{\n\tif (dest != num)\n\t\tstrcpy(dest, num);\n\tstrcat(dest, get_th(num, type));\n\treturn dest;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static char *get_last_relevant_decnum(char *num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dest",
            "get_th(num, type)"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_th",
          "args": [
            "num",
            "type"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "get_th",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1381-1420",
          "snippet": "static const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TH_UPPER\t\t1"
          ],
          "globals_used": [
            "static const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};",
            "static const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};",
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static char *int_to_roman(int number);",
            "static char *get_last_relevant_decnum(char *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TH_UPPER\t\t1\n\nstatic const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};\nstatic const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dest",
            "num"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic char *\nstr_numth(char *dest, char *num, int type)\n{\n\tif (dest != num)\n\t\tstrcpy(dest, num);\n\tstrcat(dest, get_th(num, type));\n\treturn dest;\n}"
  },
  {
    "function_name": "get_th",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1381-1420",
    "snippet": "static const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TH_UPPER\t\t1"
    ],
    "globals_used": [
      "static const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};",
      "static const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};",
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static char *int_to_roman(int number);",
      "static char *get_last_relevant_decnum(char *num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num))"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"%s\\\" is not a number\"",
            "num"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) last"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "num"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TH_UPPER\t\t1\n\nstatic const char *const numTH[] = {\"ST\", \"ND\", \"RD\", \"TH\", NULL};\nstatic const char *const numth[] = {\"st\", \"nd\", \"rd\", \"th\", NULL};\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic char *int_to_roman(int number);\nstatic char *get_last_relevant_decnum(char *num);\n\nstatic const char *\nget_th(char *num, int type)\n{\n\tint\t\t\tlen = strlen(num),\n\t\t\t\tlast,\n\t\t\t\tseclast;\n\n\tlast = *(num + (len - 1));\n\tif (!isdigit((unsigned char) last))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a number\", num)));\n\n\t/*\n\t * All \"teens\" (<x>1[0-9]) get 'TH/th', while <x>[02-9][123] still get\n\t * 'ST/st', 'ND/nd', 'RD/rd', respectively\n\t */\n\tif ((len > 1) && ((seclast = num[len - 2]) == '1'))\n\t\tlast = 0;\n\n\tswitch (last)\n\t{\n\t\tcase '1':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[0];\n\t\t\treturn numth[0];\n\t\tcase '2':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[1];\n\t\t\treturn numth[1];\n\t\tcase '3':\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[2];\n\t\t\treturn numth[2];\n\t\tdefault:\n\t\t\tif (type == TH_UPPER)\n\t\t\t\treturn numTH[3];\n\t\t\treturn numth[3];\n\t}\n}"
  },
  {
    "function_name": "dump_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1345-1369",
    "snippet": "static void\ndump_node(FormatNode *node, int max)\n{\n\tFormatNode *n;\n\tint\t\t\ta;\n\n\telog(DEBUG_elog_output, \"to_from-char(): DUMP FORMAT\");\n\n\tfor (a = 0, n = node; a <= max; n++, a++)\n\t{\n\t\tif (n->type == NODE_TYPE_ACTION)\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_ACTION '%s'\\t(%s,%s)\",\n\t\t\t\t a, n->key->name, DUMP_THth(n->suffix), DUMP_FM(n->suffix));\n\t\telse if (n->type == NODE_TYPE_CHAR)\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_CHAR '%s'\",\n\t\t\t\t a, n->character);\n\t\telse if (n->type == NODE_TYPE_END)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_END\", a);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\telog(DEBUG_elog_output, \"%d:\\t unknown NODE!\", a);\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NODE_TYPE_CHAR\t\t3",
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static char *fill_str(char *str, int c, int max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"%d:\\t unknown NODE!\"",
            "a"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DUMP_FM",
          "args": [
            "n->suffix"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DUMP_THth",
          "args": [
            "n->suffix"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *fill_str(char *str, int c, int max);\n\nstatic void\ndump_node(FormatNode *node, int max)\n{\n\tFormatNode *n;\n\tint\t\t\ta;\n\n\telog(DEBUG_elog_output, \"to_from-char(): DUMP FORMAT\");\n\n\tfor (a = 0, n = node; a <= max; n++, a++)\n\t{\n\t\tif (n->type == NODE_TYPE_ACTION)\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_ACTION '%s'\\t(%s,%s)\",\n\t\t\t\t a, n->key->name, DUMP_THth(n->suffix), DUMP_FM(n->suffix));\n\t\telse if (n->type == NODE_TYPE_CHAR)\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_CHAR '%s'\",\n\t\t\t\t a, n->character);\n\t\telse if (n->type == NODE_TYPE_END)\n\t\t{\n\t\t\telog(DEBUG_elog_output, \"%d:\\t NODE_TYPE_END\", a);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\telog(DEBUG_elog_output, \"%d:\\t unknown NODE!\", a);\n\t}\n}"
  },
  {
    "function_name": "parse_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1225-1334",
    "snippet": "static void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SUFFTYPE_POSTFIX\t2",
      "#define SUFFTYPE_PREFIX\t\t1",
      "#define NODE_TYPE_CHAR\t\t3",
      "#define NODE_TYPE_ACTION\t2",
      "#define NODE_TYPE_END\t\t1",
      "#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/",
      "#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/",
      "#define DEBUG_elog_output\tDEBUG3"
    ],
    "globals_used": [
      "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tstrspace_len(char *str);",
      "static void from_char_set_int(int *dest, const int value, const FormatNode *node);",
      "static int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);",
      "static int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);",
      "static char *int_to_roman(int number);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n->character",
            "str",
            "chlen"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "str"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n->character",
            "str",
            "chlen"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suff_search",
          "args": [
            "str",
            "suf",
            "SUFFTYPE_POSTFIX"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "suff_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1030-1044",
          "snippet": "static const KeySuffix *\nsuff_search(const char *str, const KeySuffix *suf, int type)\n{\n\tconst KeySuffix *s;\n\n\tfor (s = suf; s->name != NULL; s++)\n\t{\n\t\tif (s->type != type)\n\t\t\tcontinue;\n\n\t\tif (strncmp(str, s->name, s->len) == 0)\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static int\tstrspace_len(char *str);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic const KeySuffix *\nsuff_search(const char *str, const KeySuffix *suf, int type)\n{\n\tconst KeySuffix *s;\n\n\tfor (s = suf; s->name != NULL; s++)\n\t{\n\t\tif (s->type != type)\n\t\t\tcontinue;\n\n\t\tif (strncmp(str, s->name, s->len) == 0)\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUMDesc_prepare",
          "args": [
            "Num",
            "n"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "NUMDesc_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1050-1216",
          "snippet": "static void\nNUMDesc_prepare(NUMDesc *num, FormatNode *n)\n{\n\tif (n->type != NODE_TYPE_ACTION)\n\t\treturn;\n\n\tif (IS_EEEE(num) && n->key->id != NUM_E)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"\\\"EEEE\\\" must be the last pattern used\")));\n\n\tswitch (n->key->id)\n\t{\n\t\tcase NUM_9:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"9\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t{\n\t\t\t\t++num->multi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\t++num->post;\n\t\t\telse\n\t\t\t\t++num->pre;\n\t\t\tbreak;\n\n\t\tcase NUM_0:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"0\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (!IS_ZERO(num) && !IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->flag |= NUM_F_ZERO;\n\t\t\t\tnum->zero_start = num->pre + 1;\n\t\t\t}\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t\t++num->pre;\n\t\t\telse\n\t\t\t\t++num->post;\n\n\t\t\tnum->zero_end = num->pre + num->post;\n\t\t\tbreak;\n\n\t\tcase NUM_B:\n\t\t\tif (num->pre == 0 && num->post == 0 && (!IS_ZERO(num)))\n\t\t\t\tnum->flag |= NUM_F_BLANK;\n\t\t\tbreak;\n\n\t\tcase NUM_D:\n\t\t\tnum->flag |= NUM_F_LDECIMAL;\n\t\t\tnum->need_locale = true;\n\t\t\t/* FALLTHROUGH */\n\t\tcase NUM_DEC:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"multiple decimal points\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_DECIMAL;\n\t\t\tbreak;\n\n\t\tcase NUM_FM:\n\t\t\tnum->flag |= NUM_F_FILLMODE;\n\t\t\tbreak;\n\n\t\tcase NUM_S:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" twice\")));\n\t\t\tif (IS_PLUS(num) || IS_MINUS(num) || IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\"/\\\"PR\\\" together\")));\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_PRE;\n\t\t\t\tnum->pre_lsign_num = num->pre;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\telse if (num->lsign == NUM_LSIGN_NONE)\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_POST;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NUM_MI:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"MI\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_MINUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_PL:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\" together\")));\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_PLUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_SG:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tbreak;\n\n\t\tcase NUM_PR:\n\t\t\tif (IS_LSIGN(num) || IS_PLUS(num) || IS_MINUS(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"PR\\\" and \\\"S\\\"/\\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_BRACKET;\n\t\t\tbreak;\n\n\t\tcase NUM_rn:\n\t\tcase NUM_RN:\n\t\t\tnum->flag |= NUM_F_ROMAN;\n\t\t\tbreak;\n\n\t\tcase NUM_L:\n\t\tcase NUM_G:\n\t\t\tnum->need_locale = true;\n\t\t\tbreak;\n\n\t\tcase NUM_V:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_MULTI;\n\t\t\tbreak;\n\n\t\tcase NUM_E:\n\t\t\tif (IS_EEEE(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"EEEE\\\" twice\")));\n\t\t\tif (IS_BLANK(num) || IS_FILLMODE(num) || IS_LSIGN(num) ||\n\t\t\t\tIS_BRACKET(num) || IS_MINUS(num) || IS_PLUS(num) ||\n\t\t\t\tIS_ROMAN(num) || IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"EEEE\\\" is incompatible with other formats\"),\n\t\t\t\t\t\t errdetail(\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\")));\n\t\t\tnum->flag |= NUM_F_EEEE;\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_LSIGN_NONE\t0",
            "#define NUM_LSIGN_POST\t1",
            "#define NUM_LSIGN_PRE\t(-1)",
            "#define NUM_F_EEEE\t\t\t(1 << 14)",
            "#define NUM_F_MINUS_POST\t(1 << 13)",
            "#define NUM_F_PLUS_POST\t\t(1 << 12)",
            "#define NUM_F_MULTI\t\t\t(1 << 11)",
            "#define NUM_F_ROMAN\t\t\t(1 << 10)",
            "#define NUM_F_PLUS\t\t\t(1 << 9)",
            "#define NUM_F_MINUS\t\t\t(1 << 8)",
            "#define NUM_F_BRACKET\t\t(1 << 7)",
            "#define NUM_F_LSIGN\t\t\t(1 << 6)",
            "#define NUM_F_FILLMODE\t\t(1 << 5)",
            "#define NUM_F_BLANK\t\t\t(1 << 4)",
            "#define NUM_F_ZERO\t\t\t(1 << 3)",
            "#define NUM_F_LDECIMAL\t\t(1 << 2)",
            "#define NUM_F_DECIMAL\t\t(1 << 1)",
            "#define NODE_TYPE_ACTION\t2"
          ],
          "globals_used": [
            "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
            "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
            "static const char *get_th(char *num, int type);",
            "static char *str_numth(char *dest, char *num, int type);",
            "static char *get_last_relevant_decnum(char *num);",
            "static void NUM_numpart_to_char(NUMProc *Np, int id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_LSIGN_NONE\t0\n#define NUM_LSIGN_POST\t1\n#define NUM_LSIGN_PRE\t(-1)\n#define NUM_F_EEEE\t\t\t(1 << 14)\n#define NUM_F_MINUS_POST\t(1 << 13)\n#define NUM_F_PLUS_POST\t\t(1 << 12)\n#define NUM_F_MULTI\t\t\t(1 << 11)\n#define NUM_F_ROMAN\t\t\t(1 << 10)\n#define NUM_F_PLUS\t\t\t(1 << 9)\n#define NUM_F_MINUS\t\t\t(1 << 8)\n#define NUM_F_BRACKET\t\t(1 << 7)\n#define NUM_F_LSIGN\t\t\t(1 << 6)\n#define NUM_F_FILLMODE\t\t(1 << 5)\n#define NUM_F_BLANK\t\t\t(1 << 4)\n#define NUM_F_ZERO\t\t\t(1 << 3)\n#define NUM_F_LDECIMAL\t\t(1 << 2)\n#define NUM_F_DECIMAL\t\t(1 << 1)\n#define NODE_TYPE_ACTION\t2\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic char *get_last_relevant_decnum(char *num);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUMDesc_prepare(NUMDesc *num, FormatNode *n)\n{\n\tif (n->type != NODE_TYPE_ACTION)\n\t\treturn;\n\n\tif (IS_EEEE(num) && n->key->id != NUM_E)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"\\\"EEEE\\\" must be the last pattern used\")));\n\n\tswitch (n->key->id)\n\t{\n\t\tcase NUM_9:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"9\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t{\n\t\t\t\t++num->multi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\t++num->post;\n\t\t\telse\n\t\t\t\t++num->pre;\n\t\t\tbreak;\n\n\t\tcase NUM_0:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"0\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (!IS_ZERO(num) && !IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->flag |= NUM_F_ZERO;\n\t\t\t\tnum->zero_start = num->pre + 1;\n\t\t\t}\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t\t++num->pre;\n\t\t\telse\n\t\t\t\t++num->post;\n\n\t\t\tnum->zero_end = num->pre + num->post;\n\t\t\tbreak;\n\n\t\tcase NUM_B:\n\t\t\tif (num->pre == 0 && num->post == 0 && (!IS_ZERO(num)))\n\t\t\t\tnum->flag |= NUM_F_BLANK;\n\t\t\tbreak;\n\n\t\tcase NUM_D:\n\t\t\tnum->flag |= NUM_F_LDECIMAL;\n\t\t\tnum->need_locale = true;\n\t\t\t/* FALLTHROUGH */\n\t\tcase NUM_DEC:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"multiple decimal points\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_DECIMAL;\n\t\t\tbreak;\n\n\t\tcase NUM_FM:\n\t\t\tnum->flag |= NUM_F_FILLMODE;\n\t\t\tbreak;\n\n\t\tcase NUM_S:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" twice\")));\n\t\t\tif (IS_PLUS(num) || IS_MINUS(num) || IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\"/\\\"PR\\\" together\")));\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_PRE;\n\t\t\t\tnum->pre_lsign_num = num->pre;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\telse if (num->lsign == NUM_LSIGN_NONE)\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_POST;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NUM_MI:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"MI\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_MINUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_PL:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\" together\")));\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_PLUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_SG:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tbreak;\n\n\t\tcase NUM_PR:\n\t\t\tif (IS_LSIGN(num) || IS_PLUS(num) || IS_MINUS(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"PR\\\" and \\\"S\\\"/\\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_BRACKET;\n\t\t\tbreak;\n\n\t\tcase NUM_rn:\n\t\tcase NUM_RN:\n\t\t\tnum->flag |= NUM_F_ROMAN;\n\t\t\tbreak;\n\n\t\tcase NUM_L:\n\t\tcase NUM_G:\n\t\t\tnum->need_locale = true;\n\t\t\tbreak;\n\n\t\tcase NUM_V:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_MULTI;\n\t\t\tbreak;\n\n\t\tcase NUM_E:\n\t\t\tif (IS_EEEE(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"EEEE\\\" twice\")));\n\t\t\tif (IS_BLANK(num) || IS_FILLMODE(num) || IS_LSIGN(num) ||\n\t\t\t\tIS_BRACKET(num) || IS_MINUS(num) || IS_PLUS(num) ||\n\t\t\t\tIS_ROMAN(num) || IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"EEEE\\\" is incompatible with other formats\"),\n\t\t\t\t\t\t errdetail(\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\")));\n\t\t\tnum->flag |= NUM_F_EEEE;\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_seq_search",
          "args": [
            "str",
            "kw",
            "index"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "index_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1006-1028",
          "snippet": "static const KeyWord *\nindex_seq_search(const char *str, const KeyWord *kw, const int *index)\n{\n\tint\t\t\tpoz;\n\n\tif (!KeyWord_INDEX_FILTER(*str))\n\t\treturn NULL;\n\n\tif ((poz = *(index + (*str - ' '))) > -1)\n\t{\n\t\tconst KeyWord *k = kw + poz;\n\n\t\tdo\n\t\t{\n\t\t\tif (strncmp(str, k->name, k->len) == 0)\n\t\t\t\treturn k;\n\t\t\tk++;\n\t\t\tif (!k->name)\n\t\t\t\treturn NULL;\n\t\t} while (*str == *k->name);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
            "static int\tstrspace_len(char *str);",
            "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
            "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
            "static DCHCacheEntry *DCH_cache_search(const char *str);",
            "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
            "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
            "static NUMCacheEntry *NUM_cache_search(const char *str);",
            "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic const KeyWord *\nindex_seq_search(const char *str, const KeyWord *kw, const int *index)\n{\n\tint\t\t\tpoz;\n\n\tif (!KeyWord_INDEX_FILTER(*str))\n\t\treturn NULL;\n\n\tif ((poz = *(index + (*str - ' '))) > -1)\n\t{\n\t\tconst KeyWord *k = kw + poz;\n\n\t\tdo\n\t\t{\n\t\t\tif (strncmp(str, k->name, k->len) == 0)\n\t\t\t\treturn k;\n\t\t\tk++;\n\t\t\tif (!k->name)\n\t\t\t\treturn NULL;\n\t\t} while (*str == *k->name);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG_elog_output",
            "\"to_char/number(): run parser\""
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define SUFFTYPE_POSTFIX\t2\n#define SUFFTYPE_PREFIX\t\t1\n#define NODE_TYPE_CHAR\t\t3\n#define NODE_TYPE_ACTION\t2\n#define NODE_TYPE_END\t\t1\n#define NUM_TYPE\t\t2\t\t/* NUMBER version\t*/\n#define DCH_TYPE\t\t1\t\t/* DATE-TIME version\t*/\n#define DEBUG_elog_output\tDEBUG3\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic void parse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic void from_char_set_int(int *dest, const int value, const FormatNode *node);\nstatic int\tfrom_char_parse_int_len(int *dest, char **src, const int len, FormatNode *node);\nstatic int\tfrom_char_parse_int(int *dest, char **src, FormatNode *node);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic int\tfrom_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);\nstatic char *int_to_roman(int number);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic void\nparse_format(FormatNode *node, const char *str, const KeyWord *kw,\n\t\t\t const KeySuffix *suf, const int *index, int ver, NUMDesc *Num)\n{\n\tFormatNode *n;\n\n#ifdef DEBUG_TO_FROM_CHAR\n\telog(DEBUG_elog_output, \"to_char/number(): run parser\");\n#endif\n\n\tn = node;\n\n\twhile (*str)\n\t{\n\t\tint\t\t\tsuffix = 0;\n\t\tconst KeySuffix *s;\n\n\t\t/*\n\t\t * Prefix\n\t\t */\n\t\tif (ver == DCH_TYPE &&\n\t\t\t(s = suff_search(str, suf, SUFFTYPE_PREFIX)) != NULL)\n\t\t{\n\t\t\tsuffix |= s->id;\n\t\t\tif (s->len)\n\t\t\t\tstr += s->len;\n\t\t}\n\n\t\t/*\n\t\t * Keyword\n\t\t */\n\t\tif (*str && (n->key = index_seq_search(str, kw, index)) != NULL)\n\t\t{\n\t\t\tn->type = NODE_TYPE_ACTION;\n\t\t\tn->suffix = suffix;\n\t\t\tif (n->key->len)\n\t\t\t\tstr += n->key->len;\n\n\t\t\t/*\n\t\t\t * NUM version: Prepare global NUMDesc struct\n\t\t\t */\n\t\t\tif (ver == NUM_TYPE)\n\t\t\t\tNUMDesc_prepare(Num, n);\n\n\t\t\t/*\n\t\t\t * Postfix\n\t\t\t */\n\t\t\tif (ver == DCH_TYPE && *str &&\n\t\t\t\t(s = suff_search(str, suf, SUFFTYPE_POSTFIX)) != NULL)\n\t\t\t{\n\t\t\t\tn->suffix |= s->id;\n\t\t\t\tif (s->len)\n\t\t\t\t\tstr += s->len;\n\t\t\t}\n\n\t\t\tn++;\n\t\t}\n\t\telse if (*str)\n\t\t{\n\t\t\tint\t\t\tchlen;\n\n\t\t\t/*\n\t\t\t * Process double-quoted literal string, if any\n\t\t\t */\n\t\t\tif (*str == '\"')\n\t\t\t{\n\t\t\t\tstr++;\n\t\t\t\twhile (*str)\n\t\t\t\t{\n\t\t\t\t\tif (*str == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* backslash quotes the next character, if any */\n\t\t\t\t\tif (*str == '\\\\' && *(str + 1))\n\t\t\t\t\t\tstr++;\n\t\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\t\tn->key = NULL;\n\t\t\t\t\tn->suffix = 0;\n\t\t\t\t\tn++;\n\t\t\t\t\tstr += chlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Outside double-quoted strings, backslash is only special if\n\t\t\t\t * it immediately precedes a double quote.\n\t\t\t\t */\n\t\t\t\tif (*str == '\\\\' && *(str + 1) == '\"')\n\t\t\t\t\tstr++;\n\t\t\t\tchlen = pg_mblen(str);\n\t\t\t\tn->type = NODE_TYPE_CHAR;\n\t\t\t\tmemcpy(n->character, str, chlen);\n\t\t\t\tn->character[chlen] = '\\0';\n\t\t\t\tn->key = NULL;\n\t\t\t\tn->suffix = 0;\n\t\t\t\tn++;\n\t\t\t\tstr += chlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tn->type = NODE_TYPE_END;\n\tn->suffix = 0;\n}"
  },
  {
    "function_name": "NUMDesc_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1050-1216",
    "snippet": "static void\nNUMDesc_prepare(NUMDesc *num, FormatNode *n)\n{\n\tif (n->type != NODE_TYPE_ACTION)\n\t\treturn;\n\n\tif (IS_EEEE(num) && n->key->id != NUM_E)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"\\\"EEEE\\\" must be the last pattern used\")));\n\n\tswitch (n->key->id)\n\t{\n\t\tcase NUM_9:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"9\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t{\n\t\t\t\t++num->multi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\t++num->post;\n\t\t\telse\n\t\t\t\t++num->pre;\n\t\t\tbreak;\n\n\t\tcase NUM_0:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"0\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (!IS_ZERO(num) && !IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->flag |= NUM_F_ZERO;\n\t\t\t\tnum->zero_start = num->pre + 1;\n\t\t\t}\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t\t++num->pre;\n\t\t\telse\n\t\t\t\t++num->post;\n\n\t\t\tnum->zero_end = num->pre + num->post;\n\t\t\tbreak;\n\n\t\tcase NUM_B:\n\t\t\tif (num->pre == 0 && num->post == 0 && (!IS_ZERO(num)))\n\t\t\t\tnum->flag |= NUM_F_BLANK;\n\t\t\tbreak;\n\n\t\tcase NUM_D:\n\t\t\tnum->flag |= NUM_F_LDECIMAL;\n\t\t\tnum->need_locale = true;\n\t\t\t/* FALLTHROUGH */\n\t\tcase NUM_DEC:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"multiple decimal points\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_DECIMAL;\n\t\t\tbreak;\n\n\t\tcase NUM_FM:\n\t\t\tnum->flag |= NUM_F_FILLMODE;\n\t\t\tbreak;\n\n\t\tcase NUM_S:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" twice\")));\n\t\t\tif (IS_PLUS(num) || IS_MINUS(num) || IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\"/\\\"PR\\\" together\")));\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_PRE;\n\t\t\t\tnum->pre_lsign_num = num->pre;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\telse if (num->lsign == NUM_LSIGN_NONE)\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_POST;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NUM_MI:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"MI\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_MINUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_PL:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\" together\")));\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_PLUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_SG:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tbreak;\n\n\t\tcase NUM_PR:\n\t\t\tif (IS_LSIGN(num) || IS_PLUS(num) || IS_MINUS(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"PR\\\" and \\\"S\\\"/\\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_BRACKET;\n\t\t\tbreak;\n\n\t\tcase NUM_rn:\n\t\tcase NUM_RN:\n\t\t\tnum->flag |= NUM_F_ROMAN;\n\t\t\tbreak;\n\n\t\tcase NUM_L:\n\t\tcase NUM_G:\n\t\t\tnum->need_locale = true;\n\t\t\tbreak;\n\n\t\tcase NUM_V:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_MULTI;\n\t\t\tbreak;\n\n\t\tcase NUM_E:\n\t\t\tif (IS_EEEE(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"EEEE\\\" twice\")));\n\t\t\tif (IS_BLANK(num) || IS_FILLMODE(num) || IS_LSIGN(num) ||\n\t\t\t\tIS_BRACKET(num) || IS_MINUS(num) || IS_PLUS(num) ||\n\t\t\t\tIS_ROMAN(num) || IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"EEEE\\\" is incompatible with other formats\"),\n\t\t\t\t\t\t errdetail(\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\")));\n\t\t\tnum->flag |= NUM_F_EEEE;\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_LSIGN_NONE\t0",
      "#define NUM_LSIGN_POST\t1",
      "#define NUM_LSIGN_PRE\t(-1)",
      "#define NUM_F_EEEE\t\t\t(1 << 14)",
      "#define NUM_F_MINUS_POST\t(1 << 13)",
      "#define NUM_F_PLUS_POST\t\t(1 << 12)",
      "#define NUM_F_MULTI\t\t\t(1 << 11)",
      "#define NUM_F_ROMAN\t\t\t(1 << 10)",
      "#define NUM_F_PLUS\t\t\t(1 << 9)",
      "#define NUM_F_MINUS\t\t\t(1 << 8)",
      "#define NUM_F_BRACKET\t\t(1 << 7)",
      "#define NUM_F_LSIGN\t\t\t(1 << 6)",
      "#define NUM_F_FILLMODE\t\t(1 << 5)",
      "#define NUM_F_BLANK\t\t\t(1 << 4)",
      "#define NUM_F_ZERO\t\t\t(1 << 3)",
      "#define NUM_F_LDECIMAL\t\t(1 << 2)",
      "#define NUM_F_DECIMAL\t\t(1 << 1)",
      "#define NODE_TYPE_ACTION\t2"
    ],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static void NUMDesc_prepare(NUMDesc *num, FormatNode *n);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static char *get_last_relevant_decnum(char *num);",
      "static void NUM_numpart_to_char(NUMProc *Np, int id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"EEEE\\\" is incompatible with other formats\"),\n\t\t\t\t\t\t errdetail(\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\"))"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\""
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"EEEE\\\" is incompatible with other formats\""
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "num"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROMAN",
          "args": [
            "num"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "num"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "num"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "num"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FILLMODE",
          "args": [
            "num"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BLANK",
          "args": [
            "num"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"EEEE\\\" twice\"))"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "num"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\"))"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"PR\\\" and \\\"S\\\"/\\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\" together\"))"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "num"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "num"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"SG\\\" together\"))"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\" together\"))"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"MI\\\" together\"))"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\"/\\\"PR\\\" together\"))"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "num"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MINUS",
          "args": [
            "num"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PLUS",
          "args": [
            "num"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" twice\"))"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LSIGN",
          "args": [
            "num"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\"))"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "num"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"multiple decimal points\"))"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "num"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ZERO",
          "args": [
            "num"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"0\\\" must be ahead of \\\"PR\\\"\"))"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "num"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DECIMAL",
          "args": [
            "num"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MULTI",
          "args": [
            "num"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"9\\\" must be ahead of \\\"PR\\\"\"))"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BRACKET",
          "args": [
            "num"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"\\\"EEEE\\\" must be the last pattern used\"))"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EEEE",
          "args": [
            "num"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define NUM_LSIGN_NONE\t0\n#define NUM_LSIGN_POST\t1\n#define NUM_LSIGN_PRE\t(-1)\n#define NUM_F_EEEE\t\t\t(1 << 14)\n#define NUM_F_MINUS_POST\t(1 << 13)\n#define NUM_F_PLUS_POST\t\t(1 << 12)\n#define NUM_F_MULTI\t\t\t(1 << 11)\n#define NUM_F_ROMAN\t\t\t(1 << 10)\n#define NUM_F_PLUS\t\t\t(1 << 9)\n#define NUM_F_MINUS\t\t\t(1 << 8)\n#define NUM_F_BRACKET\t\t(1 << 7)\n#define NUM_F_LSIGN\t\t\t(1 << 6)\n#define NUM_F_FILLMODE\t\t(1 << 5)\n#define NUM_F_BLANK\t\t\t(1 << 4)\n#define NUM_F_ZERO\t\t\t(1 << 3)\n#define NUM_F_LDECIMAL\t\t(1 << 2)\n#define NUM_F_DECIMAL\t\t(1 << 1)\n#define NODE_TYPE_ACTION\t2\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic void NUMDesc_prepare(NUMDesc *num, FormatNode *n);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic char *get_last_relevant_decnum(char *num);\nstatic void NUM_numpart_to_char(NUMProc *Np, int id);\n\nstatic void\nNUMDesc_prepare(NUMDesc *num, FormatNode *n)\n{\n\tif (n->type != NODE_TYPE_ACTION)\n\t\treturn;\n\n\tif (IS_EEEE(num) && n->key->id != NUM_E)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"\\\"EEEE\\\" must be the last pattern used\")));\n\n\tswitch (n->key->id)\n\t{\n\t\tcase NUM_9:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"9\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t{\n\t\t\t\t++num->multi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\t++num->post;\n\t\t\telse\n\t\t\t\t++num->pre;\n\t\t\tbreak;\n\n\t\tcase NUM_0:\n\t\t\tif (IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"0\\\" must be ahead of \\\"PR\\\"\")));\n\t\t\tif (!IS_ZERO(num) && !IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->flag |= NUM_F_ZERO;\n\t\t\t\tnum->zero_start = num->pre + 1;\n\t\t\t}\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t\t++num->pre;\n\t\t\telse\n\t\t\t\t++num->post;\n\n\t\t\tnum->zero_end = num->pre + num->post;\n\t\t\tbreak;\n\n\t\tcase NUM_B:\n\t\t\tif (num->pre == 0 && num->post == 0 && (!IS_ZERO(num)))\n\t\t\t\tnum->flag |= NUM_F_BLANK;\n\t\t\tbreak;\n\n\t\tcase NUM_D:\n\t\t\tnum->flag |= NUM_F_LDECIMAL;\n\t\t\tnum->need_locale = true;\n\t\t\t/* FALLTHROUGH */\n\t\tcase NUM_DEC:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"multiple decimal points\")));\n\t\t\tif (IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_DECIMAL;\n\t\t\tbreak;\n\n\t\tcase NUM_FM:\n\t\t\tnum->flag |= NUM_F_FILLMODE;\n\t\t\tbreak;\n\n\t\tcase NUM_S:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" twice\")));\n\t\t\tif (IS_PLUS(num) || IS_MINUS(num) || IS_BRACKET(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\"/\\\"PR\\\" together\")));\n\t\t\tif (!IS_DECIMAL(num))\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_PRE;\n\t\t\t\tnum->pre_lsign_num = num->pre;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\telse if (num->lsign == NUM_LSIGN_NONE)\n\t\t\t{\n\t\t\t\tnum->lsign = NUM_LSIGN_POST;\n\t\t\t\tnum->need_locale = true;\n\t\t\t\tnum->flag |= NUM_F_LSIGN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NUM_MI:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"MI\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_MINUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_PL:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"PL\\\" together\")));\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tnum->flag |= NUM_F_PLUS_POST;\n\t\t\tbreak;\n\n\t\tcase NUM_SG:\n\t\t\tif (IS_LSIGN(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"S\\\" and \\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_MINUS;\n\t\t\tnum->flag |= NUM_F_PLUS;\n\t\t\tbreak;\n\n\t\tcase NUM_PR:\n\t\t\tif (IS_LSIGN(num) || IS_PLUS(num) || IS_MINUS(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"PR\\\" and \\\"S\\\"/\\\"PL\\\"/\\\"MI\\\"/\\\"SG\\\" together\")));\n\t\t\tnum->flag |= NUM_F_BRACKET;\n\t\t\tbreak;\n\n\t\tcase NUM_rn:\n\t\tcase NUM_RN:\n\t\t\tnum->flag |= NUM_F_ROMAN;\n\t\t\tbreak;\n\n\t\tcase NUM_L:\n\t\tcase NUM_G:\n\t\t\tnum->need_locale = true;\n\t\t\tbreak;\n\n\t\tcase NUM_V:\n\t\t\tif (IS_DECIMAL(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"V\\\" and decimal point together\")));\n\t\t\tnum->flag |= NUM_F_MULTI;\n\t\t\tbreak;\n\n\t\tcase NUM_E:\n\t\t\tif (IS_EEEE(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot use \\\"EEEE\\\" twice\")));\n\t\t\tif (IS_BLANK(num) || IS_FILLMODE(num) || IS_LSIGN(num) ||\n\t\t\t\tIS_BRACKET(num) || IS_MINUS(num) || IS_PLUS(num) ||\n\t\t\t\tIS_ROMAN(num) || IS_MULTI(num))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"\\\"EEEE\\\" is incompatible with other formats\"),\n\t\t\t\t\t\t errdetail(\"\\\"EEEE\\\" may only be used together with digit and decimal point patterns.\")));\n\t\t\tnum->flag |= NUM_F_EEEE;\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "suff_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1030-1044",
    "snippet": "static const KeySuffix *\nsuff_search(const char *str, const KeySuffix *suf, int type)\n{\n\tconst KeySuffix *s;\n\n\tfor (s = suf; s->name != NULL; s++)\n\t{\n\t\tif (s->type != type)\n\t\t\tcontinue;\n\n\t\tif (strncmp(str, s->name, s->len) == 0)\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);",
      "static const char *get_th(char *num, int type);",
      "static char *str_numth(char *dest, char *num, int type);",
      "static int\tstrspace_len(char *str);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "s->name",
            "s->len"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeySuffix *suff_search(const char *str, const KeySuffix *suf, int type);\nstatic const char *get_th(char *num, int type);\nstatic char *str_numth(char *dest, char *num, int type);\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic const KeySuffix *\nsuff_search(const char *str, const KeySuffix *suf, int type)\n{\n\tconst KeySuffix *s;\n\n\tfor (s = suf; s->name != NULL; s++)\n\t{\n\t\tif (s->type != type)\n\t\t\tcontinue;\n\n\t\tif (strncmp(str, s->name, s->len) == 0)\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "index_seq_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
    "lines": "1006-1028",
    "snippet": "static const KeyWord *\nindex_seq_search(const char *str, const KeyWord *kw, const int *index)\n{\n\tint\t\t\tpoz;\n\n\tif (!KeyWord_INDEX_FILTER(*str))\n\t\treturn NULL;\n\n\tif ((poz = *(index + (*str - ' '))) > -1)\n\t{\n\t\tconst KeyWord *k = kw + poz;\n\n\t\tdo\n\t\t{\n\t\t\tif (strncmp(str, k->name, k->len) == 0)\n\t\t\t\treturn k;\n\t\t\tk++;\n\t\t\tif (!k->name)\n\t\t\t\treturn NULL;\n\t\t} while (*str == *k->name);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/int8.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <unicode/ustring.h>",
      "#include <wctype.h>",
      "#include <wchar.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <math.h>",
      "#include <unistd.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);",
      "static int\tstrspace_len(char *str);",
      "static int\tseq_search(char *name, const char *const *array, int type, int max, int *len);",
      "static DCHCacheEntry *DCH_cache_getnew(const char *str);",
      "static DCHCacheEntry *DCH_cache_search(const char *str);",
      "static DCHCacheEntry *DCH_cache_fetch(const char *str);",
      "static NUMCacheEntry *NUM_cache_getnew(const char *str);",
      "static NUMCacheEntry *NUM_cache_search(const char *str);",
      "static NUMCacheEntry *NUM_cache_fetch(const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "k->name",
            "k->len"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeyWord_INDEX_FILTER",
          "args": [
            "*str"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const KeyWord *index_seq_search(const char *str, const KeyWord *kw,\n\t\t\t\t const int *index);\nstatic int\tstrspace_len(char *str);\nstatic int\tseq_search(char *name, const char *const *array, int type, int max, int *len);\nstatic DCHCacheEntry *DCH_cache_getnew(const char *str);\nstatic DCHCacheEntry *DCH_cache_search(const char *str);\nstatic DCHCacheEntry *DCH_cache_fetch(const char *str);\nstatic NUMCacheEntry *NUM_cache_getnew(const char *str);\nstatic NUMCacheEntry *NUM_cache_search(const char *str);\nstatic NUMCacheEntry *NUM_cache_fetch(const char *str);\n\nstatic const KeyWord *\nindex_seq_search(const char *str, const KeyWord *kw, const int *index)\n{\n\tint\t\t\tpoz;\n\n\tif (!KeyWord_INDEX_FILTER(*str))\n\t\treturn NULL;\n\n\tif ((poz = *(index + (*str - ' '))) > -1)\n\t{\n\t\tconst KeyWord *k = kw + poz;\n\n\t\tdo\n\t\t{\n\t\t\tif (strncmp(str, k->name, k->len) == 0)\n\t\t\t\treturn k;\n\t\t\tk++;\n\t\t\tif (!k->name)\n\t\t\t\treturn NULL;\n\t\t} while (*str == *k->name);\n\t}\n\treturn NULL;\n}"
  }
]