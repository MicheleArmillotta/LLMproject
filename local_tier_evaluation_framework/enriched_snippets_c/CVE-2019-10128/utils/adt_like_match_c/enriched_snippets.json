[
  {
    "function_name": "do_like_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like_match.c",
    "lines": "247-339",
    "snippet": "static text *\ndo_like_escape(text *pat, text *esc)\n{\n\ttext\t   *result;\n\tchar\t   *p,\n\t\t\t   *e,\n\t\t\t   *r;\n\tint\t\t\tplen,\n\t\t\t\telen;\n\tbool\t\tafterescape;\n\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\te = VARDATA_ANY(esc);\n\telen = VARSIZE_ANY_EXHDR(esc);\n\n\t/*\n\t * Worst-case pattern growth is 2x --- unlikely, but it's hardly worth\n\t * trying to calculate the size more accurately than that.\n\t */\n\tresult = (text *) palloc(plen * 2 + VARHDRSZ);\n\tr = VARDATA(result);\n\n\tif (elen == 0)\n\t{\n\t\t/*\n\t\t * No escape character is wanted.  Double any backslashes in the\n\t\t * pattern to make them act like ordinary characters.\n\t\t */\n\t\twhile (plen > 0)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\t*r++ = '\\\\';\n\t\t\tCopyAdvChar(r, p, plen);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * The specified escape must be only a single character.\n\t\t */\n\t\tNextChar(e, elen);\n\t\tif (elen != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t errhint(\"Escape string must be empty or one character.\")));\n\n\t\te = VARDATA_ANY(esc);\n\n\t\t/*\n\t\t * If specified escape is '\\', just copy the pattern as-is.\n\t\t */\n\t\tif (*e == '\\\\')\n\t\t{\n\t\t\tmemcpy(result, pat, VARSIZE_ANY(pat));\n\t\t\treturn result;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, convert occurrences of the specified escape character to\n\t\t * '\\', and double occurrences of '\\' --- unless they immediately\n\t\t * follow an escape character!\n\t\t */\n\t\tafterescape = false;\n\t\twhile (plen > 0)\n\t\t{\n\t\t\tif (CHAREQ(p, e) && !afterescape)\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\tNextChar(p, plen);\n\t\t\t\tafterescape = true;\n\t\t\t}\n\t\t\telse if (*p == '\\\\')\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\tif (!afterescape)\n\t\t\t\t\t*r++ = '\\\\';\n\t\t\t\tNextChar(p, plen);\n\t\t\t\tafterescape = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCopyAdvChar(r, p, plen);\n\t\t\t\tafterescape = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tSET_VARSIZE(result, r - ((char *) result));\n\n\treturn result;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "r - ((char *) result)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopyAdvChar",
          "args": [
            "r",
            "p",
            "plen"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "p",
            "plen"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "p",
            "plen"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHAREQ",
          "args": [
            "p",
            "e"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "pat",
            "VARSIZE_ANY(pat)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "pat"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "esc"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t errhint(\"Escape string must be empty or one character.\"))"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Escape string must be empty or one character.\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid escape string\""
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ESCAPE_SEQUENCE"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "e",
            "elen"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopyAdvChar",
          "args": [
            "r",
            "p",
            "plen"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "plen * 2 + VARHDRSZ"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "esc"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "esc"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static text *\ndo_like_escape(text *pat, text *esc)\n{\n\ttext\t   *result;\n\tchar\t   *p,\n\t\t\t   *e,\n\t\t\t   *r;\n\tint\t\t\tplen,\n\t\t\t\telen;\n\tbool\t\tafterescape;\n\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\te = VARDATA_ANY(esc);\n\telen = VARSIZE_ANY_EXHDR(esc);\n\n\t/*\n\t * Worst-case pattern growth is 2x --- unlikely, but it's hardly worth\n\t * trying to calculate the size more accurately than that.\n\t */\n\tresult = (text *) palloc(plen * 2 + VARHDRSZ);\n\tr = VARDATA(result);\n\n\tif (elen == 0)\n\t{\n\t\t/*\n\t\t * No escape character is wanted.  Double any backslashes in the\n\t\t * pattern to make them act like ordinary characters.\n\t\t */\n\t\twhile (plen > 0)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\t*r++ = '\\\\';\n\t\t\tCopyAdvChar(r, p, plen);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * The specified escape must be only a single character.\n\t\t */\n\t\tNextChar(e, elen);\n\t\tif (elen != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t errmsg(\"invalid escape string\"),\n\t\t\t\t\t errhint(\"Escape string must be empty or one character.\")));\n\n\t\te = VARDATA_ANY(esc);\n\n\t\t/*\n\t\t * If specified escape is '\\', just copy the pattern as-is.\n\t\t */\n\t\tif (*e == '\\\\')\n\t\t{\n\t\t\tmemcpy(result, pat, VARSIZE_ANY(pat));\n\t\t\treturn result;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, convert occurrences of the specified escape character to\n\t\t * '\\', and double occurrences of '\\' --- unless they immediately\n\t\t * follow an escape character!\n\t\t */\n\t\tafterescape = false;\n\t\twhile (plen > 0)\n\t\t{\n\t\t\tif (CHAREQ(p, e) && !afterescape)\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\tNextChar(p, plen);\n\t\t\t\tafterescape = true;\n\t\t\t}\n\t\t\telse if (*p == '\\\\')\n\t\t\t{\n\t\t\t\t*r++ = '\\\\';\n\t\t\t\tif (!afterescape)\n\t\t\t\t\t*r++ = '\\\\';\n\t\t\t\tNextChar(p, plen);\n\t\t\t\tafterescape = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCopyAdvChar(r, p, plen);\n\t\t\t\tafterescape = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tSET_VARSIZE(result, r - ((char *) result));\n\n\treturn result;\n}"
  },
  {
    "function_name": "MatchText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like_match.c",
    "lines": "78-239",
    "snippet": "static int\nMatchText(char *t, int tlen, char *p, int plen,\n\t\t  pg_locale_t locale, bool locale_is_c)\n{\n\t/* Fast path for match-everything pattern */\n\tif (plen == 1 && *p == '%')\n\t\treturn LIKE_TRUE;\n\n\t/* Since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\t/*\n\t * In this loop, we advance by char when matching wildcards (and thus on\n\t * recursive entry to this function we are properly char-synced). On other\n\t * occasions it is safe to advance by byte, as the text and pattern will\n\t * be in lockstep. This allows us to perform all comparisons between the\n\t * text and pattern on a byte by byte basis, even for multi-byte\n\t * encodings.\n\t */\n\twhile (tlen > 0 && plen > 0)\n\t{\n\t\tif (*p == '\\\\')\n\t\t{\n\t\t\t/* Next pattern byte must match literally, whatever it is */\n\t\t\tNextByte(p, plen);\n\t\t\t/* ... and there had better be one, per SQL standard */\n\t\t\tif (plen <= 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\tif (GETCHAR(*p) != GETCHAR(*t))\n\t\t\t\treturn LIKE_FALSE;\n\t\t}\n\t\telse if (*p == '%')\n\t\t{\n\t\t\tchar\t\tfirstpat;\n\n\t\t\t/*\n\t\t\t * % processing is essentially a search for a text position at\n\t\t\t * which the remainder of the text matches the remainder of the\n\t\t\t * pattern, using a recursive call to check each potential match.\n\t\t\t *\n\t\t\t * If there are wildcards immediately following the %, we can skip\n\t\t\t * over them first, using the idea that any sequence of N _'s and\n\t\t\t * one or more %'s is equivalent to N _'s and one % (ie, it will\n\t\t\t * match any sequence of at least N text characters).  In this way\n\t\t\t * we will always run the recursive search loop using a pattern\n\t\t\t * fragment that begins with a literal character-to-match, thereby\n\t\t\t * not recursing more than we have to.\n\t\t\t */\n\t\t\tNextByte(p, plen);\n\n\t\t\twhile (plen > 0)\n\t\t\t{\n\t\t\t\tif (*p == '%')\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\telse if (*p == '_')\n\t\t\t\t{\n\t\t\t\t\t/* If not enough text left to match the pattern, ABORT */\n\t\t\t\t\tif (tlen <= 0)\n\t\t\t\t\t\treturn LIKE_ABORT;\n\t\t\t\t\tNextChar(t, tlen);\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\t\t/* Reached a non-wildcard pattern char */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we're at end of pattern, match: we have a trailing % which\n\t\t\t * matches any remaining text string.\n\t\t\t */\n\t\t\tif (plen <= 0)\n\t\t\t\treturn LIKE_TRUE;\n\n\t\t\t/*\n\t\t\t * Otherwise, scan for a text position at which we can match the\n\t\t\t * rest of the pattern.  The first remaining pattern char is known\n\t\t\t * to be a regular or escaped literal character, so we can compare\n\t\t\t * the first pattern byte to each text byte to avoid recursing\n\t\t\t * more than we have to.  This fact also guarantees that we don't\n\t\t\t * have to consider a match to the zero-length substring at the\n\t\t\t * end of the text.\n\t\t\t */\n\t\t\tif (*p == '\\\\')\n\t\t\t{\n\t\t\t\tif (plen < 2)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\t\tfirstpat = GETCHAR(p[1]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirstpat = GETCHAR(*p);\n\n\t\t\twhile (tlen > 0)\n\t\t\t{\n\t\t\t\tif (GETCHAR(*t) == firstpat)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched = MatchText(t, tlen, p, plen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocale, locale_is_c);\n\n\t\t\t\t\tif (matched != LIKE_FALSE)\n\t\t\t\t\t\treturn matched; /* TRUE or ABORT */\n\t\t\t\t}\n\n\t\t\t\tNextChar(t, tlen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * End of text with no match, so no point in trying later places\n\t\t\t * to start matching this pattern.\n\t\t\t */\n\t\t\treturn LIKE_ABORT;\n\t\t}\n\t\telse if (*p == '_')\n\t\t{\n\t\t\t/* _ matches any single character, and we know there is one */\n\t\t\tNextChar(t, tlen);\n\t\t\tNextByte(p, plen);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (GETCHAR(*p) != GETCHAR(*t))\n\t\t{\n\t\t\t/* non-wildcard pattern char fails to match text char */\n\t\t\treturn LIKE_FALSE;\n\t\t}\n\n\t\t/*\n\t\t * Pattern and text match, so advance.\n\t\t *\n\t\t * It is safe to use NextByte instead of NextChar here, even for\n\t\t * multi-byte character sets, because we are not following immediately\n\t\t * after a wildcard character. If we are in the middle of a multibyte\n\t\t * character, we must already have matched at least one byte of the\n\t\t * character from both text and pattern; so we cannot get out-of-sync\n\t\t * on character boundaries.  And we know that no backend-legal\n\t\t * encoding allows ASCII characters such as '%' to appear as non-first\n\t\t * bytes of characters, so we won't mistakenly detect a new wildcard.\n\t\t */\n\t\tNextByte(t, tlen);\n\t\tNextByte(p, plen);\n\t}\n\n\tif (tlen > 0)\n\t\treturn LIKE_FALSE;\t\t/* end of pattern, but not of text */\n\n\t/*\n\t * End of text, but perhaps not of pattern.  Match iff the remaining\n\t * pattern can match a zero-length string, ie, it's zero or more %'s.\n\t */\n\twhile (plen > 0 && *p == '%')\n\t\tNextByte(p, plen);\n\tif (plen <= 0)\n\t\treturn LIKE_TRUE;\n\n\t/*\n\t * End of text with no match, so no point in trying later places to start\n\t * matching this pattern.\n\t */\n\treturn LIKE_ABORT;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "t",
            "tlen"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*t"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*p"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "t",
            "tlen"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "t",
            "tlen"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MatchText",
          "args": [
            "t",
            "tlen",
            "p",
            "plen",
            "locale",
            "locale_is_c"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "MatchText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like_match.c",
          "lines": "78-239",
          "snippet": "static int\nMatchText(char *t, int tlen, char *p, int plen,\n\t\t  pg_locale_t locale, bool locale_is_c)\n{\n\t/* Fast path for match-everything pattern */\n\tif (plen == 1 && *p == '%')\n\t\treturn LIKE_TRUE;\n\n\t/* Since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\t/*\n\t * In this loop, we advance by char when matching wildcards (and thus on\n\t * recursive entry to this function we are properly char-synced). On other\n\t * occasions it is safe to advance by byte, as the text and pattern will\n\t * be in lockstep. This allows us to perform all comparisons between the\n\t * text and pattern on a byte by byte basis, even for multi-byte\n\t * encodings.\n\t */\n\twhile (tlen > 0 && plen > 0)\n\t{\n\t\tif (*p == '\\\\')\n\t\t{\n\t\t\t/* Next pattern byte must match literally, whatever it is */\n\t\t\tNextByte(p, plen);\n\t\t\t/* ... and there had better be one, per SQL standard */\n\t\t\tif (plen <= 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\tif (GETCHAR(*p) != GETCHAR(*t))\n\t\t\t\treturn LIKE_FALSE;\n\t\t}\n\t\telse if (*p == '%')\n\t\t{\n\t\t\tchar\t\tfirstpat;\n\n\t\t\t/*\n\t\t\t * % processing is essentially a search for a text position at\n\t\t\t * which the remainder of the text matches the remainder of the\n\t\t\t * pattern, using a recursive call to check each potential match.\n\t\t\t *\n\t\t\t * If there are wildcards immediately following the %, we can skip\n\t\t\t * over them first, using the idea that any sequence of N _'s and\n\t\t\t * one or more %'s is equivalent to N _'s and one % (ie, it will\n\t\t\t * match any sequence of at least N text characters).  In this way\n\t\t\t * we will always run the recursive search loop using a pattern\n\t\t\t * fragment that begins with a literal character-to-match, thereby\n\t\t\t * not recursing more than we have to.\n\t\t\t */\n\t\t\tNextByte(p, plen);\n\n\t\t\twhile (plen > 0)\n\t\t\t{\n\t\t\t\tif (*p == '%')\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\telse if (*p == '_')\n\t\t\t\t{\n\t\t\t\t\t/* If not enough text left to match the pattern, ABORT */\n\t\t\t\t\tif (tlen <= 0)\n\t\t\t\t\t\treturn LIKE_ABORT;\n\t\t\t\t\tNextChar(t, tlen);\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\t\t/* Reached a non-wildcard pattern char */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we're at end of pattern, match: we have a trailing % which\n\t\t\t * matches any remaining text string.\n\t\t\t */\n\t\t\tif (plen <= 0)\n\t\t\t\treturn LIKE_TRUE;\n\n\t\t\t/*\n\t\t\t * Otherwise, scan for a text position at which we can match the\n\t\t\t * rest of the pattern.  The first remaining pattern char is known\n\t\t\t * to be a regular or escaped literal character, so we can compare\n\t\t\t * the first pattern byte to each text byte to avoid recursing\n\t\t\t * more than we have to.  This fact also guarantees that we don't\n\t\t\t * have to consider a match to the zero-length substring at the\n\t\t\t * end of the text.\n\t\t\t */\n\t\t\tif (*p == '\\\\')\n\t\t\t{\n\t\t\t\tif (plen < 2)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\t\tfirstpat = GETCHAR(p[1]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirstpat = GETCHAR(*p);\n\n\t\t\twhile (tlen > 0)\n\t\t\t{\n\t\t\t\tif (GETCHAR(*t) == firstpat)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched = MatchText(t, tlen, p, plen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocale, locale_is_c);\n\n\t\t\t\t\tif (matched != LIKE_FALSE)\n\t\t\t\t\t\treturn matched; /* TRUE or ABORT */\n\t\t\t\t}\n\n\t\t\t\tNextChar(t, tlen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * End of text with no match, so no point in trying later places\n\t\t\t * to start matching this pattern.\n\t\t\t */\n\t\t\treturn LIKE_ABORT;\n\t\t}\n\t\telse if (*p == '_')\n\t\t{\n\t\t\t/* _ matches any single character, and we know there is one */\n\t\t\tNextChar(t, tlen);\n\t\t\tNextByte(p, plen);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (GETCHAR(*p) != GETCHAR(*t))\n\t\t{\n\t\t\t/* non-wildcard pattern char fails to match text char */\n\t\t\treturn LIKE_FALSE;\n\t\t}\n\n\t\t/*\n\t\t * Pattern and text match, so advance.\n\t\t *\n\t\t * It is safe to use NextByte instead of NextChar here, even for\n\t\t * multi-byte character sets, because we are not following immediately\n\t\t * after a wildcard character. If we are in the middle of a multibyte\n\t\t * character, we must already have matched at least one byte of the\n\t\t * character from both text and pattern; so we cannot get out-of-sync\n\t\t * on character boundaries.  And we know that no backend-legal\n\t\t * encoding allows ASCII characters such as '%' to appear as non-first\n\t\t * bytes of characters, so we won't mistakenly detect a new wildcard.\n\t\t */\n\t\tNextByte(t, tlen);\n\t\tNextByte(p, plen);\n\t}\n\n\tif (tlen > 0)\n\t\treturn LIKE_FALSE;\t\t/* end of pattern, but not of text */\n\n\t/*\n\t * End of text, but perhaps not of pattern.  Match iff the remaining\n\t * pattern can match a zero-length string, ie, it's zero or more %'s.\n\t */\n\twhile (plen > 0 && *p == '%')\n\t\tNextByte(p, plen);\n\tif (plen <= 0)\n\t\treturn LIKE_TRUE;\n\n\t/*\n\t * End of text with no match, so no point in trying later places to start\n\t * matching this pattern.\n\t */\n\treturn LIKE_ABORT;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*t"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*p"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "p[1]"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\"))"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"LIKE pattern must not end with escape character\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_ESCAPE_SEQUENCE"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextChar",
          "args": [
            "t",
            "tlen"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*t"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETCHAR",
          "args": [
            "*p"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\"))"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextByte",
          "args": [
            "p",
            "plen"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int\nMatchText(char *t, int tlen, char *p, int plen,\n\t\t  pg_locale_t locale, bool locale_is_c)\n{\n\t/* Fast path for match-everything pattern */\n\tif (plen == 1 && *p == '%')\n\t\treturn LIKE_TRUE;\n\n\t/* Since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\t/*\n\t * In this loop, we advance by char when matching wildcards (and thus on\n\t * recursive entry to this function we are properly char-synced). On other\n\t * occasions it is safe to advance by byte, as the text and pattern will\n\t * be in lockstep. This allows us to perform all comparisons between the\n\t * text and pattern on a byte by byte basis, even for multi-byte\n\t * encodings.\n\t */\n\twhile (tlen > 0 && plen > 0)\n\t{\n\t\tif (*p == '\\\\')\n\t\t{\n\t\t\t/* Next pattern byte must match literally, whatever it is */\n\t\t\tNextByte(p, plen);\n\t\t\t/* ... and there had better be one, per SQL standard */\n\t\t\tif (plen <= 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\tif (GETCHAR(*p) != GETCHAR(*t))\n\t\t\t\treturn LIKE_FALSE;\n\t\t}\n\t\telse if (*p == '%')\n\t\t{\n\t\t\tchar\t\tfirstpat;\n\n\t\t\t/*\n\t\t\t * % processing is essentially a search for a text position at\n\t\t\t * which the remainder of the text matches the remainder of the\n\t\t\t * pattern, using a recursive call to check each potential match.\n\t\t\t *\n\t\t\t * If there are wildcards immediately following the %, we can skip\n\t\t\t * over them first, using the idea that any sequence of N _'s and\n\t\t\t * one or more %'s is equivalent to N _'s and one % (ie, it will\n\t\t\t * match any sequence of at least N text characters).  In this way\n\t\t\t * we will always run the recursive search loop using a pattern\n\t\t\t * fragment that begins with a literal character-to-match, thereby\n\t\t\t * not recursing more than we have to.\n\t\t\t */\n\t\t\tNextByte(p, plen);\n\n\t\t\twhile (plen > 0)\n\t\t\t{\n\t\t\t\tif (*p == '%')\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\telse if (*p == '_')\n\t\t\t\t{\n\t\t\t\t\t/* If not enough text left to match the pattern, ABORT */\n\t\t\t\t\tif (tlen <= 0)\n\t\t\t\t\t\treturn LIKE_ABORT;\n\t\t\t\t\tNextChar(t, tlen);\n\t\t\t\t\tNextByte(p, plen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\t\t/* Reached a non-wildcard pattern char */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we're at end of pattern, match: we have a trailing % which\n\t\t\t * matches any remaining text string.\n\t\t\t */\n\t\t\tif (plen <= 0)\n\t\t\t\treturn LIKE_TRUE;\n\n\t\t\t/*\n\t\t\t * Otherwise, scan for a text position at which we can match the\n\t\t\t * rest of the pattern.  The first remaining pattern char is known\n\t\t\t * to be a regular or escaped literal character, so we can compare\n\t\t\t * the first pattern byte to each text byte to avoid recursing\n\t\t\t * more than we have to.  This fact also guarantees that we don't\n\t\t\t * have to consider a match to the zero-length substring at the\n\t\t\t * end of the text.\n\t\t\t */\n\t\t\tif (*p == '\\\\')\n\t\t\t{\n\t\t\t\tif (plen < 2)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_ESCAPE_SEQUENCE),\n\t\t\t\t\t\t\t errmsg(\"LIKE pattern must not end with escape character\")));\n\t\t\t\tfirstpat = GETCHAR(p[1]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfirstpat = GETCHAR(*p);\n\n\t\t\twhile (tlen > 0)\n\t\t\t{\n\t\t\t\tif (GETCHAR(*t) == firstpat)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tmatched = MatchText(t, tlen, p, plen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocale, locale_is_c);\n\n\t\t\t\t\tif (matched != LIKE_FALSE)\n\t\t\t\t\t\treturn matched; /* TRUE or ABORT */\n\t\t\t\t}\n\n\t\t\t\tNextChar(t, tlen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * End of text with no match, so no point in trying later places\n\t\t\t * to start matching this pattern.\n\t\t\t */\n\t\t\treturn LIKE_ABORT;\n\t\t}\n\t\telse if (*p == '_')\n\t\t{\n\t\t\t/* _ matches any single character, and we know there is one */\n\t\t\tNextChar(t, tlen);\n\t\t\tNextByte(p, plen);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (GETCHAR(*p) != GETCHAR(*t))\n\t\t{\n\t\t\t/* non-wildcard pattern char fails to match text char */\n\t\t\treturn LIKE_FALSE;\n\t\t}\n\n\t\t/*\n\t\t * Pattern and text match, so advance.\n\t\t *\n\t\t * It is safe to use NextByte instead of NextChar here, even for\n\t\t * multi-byte character sets, because we are not following immediately\n\t\t * after a wildcard character. If we are in the middle of a multibyte\n\t\t * character, we must already have matched at least one byte of the\n\t\t * character from both text and pattern; so we cannot get out-of-sync\n\t\t * on character boundaries.  And we know that no backend-legal\n\t\t * encoding allows ASCII characters such as '%' to appear as non-first\n\t\t * bytes of characters, so we won't mistakenly detect a new wildcard.\n\t\t */\n\t\tNextByte(t, tlen);\n\t\tNextByte(p, plen);\n\t}\n\n\tif (tlen > 0)\n\t\treturn LIKE_FALSE;\t\t/* end of pattern, but not of text */\n\n\t/*\n\t * End of text, but perhaps not of pattern.  Match iff the remaining\n\t * pattern can match a zero-length string, ie, it's zero or more %'s.\n\t */\n\twhile (plen > 0 && *p == '%')\n\t\tNextByte(p, plen);\n\tif (plen <= 0)\n\t\treturn LIKE_TRUE;\n\n\t/*\n\t * End of text with no match, so no point in trying later places to start\n\t * matching this pattern.\n\t */\n\treturn LIKE_ABORT;\n}"
  }
]