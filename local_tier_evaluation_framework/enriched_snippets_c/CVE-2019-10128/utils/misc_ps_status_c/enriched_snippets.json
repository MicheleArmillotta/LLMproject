[
  {
    "function_name": "get_ps_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
    "lines": "404-419",
    "snippet": "const char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}",
    "includes": [
      "#include \"utils/guc.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/libpq.h\"",
      "#include <crt_externs.h>",
      "#include <sys/exec.h>",
      "#include <machine/vmparam.h>\t/* for old BSD */",
      "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
      "#include <unistd.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PS_USE_CLOBBER_ARGV"
    ],
    "globals_used": [
      "static size_t ps_buffer_cur_len;",
      "static size_t ps_buffer_fixed_size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_USE_CLOBBER_ARGV\n\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nconst char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}"
  },
  {
    "function_name": "set_ps_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
    "lines": "325-395",
    "snippet": "void\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}",
    "includes": [
      "#include \"utils/guc.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/libpq.h\"",
      "#include <crt_externs.h>",
      "#include <sys/exec.h>",
      "#include <machine/vmparam.h>\t/* for old BSD */",
      "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
      "#include <unistd.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PS_BUFFER_SIZE 256",
      "#define PS_PADDING ' '",
      "#define PS_PADDING '\\0'",
      "#define PS_USE_NONE",
      "#define PS_USE_WIN32",
      "#define PS_USE_CLOBBER_ARGV",
      "#define PS_USE_PS_STRINGS",
      "#define PS_USE_PSTAT",
      "#define PS_USE_SETPROCTITLE"
    ],
    "globals_used": [
      "bool\t\tupdate_process_title = true;",
      "static size_t ps_buffer_cur_len;",
      "static size_t ps_buffer_fixed_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateEvent",
          "args": [
            "NULL",
            "TRUE",
            "FALSE",
            "name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"pgident(%d): %s\"",
            "MyProcPid",
            "ps_buffer"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "ident_handle"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "ps_buffer + ps_buffer_cur_len",
            "PS_PADDING",
            "last_status_len - ps_buffer_cur_len"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstat",
          "args": [
            "PSTAT_SETCMD",
            "pst",
            "ps_buffer_cur_len",
            "0",
            "0"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "\"%s\"",
            "ps_buffer"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ps_buffer"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ps_buffer + ps_buffer_fixed_size",
            "activity",
            "ps_buffer_size - ps_buffer_fixed_size"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_safe_strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ascii.c",
          "lines": "172-198",
          "snippet": "void\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/ascii.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/ascii.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nascii_safe_strlcpy(char *dest, const char *src, size_t destsiz)\n{\n\tif (destsiz == 0)\t\t\t/* corner case: no room for trailing nul */\n\t\treturn;\n\n\twhile (--destsiz > 0)\n\t{\n\t\t/* use unsigned char here to avoid compiler warning */\n\t\tunsigned char ch = *src++;\n\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\t/* Keep printable ASCII characters */\n\t\tif (32 <= ch && ch <= 127)\n\t\t\t*dest = ch;\n\t\t/* White-space is also OK */\n\t\telse if (ch == '\\n' || ch == '\\r' || ch == '\\t')\n\t\t\t*dest = ch;\n\t\t/* Everything else is replaced with '?' */\n\t\telse\n\t\t\t*dest = '?';\n\t\tdest++;\n\t}\n\n\t*dest = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_BUFFER_SIZE 256\n#define PS_PADDING ' '\n#define PS_PADDING '\\0'\n#define PS_USE_NONE\n#define PS_USE_WIN32\n#define PS_USE_CLOBBER_ARGV\n#define PS_USE_PS_STRINGS\n#define PS_USE_PSTAT\n#define PS_USE_SETPROCTITLE\n\nbool\t\tupdate_process_title = true;\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nvoid\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}"
  },
  {
    "function_name": "init_ps_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
    "lines": "243-317",
    "snippet": "void\ninit_ps_display(const char *username, const char *dbname,\n\t\t\t\tconst char *host_info, const char *initial_str)\n{\n\tAssert(username);\n\tAssert(dbname);\n\tAssert(host_info);\n\n#ifndef PS_USE_NONE\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\t/* no ps display if you didn't call save_ps_display_args() */\n\tif (!save_argv)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/*\n\t * Overwrite argv[] to point at appropriate space, if needed\n\t */\n\n#ifdef PS_USE_CHANGE_ARGV\n\tsave_argv[0] = ps_buffer;\n\tsave_argv[1] = NULL;\n#endif\t\t\t\t\t\t\t/* PS_USE_CHANGE_ARGV */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t{\n\t\tint\t\t\ti;\n\n\t\t/* make extra argv slots point at end_of_area (a NUL) */\n\t\tfor (i = 1; i < save_argc; i++)\n\t\t\tsave_argv[i] = ps_buffer + ps_buffer_size;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n\t/*\n\t * Make fixed prefix of ps display.\n\t */\n\n#ifdef PS_USE_SETPROCTITLE\n\n\t/*\n\t * apparently setproctitle() already adds a `progname:' prefix to the ps\n\t * line\n\t */\n#define PROGRAM_NAME_PREFIX \"\"\n#else\n#define PROGRAM_NAME_PREFIX \"postgres: \"\n#endif\n\n\tif (*cluster_name == '\\0')\n\t{\n\t\tsnprintf(ps_buffer, ps_buffer_size,\n\t\t\t\t PROGRAM_NAME_PREFIX \"%s %s %s \",\n\t\t\t\t username, dbname, host_info);\n\t}\n\telse\n\t{\n\t\tsnprintf(ps_buffer, ps_buffer_size,\n\t\t\t\t PROGRAM_NAME_PREFIX \"%s: %s %s %s \",\n\t\t\t\t cluster_name, username, dbname, host_info);\n\t}\n\n\tps_buffer_cur_len = ps_buffer_fixed_size = strlen(ps_buffer);\n\n\tset_ps_display(initial_str, true);\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}",
    "includes": [
      "#include \"utils/guc.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/libpq.h\"",
      "#include <crt_externs.h>",
      "#include <sys/exec.h>",
      "#include <machine/vmparam.h>\t/* for old BSD */",
      "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
      "#include <unistd.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PROGRAM_NAME_PREFIX \"postgres: \"",
      "#define PROGRAM_NAME_PREFIX \"\"",
      "#define PS_USE_NONE",
      "#define PS_USE_CLOBBER_ARGV",
      "#define PS_USE_CHANGE_ARGV",
      "#define PS_USE_SETPROCTITLE"
    ],
    "globals_used": [
      "static size_t ps_buffer_cur_len;",
      "static size_t ps_buffer_fixed_size;",
      "static int\tsave_argc;",
      "static char **save_argv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ps_display",
          "args": [
            "initial_str",
            "true"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "set_ps_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
          "lines": "325-395",
          "snippet": "void\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}",
          "includes": [
            "#include \"utils/guc.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/libpq.h\"",
            "#include <crt_externs.h>",
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PS_BUFFER_SIZE 256",
            "#define PS_PADDING ' '",
            "#define PS_PADDING '\\0'",
            "#define PS_USE_NONE",
            "#define PS_USE_WIN32",
            "#define PS_USE_CLOBBER_ARGV",
            "#define PS_USE_PS_STRINGS",
            "#define PS_USE_PSTAT",
            "#define PS_USE_SETPROCTITLE"
          ],
          "globals_used": [
            "bool\t\tupdate_process_title = true;",
            "static size_t ps_buffer_cur_len;",
            "static size_t ps_buffer_fixed_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_BUFFER_SIZE 256\n#define PS_PADDING ' '\n#define PS_PADDING '\\0'\n#define PS_USE_NONE\n#define PS_USE_WIN32\n#define PS_USE_CLOBBER_ARGV\n#define PS_USE_PS_STRINGS\n#define PS_USE_PSTAT\n#define PS_USE_SETPROCTITLE\n\nbool\t\tupdate_process_title = true;\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nvoid\nset_ps_display(const char *activity, bool force)\n{\n#ifndef PS_USE_NONE\n\t/* update_process_title=off disables updates, unless force = true */\n\tif (!force && !update_process_title)\n\t\treturn;\n\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/* Update ps_buffer to contain both fixed part and activity */\n\tstrlcpy(ps_buffer + ps_buffer_fixed_size, activity,\n\t\t\tps_buffer_size - ps_buffer_fixed_size);\n\tps_buffer_cur_len = strlen(ps_buffer);\n\n\t/* Transmit new setting to kernel, if necessary */\n\n#ifdef PS_USE_SETPROCTITLE\n\tsetproctitle(\"%s\", ps_buffer);\n#endif\n\n#ifdef PS_USE_PSTAT\n\t{\n\t\tunion pstun pst;\n\n\t\tpst.pst_command = ps_buffer;\n\t\tpstat(PSTAT_SETCMD, pst, ps_buffer_cur_len, 0, 0);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_PSTAT */\n\n#ifdef PS_USE_PS_STRINGS\n\tPS_STRINGS->ps_nargvstr = 1;\n\tPS_STRINGS->ps_argvstr = ps_buffer;\n#endif\t\t\t\t\t\t\t/* PS_USE_PS_STRINGS */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* pad unused memory; need only clobber remainder of old status string */\n\tif (last_status_len > ps_buffer_cur_len)\n\t\tMemSet(ps_buffer + ps_buffer_cur_len, PS_PADDING,\n\t\t\t   last_status_len - ps_buffer_cur_len);\n\tlast_status_len = ps_buffer_cur_len;\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#ifdef PS_USE_WIN32\n\t{\n\t\t/*\n\t\t * Win32 does not support showing any changed arguments. To make it at\n\t\t * all possible to track which backend is doing what, we create a\n\t\t * named object that can be viewed with for example Process Explorer.\n\t\t */\n\t\tstatic HANDLE ident_handle = INVALID_HANDLE_VALUE;\n\t\tchar\t\tname[PS_BUFFER_SIZE + 32];\n\n\t\tif (ident_handle != INVALID_HANDLE_VALUE)\n\t\t\tCloseHandle(ident_handle);\n\n\t\tsprintf(name, \"pgident(%d): %s\", MyProcPid, ps_buffer);\n\n\t\tident_handle = CreateEvent(NULL, TRUE, FALSE, name);\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_WIN32 */\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ps_buffer"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ps_buffer",
            "ps_buffer_size",
            "PROGRAM_NAME_PREFIX \"%s: %s %s %s \"",
            "cluster_name",
            "username",
            "dbname",
            "host_info"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ps_buffer",
            "ps_buffer_size",
            "PROGRAM_NAME_PREFIX \"%s %s %s \"",
            "username",
            "dbname",
            "host_info"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "host_info"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dbname"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "username"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PROGRAM_NAME_PREFIX \"postgres: \"\n#define PROGRAM_NAME_PREFIX \"\"\n#define PS_USE_NONE\n#define PS_USE_CLOBBER_ARGV\n#define PS_USE_CHANGE_ARGV\n#define PS_USE_SETPROCTITLE\n\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\nstatic int\tsave_argc;\nstatic char **save_argv;\n\nvoid\ninit_ps_display(const char *username, const char *dbname,\n\t\t\t\tconst char *host_info, const char *initial_str)\n{\n\tAssert(username);\n\tAssert(dbname);\n\tAssert(host_info);\n\n#ifndef PS_USE_NONE\n\t/* no ps display for stand-alone backend */\n\tif (!IsUnderPostmaster)\n\t\treturn;\n\n\t/* no ps display if you didn't call save_ps_display_args() */\n\tif (!save_argv)\n\t\treturn;\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t\treturn;\n#endif\n\n\t/*\n\t * Overwrite argv[] to point at appropriate space, if needed\n\t */\n\n#ifdef PS_USE_CHANGE_ARGV\n\tsave_argv[0] = ps_buffer;\n\tsave_argv[1] = NULL;\n#endif\t\t\t\t\t\t\t/* PS_USE_CHANGE_ARGV */\n\n#ifdef PS_USE_CLOBBER_ARGV\n\t{\n\t\tint\t\t\ti;\n\n\t\t/* make extra argv slots point at end_of_area (a NUL) */\n\t\tfor (i = 1; i < save_argc; i++)\n\t\t\tsave_argv[i] = ps_buffer + ps_buffer_size;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n\t/*\n\t * Make fixed prefix of ps display.\n\t */\n\n#ifdef PS_USE_SETPROCTITLE\n\n\t/*\n\t * apparently setproctitle() already adds a `progname:' prefix to the ps\n\t * line\n\t */\n#define PROGRAM_NAME_PREFIX \"\"\n#else\n#define PROGRAM_NAME_PREFIX \"postgres: \"\n#endif\n\n\tif (*cluster_name == '\\0')\n\t{\n\t\tsnprintf(ps_buffer, ps_buffer_size,\n\t\t\t\t PROGRAM_NAME_PREFIX \"%s %s %s \",\n\t\t\t\t username, dbname, host_info);\n\t}\n\telse\n\t{\n\t\tsnprintf(ps_buffer, ps_buffer_size,\n\t\t\t\t PROGRAM_NAME_PREFIX \"%s: %s %s %s \",\n\t\t\t\t cluster_name, username, dbname, host_info);\n\t}\n\n\tps_buffer_cur_len = ps_buffer_fixed_size = strlen(ps_buffer);\n\n\tset_ps_display(initial_str, true);\n#endif\t\t\t\t\t\t\t/* not PS_USE_NONE */\n}"
  },
  {
    "function_name": "save_ps_display_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
    "lines": "120-237",
    "snippet": "char\t  **\nsave_ps_display_args(int argc, char **argv)\n{\n\tsave_argc = argc;\n\tsave_argv = argv;\n\n#if defined(PS_USE_CLOBBER_ARGV)\n\n\t/*\n\t * If we're going to overwrite the argv area, count the available space.\n\t * Also move the environment to make additional room.\n\t */\n\t{\n\t\tchar\t   *end_of_area = NULL;\n\t\tchar\t  **new_environ;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * check for contiguous argv strings\n\t\t */\n\t\tfor (i = 0; i < argc; i++)\n\t\t{\n\t\t\tif (i == 0 || end_of_area + 1 == argv[i])\n\t\t\t\tend_of_area = argv[i] + strlen(argv[i]);\n\t\t}\n\n\t\tif (end_of_area == NULL)\t/* probably can't happen? */\n\t\t{\n\t\t\tps_buffer = NULL;\n\t\t\tps_buffer_size = 0;\n\t\t\treturn argv;\n\t\t}\n\n\t\t/*\n\t\t * check for contiguous environ strings following argv\n\t\t */\n\t\tfor (i = 0; environ[i] != NULL; i++)\n\t\t{\n\t\t\tif (end_of_area + 1 == environ[i])\n\t\t\t\tend_of_area = environ[i] + strlen(environ[i]);\n\t\t}\n\n\t\tps_buffer = argv[0];\n\t\tlast_status_len = ps_buffer_size = end_of_area - argv[0];\n\n\t\t/*\n\t\t * move the environment out of the way\n\t\t */\n\t\tnew_environ = (char **) malloc((i + 1) * sizeof(char *));\n\t\tif (!new_environ)\n\t\t{\n\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; environ[i] != NULL; i++)\n\t\t{\n\t\t\tnew_environ[i] = strdup(environ[i]);\n\t\t\tif (!new_environ[i])\n\t\t\t{\n\t\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tnew_environ[i] = NULL;\n\t\tenviron = new_environ;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#if defined(PS_USE_CHANGE_ARGV) || defined(PS_USE_CLOBBER_ARGV)\n\n\t/*\n\t * If we're going to change the original argv[] then make a copy for\n\t * argument parsing purposes.\n\t *\n\t * (NB: do NOT think to remove the copying of argv[], even though\n\t * postmaster.c finishes looking at argv[] long before we ever consider\n\t * changing the ps display.  On some platforms, getopt() keeps pointers\n\t * into the argv array, and will get horribly confused when it is\n\t * re-called to analyze a subprocess' argument string if the argv storage\n\t * has been clobbered meanwhile.  Other platforms have other dependencies\n\t * on argv[].\n\t */\n\t{\n\t\tchar\t  **new_argv;\n\t\tint\t\t\ti;\n\n\t\tnew_argv = (char **) malloc((argc + 1) * sizeof(char *));\n\t\tif (!new_argv)\n\t\t{\n\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; i < argc; i++)\n\t\t{\n\t\t\tnew_argv[i] = strdup(argv[i]);\n\t\t\tif (!new_argv[i])\n\t\t\t{\n\t\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tnew_argv[argc] = NULL;\n\n#if defined(__darwin__)\n\n\t\t/*\n\t\t * macOS (and perhaps other NeXT-derived platforms?) has a static copy\n\t\t * of the argv pointer, which we may fix like so:\n\t\t */\n\t\t*_NSGetArgv() = new_argv;\n#endif\n\n\t\targv = new_argv;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CHANGE_ARGV or PS_USE_CLOBBER_ARGV */\n\n\treturn argv;\n}",
    "includes": [
      "#include \"utils/guc.h\"",
      "#include \"utils/ps_status.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/libpq.h\"",
      "#include <crt_externs.h>",
      "#include <sys/exec.h>",
      "#include <machine/vmparam.h>\t/* for old BSD */",
      "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
      "#include <unistd.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PS_USE_CLOBBER_ARGV",
      "#define PS_USE_CHANGE_ARGV"
    ],
    "globals_used": [
      "extern char **environ;",
      "static int\tsave_argc;",
      "static char **save_argv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_NSGetArgv",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"out of memory\\n\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(argc + 1) * sizeof(char *)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(i + 1) * sizeof(char *)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "environ[i]"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_USE_CLOBBER_ARGV\n#define PS_USE_CHANGE_ARGV\n\nextern char **environ;\nstatic int\tsave_argc;\nstatic char **save_argv;\n\nchar\t  **\nsave_ps_display_args(int argc, char **argv)\n{\n\tsave_argc = argc;\n\tsave_argv = argv;\n\n#if defined(PS_USE_CLOBBER_ARGV)\n\n\t/*\n\t * If we're going to overwrite the argv area, count the available space.\n\t * Also move the environment to make additional room.\n\t */\n\t{\n\t\tchar\t   *end_of_area = NULL;\n\t\tchar\t  **new_environ;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * check for contiguous argv strings\n\t\t */\n\t\tfor (i = 0; i < argc; i++)\n\t\t{\n\t\t\tif (i == 0 || end_of_area + 1 == argv[i])\n\t\t\t\tend_of_area = argv[i] + strlen(argv[i]);\n\t\t}\n\n\t\tif (end_of_area == NULL)\t/* probably can't happen? */\n\t\t{\n\t\t\tps_buffer = NULL;\n\t\t\tps_buffer_size = 0;\n\t\t\treturn argv;\n\t\t}\n\n\t\t/*\n\t\t * check for contiguous environ strings following argv\n\t\t */\n\t\tfor (i = 0; environ[i] != NULL; i++)\n\t\t{\n\t\t\tif (end_of_area + 1 == environ[i])\n\t\t\t\tend_of_area = environ[i] + strlen(environ[i]);\n\t\t}\n\n\t\tps_buffer = argv[0];\n\t\tlast_status_len = ps_buffer_size = end_of_area - argv[0];\n\n\t\t/*\n\t\t * move the environment out of the way\n\t\t */\n\t\tnew_environ = (char **) malloc((i + 1) * sizeof(char *));\n\t\tif (!new_environ)\n\t\t{\n\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; environ[i] != NULL; i++)\n\t\t{\n\t\t\tnew_environ[i] = strdup(environ[i]);\n\t\t\tif (!new_environ[i])\n\t\t\t{\n\t\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tnew_environ[i] = NULL;\n\t\tenviron = new_environ;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CLOBBER_ARGV */\n\n#if defined(PS_USE_CHANGE_ARGV) || defined(PS_USE_CLOBBER_ARGV)\n\n\t/*\n\t * If we're going to change the original argv[] then make a copy for\n\t * argument parsing purposes.\n\t *\n\t * (NB: do NOT think to remove the copying of argv[], even though\n\t * postmaster.c finishes looking at argv[] long before we ever consider\n\t * changing the ps display.  On some platforms, getopt() keeps pointers\n\t * into the argv array, and will get horribly confused when it is\n\t * re-called to analyze a subprocess' argument string if the argv storage\n\t * has been clobbered meanwhile.  Other platforms have other dependencies\n\t * on argv[].\n\t */\n\t{\n\t\tchar\t  **new_argv;\n\t\tint\t\t\ti;\n\n\t\tnew_argv = (char **) malloc((argc + 1) * sizeof(char *));\n\t\tif (!new_argv)\n\t\t{\n\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; i < argc; i++)\n\t\t{\n\t\t\tnew_argv[i] = strdup(argv[i]);\n\t\t\tif (!new_argv[i])\n\t\t\t{\n\t\t\t\twrite_stderr(\"out of memory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tnew_argv[argc] = NULL;\n\n#if defined(__darwin__)\n\n\t\t/*\n\t\t * macOS (and perhaps other NeXT-derived platforms?) has a static copy\n\t\t * of the argv pointer, which we may fix like so:\n\t\t */\n\t\t*_NSGetArgv() = new_argv;\n#endif\n\n\t\targv = new_argv;\n\t}\n#endif\t\t\t\t\t\t\t/* PS_USE_CHANGE_ARGV or PS_USE_CLOBBER_ARGV */\n\n\treturn argv;\n}"
  }
]