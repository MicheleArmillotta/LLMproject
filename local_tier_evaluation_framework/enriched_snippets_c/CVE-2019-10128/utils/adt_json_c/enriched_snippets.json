[
  {
    "function_name": "json_typeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2514-2555",
    "snippet": "Datum\njson_typeof(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json;\n\n\tJsonLexContext *lex;\n\tJsonTokenType tok;\n\tchar\t   *type;\n\n\tjson = PG_GETARG_TEXT_PP(0);\n\tlex = makeJsonLexContext(json, false);\n\n\t/* Lex exactly one token from the input and check its type. */\n\tjson_lex(lex);\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\ttype = \"object\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\ttype = \"array\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\ttype = \"string\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\ttype = \"number\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\ttype = \"boolean\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\ttype = \"null\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected json token: %d\", tok);\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(type));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(type)"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "type"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected json token: %d\"",
            "tok"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_lex",
          "args": [
            "lex"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "754-997",
          "snippet": "static inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "false"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nDatum\njson_typeof(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json;\n\n\tJsonLexContext *lex;\n\tJsonTokenType tok;\n\tchar\t   *type;\n\n\tjson = PG_GETARG_TEXT_PP(0);\n\tlex = makeJsonLexContext(json, false);\n\n\t/* Lex exactly one token from the input and check its type. */\n\tjson_lex(lex);\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\ttype = \"object\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\ttype = \"array\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\ttype = \"string\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\ttype = \"number\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\ttype = \"boolean\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\ttype = \"null\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected json token: %d\", tok);\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(type));\n}"
  },
  {
    "function_name": "escape_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2460-2500",
    "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\"'"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "*p"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"\\\\u%04x\"",
            "(int) *p"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\\\\\\""
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\\\\"\""
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\t\""
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\r\""
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\n\""
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\f\""
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "\"\\\\b\""
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\"'"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
  },
  {
    "function_name": "json_object_two_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2377-2454",
    "snippet": "Datum\njson_object_two_arg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\tnkdims = ARR_NDIM(key_array);\n\tint\t\t\tnvdims = ARR_NDIM(val_array);\n\tStringInfoData result;\n\tDatum\t   *key_datums,\n\t\t\t   *val_datums;\n\tbool\t   *key_nulls,\n\t\t\t   *val_nulls;\n\tint\t\t\tkey_count,\n\t\t\t\tval_count,\n\t\t\t\ti;\n\ttext\t   *rval;\n\tchar\t   *v;\n\n\tif (nkdims > 1 || nkdims != nvdims)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (nkdims == 0)\n\t\tPG_RETURN_DATUM(CStringGetTextDatum(\"{}\"));\n\n\tdeconstruct_array(key_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tdeconstruct_array(val_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &val_datums, &val_nulls, &val_count);\n\n\tif (key_count != val_count)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\")));\n\n\tinitStringInfo(&result);\n\n\tappendStringInfoChar(&result, '{');\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tv = TextDatumGetCString(key_datums[i]);\n\t\tif (i > 0)\n\t\t\tappendStringInfoString(&result, \", \");\n\t\tescape_json(&result, v);\n\t\tappendStringInfoString(&result, \" : \");\n\t\tpfree(v);\n\t\tif (val_nulls[i])\n\t\t\tappendStringInfoString(&result, \"null\");\n\t\telse\n\t\t{\n\t\t\tv = TextDatumGetCString(val_datums[i]);\n\t\t\tescape_json(&result, v);\n\t\t\tpfree(v);\n\t\t}\n\t}\n\n\tappendStringInfoChar(&result, '}');\n\n\tpfree(key_datums);\n\tpfree(key_nulls);\n\tpfree(val_datums);\n\tpfree(val_nulls);\n\n\trval = cstring_to_text_with_len(result.data, result.len);\n\tpfree(result.data);\n\n\tPG_RETURN_TEXT_P(rval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "rval"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result.data"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result.data",
            "result.len"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&result",
            "'}'"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "&result",
            "v"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "val_datums[i]"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"null\""
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\" : \""
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\", \""
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "key_datums[i]"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\"))"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null value not allowed for object key\""
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&result",
            "'{'"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\"))"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "val_array",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&val_datums",
            "&val_nulls",
            "&val_count"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "CStringGetTextDatum(\"{}\")"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "\"{}\""
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "val_array"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "key_array"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_object_two_arg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\tnkdims = ARR_NDIM(key_array);\n\tint\t\t\tnvdims = ARR_NDIM(val_array);\n\tStringInfoData result;\n\tDatum\t   *key_datums,\n\t\t\t   *val_datums;\n\tbool\t   *key_nulls,\n\t\t\t   *val_nulls;\n\tint\t\t\tkey_count,\n\t\t\t\tval_count,\n\t\t\t\ti;\n\ttext\t   *rval;\n\tchar\t   *v;\n\n\tif (nkdims > 1 || nkdims != nvdims)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (nkdims == 0)\n\t\tPG_RETURN_DATUM(CStringGetTextDatum(\"{}\"));\n\n\tdeconstruct_array(key_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tdeconstruct_array(val_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &val_datums, &val_nulls, &val_count);\n\n\tif (key_count != val_count)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\")));\n\n\tinitStringInfo(&result);\n\n\tappendStringInfoChar(&result, '{');\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tv = TextDatumGetCString(key_datums[i]);\n\t\tif (i > 0)\n\t\t\tappendStringInfoString(&result, \", \");\n\t\tescape_json(&result, v);\n\t\tappendStringInfoString(&result, \" : \");\n\t\tpfree(v);\n\t\tif (val_nulls[i])\n\t\t\tappendStringInfoString(&result, \"null\");\n\t\telse\n\t\t{\n\t\t\tv = TextDatumGetCString(val_datums[i]);\n\t\t\tescape_json(&result, v);\n\t\t\tpfree(v);\n\t\t}\n\t}\n\n\tappendStringInfoChar(&result, '}');\n\n\tpfree(key_datums);\n\tpfree(key_nulls);\n\tpfree(val_datums);\n\tpfree(val_nulls);\n\n\trval = cstring_to_text_with_len(result.data, result.len);\n\tpfree(result.data);\n\n\tPG_RETURN_TEXT_P(rval);\n}"
  },
  {
    "function_name": "json_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2286-2369",
    "snippet": "Datum\njson_object(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tStringInfoData result;\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count,\n\t\t\t\tcount,\n\t\t\t\ti;\n\ttext\t   *rval;\n\tchar\t   *v;\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tPG_RETURN_DATUM(CStringGetTextDatum(\"{}\"));\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n\n\tcount = in_count / 2;\n\n\tinitStringInfo(&result);\n\n\tappendStringInfoChar(&result, '{');\n\n\tfor (i = 0; i < count; ++i)\n\t{\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tv = TextDatumGetCString(in_datums[i * 2]);\n\t\tif (i > 0)\n\t\t\tappendStringInfoString(&result, \", \");\n\t\tescape_json(&result, v);\n\t\tappendStringInfoString(&result, \" : \");\n\t\tpfree(v);\n\t\tif (in_nulls[i * 2 + 1])\n\t\t\tappendStringInfoString(&result, \"null\");\n\t\telse\n\t\t{\n\t\t\tv = TextDatumGetCString(in_datums[i * 2 + 1]);\n\t\t\tescape_json(&result, v);\n\t\t\tpfree(v);\n\t\t}\n\t}\n\n\tappendStringInfoChar(&result, '}');\n\n\tpfree(in_datums);\n\tpfree(in_nulls);\n\n\trval = cstring_to_text_with_len(result.data, result.len);\n\tpfree(result.data);\n\n\tPG_RETURN_TEXT_P(rval);\n\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "rval"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result.data"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result.data",
            "result.len"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&result",
            "'}'"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "&result",
            "v"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "in_datums[i * 2 + 1]"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\"null\""
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\" : \""
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&result",
            "\", \""
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "in_datums[i * 2]"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\"))"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null value not allowed for object key\""
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&result",
            "'{'"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&result"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "in_array",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&in_datums",
            "&in_nulls",
            "&in_count"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\"))"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "in_array"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\"))"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "in_array"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "CStringGetTextDatum(\"{}\")"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "\"{}\""
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "in_array"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_object(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tStringInfoData result;\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count,\n\t\t\t\tcount,\n\t\t\t\ti;\n\ttext\t   *rval;\n\tchar\t   *v;\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tPG_RETURN_DATUM(CStringGetTextDatum(\"{}\"));\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n\n\tcount = in_count / 2;\n\n\tinitStringInfo(&result);\n\n\tappendStringInfoChar(&result, '{');\n\n\tfor (i = 0; i < count; ++i)\n\t{\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tv = TextDatumGetCString(in_datums[i * 2]);\n\t\tif (i > 0)\n\t\t\tappendStringInfoString(&result, \", \");\n\t\tescape_json(&result, v);\n\t\tappendStringInfoString(&result, \" : \");\n\t\tpfree(v);\n\t\tif (in_nulls[i * 2 + 1])\n\t\t\tappendStringInfoString(&result, \"null\");\n\t\telse\n\t\t{\n\t\t\tv = TextDatumGetCString(in_datums[i * 2 + 1]);\n\t\t\tescape_json(&result, v);\n\t\t\tpfree(v);\n\t\t}\n\t}\n\n\tappendStringInfoChar(&result, '}');\n\n\tpfree(in_datums);\n\tpfree(in_nulls);\n\n\trval = cstring_to_text_with_len(result.data, result.len);\n\tpfree(result.data);\n\n\tPG_RETURN_TEXT_P(rval);\n\n}"
  },
  {
    "function_name": "json_build_array_noargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2274-2278",
    "snippet": "Datum\njson_build_array_noargs(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(\"[]\", 2));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(\"[]\", 2)"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "\"[]\"",
            "2"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_build_array_noargs(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(\"[]\", 2));\n}"
  },
  {
    "function_name": "json_build_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2238-2269",
    "snippet": "Datum\njson_build_array(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tconst char *sep = \"\";\n\tStringInfo\tresult;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* fetch argument values to build the array */\n\tnargs = extract_variadic_args(fcinfo, 0, false, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tresult = makeStringInfo();\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tappendStringInfoString(result, sep);\n\t\tsep = \", \";\n\t\tadd_json(args[i], nulls[i], result, types[i], false);\n\t}\n\n\tappendStringInfoChar(result, ']');\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "']'"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_json",
          "args": [
            "args[i]",
            "nulls[i]",
            "result",
            "types[i]",
            "false"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "add_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1819-1841",
          "snippet": "static void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "sep"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'['"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_variadic_args",
          "args": [
            "fcinfo",
            "0",
            "false",
            "&args",
            "&types",
            "&nulls"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "extract_variadic_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1478-1575",
          "snippet": "int\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_build_array(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tconst char *sep = \"\";\n\tStringInfo\tresult;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* fetch argument values to build the array */\n\tnargs = extract_variadic_args(fcinfo, 0, false, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tresult = makeStringInfo();\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tappendStringInfoString(result, sep);\n\t\tsep = \", \";\n\t\tadd_json(args[i], nulls[i], result, types[i], false);\n\t}\n\n\tappendStringInfoChar(result, ']');\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "json_build_object_noargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2229-2233",
    "snippet": "Datum\njson_build_object_noargs(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(\"{}\", 2));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(\"{}\", 2)"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "\"{}\"",
            "2"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_build_object_noargs(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(\"{}\", 2));\n}"
  },
  {
    "function_name": "json_build_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2174-2224",
    "snippet": "Datum\njson_build_object(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs = PG_NARGS();\n\tint\t\t\ti;\n\tconst char *sep = \"\";\n\tStringInfo\tresult;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* fetch argument values to build the object */\n\tnargs = extract_variadic_args(fcinfo, 0, false, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tif (nargs % 2 != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of json_build_object() must consist of alternating keys and values.\")));\n\n\tresult = makeStringInfo();\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < nargs; i += 2)\n\t{\n\t\tappendStringInfoString(result, sep);\n\t\tsep = \", \";\n\n\t\t/* process key */\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d cannot be null\", i + 1),\n\t\t\t\t\t errhint(\"Object keys should be text.\")));\n\n\t\tadd_json(args[i], false, result, types[i], true);\n\n\t\tappendStringInfoString(result, \" : \");\n\n\t\t/* process value */\n\t\tadd_json(args[i + 1], nulls[i + 1], result, types[i + 1], false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'}'"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_json",
          "args": [
            "args[i + 1]",
            "nulls[i + 1]",
            "result",
            "types[i + 1]",
            "false"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "add_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1819-1841",
          "snippet": "static void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\" : \""
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d cannot be null\", i + 1),\n\t\t\t\t\t errhint(\"Object keys should be text.\"))"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Object keys should be text.\""
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument %d cannot be null\"",
            "i + 1"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "sep"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'{'"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of json_build_object() must consist of alternating keys and values.\"))"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_variadic_args",
          "args": [
            "fcinfo",
            "0",
            "false",
            "&args",
            "&types",
            "&nulls"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "extract_variadic_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1478-1575",
          "snippet": "int\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_build_object(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs = PG_NARGS();\n\tint\t\t\ti;\n\tconst char *sep = \"\";\n\tStringInfo\tresult;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* fetch argument values to build the object */\n\tnargs = extract_variadic_args(fcinfo, 0, false, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tif (nargs % 2 != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of json_build_object() must consist of alternating keys and values.\")));\n\n\tresult = makeStringInfo();\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < nargs; i += 2)\n\t{\n\t\tappendStringInfoString(result, sep);\n\t\tsep = \", \";\n\n\t\t/* process key */\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d cannot be null\", i + 1),\n\t\t\t\t\t errhint(\"Object keys should be text.\")));\n\n\t\tadd_json(args[i], false, result, types[i], true);\n\n\t\tappendStringInfoString(result, \" : \");\n\n\t\t/* process value */\n\t\tadd_json(args[i + 1], nulls[i + 1], result, types[i + 1], false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "catenate_stringinfo_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2156-2169",
    "snippet": "static text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *catenate_stringinfo_string(StringInfo buffer, const char *addon);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(result) + buflen",
            "addon",
            "addlen"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(result)",
            "buffer->data",
            "buflen"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "buflen + addlen + VARHDRSZ"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "buflen + addlen + VARHDRSZ"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "addon"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic text *catenate_stringinfo_string(StringInfo buffer, const char *addon);\n\nstatic text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}"
  },
  {
    "function_name": "json_object_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2133-2149",
    "snippet": "Datum\njson_object_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonAggState *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (JsonAggState *) PG_GETARG_POINTER(0);\n\n\t/* NULL result for no rows in, as is standard with aggregates */\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/* Else return state with appropriate object terminator added */\n\tPG_RETURN_TEXT_P(catenate_stringinfo_string(state->str, \" }\"));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "catenate_stringinfo_string(state->str, \" }\")"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "catenate_stringinfo_string",
          "args": [
            "state->str",
            "\" }\""
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "catenate_stringinfo_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2156-2169",
          "snippet": "static text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *catenate_stringinfo_string(StringInfo buffer, const char *addon);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic text *catenate_stringinfo_string(StringInfo buffer, const char *addon);\n\nstatic text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_object_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonAggState *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (JsonAggState *) PG_GETARG_POINTER(0);\n\n\t/* NULL result for no rows in, as is standard with aggregates */\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/* Else return state with appropriate object terminator added */\n\tPG_RETURN_TEXT_P(catenate_stringinfo_string(state->str, \" }\"));\n}"
  },
  {
    "function_name": "json_object_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2042-2128",
    "snippet": "Datum\njson_object_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext aggcontext,\n\t\t\t\toldcontext;\n\tJsonAggState *state;\n\tDatum\t\targ;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"json_object_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type;\n\n\t\t/*\n\t\t * Make the StringInfo in a context where it will persist for the\n\t\t * duration of the aggregate call. Switching context is only needed\n\t\t * for this initial step, as the StringInfo routines make sure they\n\t\t * use the right context to enlarge the object if necessary.\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = (JsonAggState *) palloc(sizeof(JsonAggState));\n\t\tstate->str = makeStringInfo();\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 1)));\n\n\t\tjson_categorize_type(arg_type, &state->key_category,\n\t\t\t\t\t\t\t &state->key_output_func);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 2);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 2)));\n\n\t\tjson_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t &state->val_output_func);\n\n\t\tappendStringInfoString(state->str, \"{ \");\n\t}\n\telse\n\t{\n\t\tstate = (JsonAggState *) PG_GETARG_POINTER(0);\n\t\tappendStringInfoString(state->str, \", \");\n\t}\n\n\t/*\n\t * Note: since json_object_agg() is declared as taking type \"any\", the\n\t * parser will not do any type conversion on unknown-type literals (that\n\t * is, undecorated strings or NULLs).  Such values will arrive here as\n\t * type UNKNOWN, which fortunately does not matter to us, since\n\t * unknownout() works fine.\n\t */\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\")));\n\n\targ = PG_GETARG_DATUM(1);\n\n\tdatum_to_json(arg, false, state->str, state->key_category,\n\t\t\t\t  state->key_output_func, true);\n\n\tappendStringInfoString(state->str, \" : \");\n\n\tif (PG_ARGISNULL(2))\n\t\targ = (Datum) 0;\n\telse\n\t\targ = PG_GETARG_DATUM(2);\n\n\tdatum_to_json(arg, PG_ARGISNULL(2), state->str, state->val_category,\n\t\t\t\t  state->val_output_func, false);\n\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "arg",
            "PG_ARGISNULL(2)",
            "state->str",
            "state->val_category",
            "state->val_output_func",
            "false"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "state->str",
            "\" : \""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\"))"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"field name must not be null\""
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "state->str",
            "\", \""
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "state->str",
            "\"{ \""
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "arg_type",
            "&state->val_category",
            "&state->val_output_func"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 2))"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "2"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 1))"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonAggState)"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"json_object_agg_transfn called in non-aggregate context\""
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_object_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext aggcontext,\n\t\t\t\toldcontext;\n\tJsonAggState *state;\n\tDatum\t\targ;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"json_object_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type;\n\n\t\t/*\n\t\t * Make the StringInfo in a context where it will persist for the\n\t\t * duration of the aggregate call. Switching context is only needed\n\t\t * for this initial step, as the StringInfo routines make sure they\n\t\t * use the right context to enlarge the object if necessary.\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = (JsonAggState *) palloc(sizeof(JsonAggState));\n\t\tstate->str = makeStringInfo();\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 1)));\n\n\t\tjson_categorize_type(arg_type, &state->key_category,\n\t\t\t\t\t\t\t &state->key_output_func);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 2);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine data type for argument %d\", 2)));\n\n\t\tjson_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t &state->val_output_func);\n\n\t\tappendStringInfoString(state->str, \"{ \");\n\t}\n\telse\n\t{\n\t\tstate = (JsonAggState *) PG_GETARG_POINTER(0);\n\t\tappendStringInfoString(state->str, \", \");\n\t}\n\n\t/*\n\t * Note: since json_object_agg() is declared as taking type \"any\", the\n\t * parser will not do any type conversion on unknown-type literals (that\n\t * is, undecorated strings or NULLs).  Such values will arrive here as\n\t * type UNKNOWN, which fortunately does not matter to us, since\n\t * unknownout() works fine.\n\t */\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\")));\n\n\targ = PG_GETARG_DATUM(1);\n\n\tdatum_to_json(arg, false, state->str, state->key_category,\n\t\t\t\t  state->key_output_func, true);\n\n\tappendStringInfoString(state->str, \" : \");\n\n\tif (PG_ARGISNULL(2))\n\t\targ = (Datum) 0;\n\telse\n\t\targ = PG_GETARG_DATUM(2);\n\n\tdatum_to_json(arg, PG_ARGISNULL(2), state->str, state->val_category,\n\t\t\t\t  state->val_output_func, false);\n\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "json_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "2017-2035",
    "snippet": "Datum\njson_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonAggState *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ?\n\t\tNULL :\n\t\t(JsonAggState *) PG_GETARG_POINTER(0);\n\n\t/* NULL result for no rows in, as is standard with aggregates */\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/* Else return state with appropriate array terminator added */\n\tPG_RETURN_TEXT_P(catenate_stringinfo_string(state->str, \"]\"));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "catenate_stringinfo_string(state->str, \"]\")"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "catenate_stringinfo_string",
          "args": [
            "state->str",
            "\"]\""
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "catenate_stringinfo_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2156-2169",
          "snippet": "static text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *catenate_stringinfo_string(StringInfo buffer, const char *addon);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic text *catenate_stringinfo_string(StringInfo buffer, const char *addon);\n\nstatic text *\ncatenate_stringinfo_string(StringInfo buffer, const char *addon)\n{\n\t/* custom version of cstring_to_text_with_len */\n\tint\t\t\tbuflen = buffer->len;\n\tint\t\t\taddlen = strlen(addon);\n\ttext\t   *result = (text *) palloc(buflen + addlen + VARHDRSZ);\n\n\tSET_VARSIZE(result, buflen + addlen + VARHDRSZ);\n\tmemcpy(VARDATA(result), buffer->data, buflen);\n\tmemcpy(VARDATA(result) + buflen, addon, addlen);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonAggState *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ?\n\t\tNULL :\n\t\t(JsonAggState *) PG_GETARG_POINTER(0);\n\n\t/* NULL result for no rows in, as is standard with aggregates */\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\n\n\t/* Else return state with appropriate array terminator added */\n\tPG_RETURN_TEXT_P(catenate_stringinfo_string(state->str, \"]\"));\n}"
  },
  {
    "function_name": "json_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1941-2012",
    "snippet": "Datum\njson_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext aggcontext,\n\t\t\t\toldcontext;\n\tJsonAggState *state;\n\tDatum\t\tval;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"json_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\t/*\n\t\t * Make this state object in a context where it will persist for the\n\t\t * duration of the aggregate call.  MemoryContextSwitchTo is only\n\t\t * needed the first time, as the StringInfo routines make sure they\n\t\t * use the right context to enlarge the object if necessary.\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = (JsonAggState *) palloc(sizeof(JsonAggState));\n\t\tstate->str = makeStringInfo();\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tappendStringInfoChar(state->str, '[');\n\t\tjson_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonAggState *) PG_GETARG_POINTER(0);\n\t\tappendStringInfoString(state->str, \", \");\n\t}\n\n\t/* fast path for NULLs */\n\tif (PG_ARGISNULL(1))\n\t{\n\t\tdatum_to_json((Datum) 0, true, state->str, JSONTYPE_NULL,\n\t\t\t\t\t  InvalidOid, false);\n\t\tPG_RETURN_POINTER(state);\n\t}\n\n\tval = PG_GETARG_DATUM(1);\n\n\t/* add some whitespace if structured type and not first item */\n\tif (!PG_ARGISNULL(0) &&\n\t\t(state->val_category == JSONTYPE_ARRAY ||\n\t\t state->val_category == JSONTYPE_COMPOSITE))\n\t{\n\t\tappendStringInfoString(state->str, \"\\n \");\n\t}\n\n\tdatum_to_json(val, false, state->str, state->val_category,\n\t\t\t\t  state->val_output_func, false);\n\n\t/*\n\t * The transition type for json_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the JsonAggState pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "val",
            "false",
            "state->str",
            "state->val_category",
            "state->val_output_func",
            "false"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "state->str",
            "\"\\n \""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "state->str",
            "\", \""
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "arg_type",
            "&state->val_category",
            "&state->val_output_func"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "state->str",
            "'['"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonAggState)"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "1"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"json_agg_transfn called in non-aggregate context\""
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\n\nDatum\njson_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext aggcontext,\n\t\t\t\toldcontext;\n\tJsonAggState *state;\n\tDatum\t\tval;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"json_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\t/*\n\t\t * Make this state object in a context where it will persist for the\n\t\t * duration of the aggregate call.  MemoryContextSwitchTo is only\n\t\t * needed the first time, as the StringInfo routines make sure they\n\t\t * use the right context to enlarge the object if necessary.\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = (JsonAggState *) palloc(sizeof(JsonAggState));\n\t\tstate->str = makeStringInfo();\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tappendStringInfoChar(state->str, '[');\n\t\tjson_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonAggState *) PG_GETARG_POINTER(0);\n\t\tappendStringInfoString(state->str, \", \");\n\t}\n\n\t/* fast path for NULLs */\n\tif (PG_ARGISNULL(1))\n\t{\n\t\tdatum_to_json((Datum) 0, true, state->str, JSONTYPE_NULL,\n\t\t\t\t\t  InvalidOid, false);\n\t\tPG_RETURN_POINTER(state);\n\t}\n\n\tval = PG_GETARG_DATUM(1);\n\n\t/* add some whitespace if structured type and not first item */\n\tif (!PG_ARGISNULL(0) &&\n\t\t(state->val_category == JSONTYPE_ARRAY ||\n\t\t state->val_category == JSONTYPE_COMPOSITE))\n\t{\n\t\tappendStringInfoString(state->str, \"\\n \");\n\t}\n\n\tdatum_to_json(val, false, state->str, state->val_category,\n\t\t\t\t  state->val_output_func, false);\n\n\t/*\n\t * The transition type for json_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the JsonAggState pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1912-1934",
    "snippet": "Datum\nto_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tOid\t\t\tval_type = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tStringInfo\tresult;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tjson_categorize_type(val_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tresult = makeStringInfo();\n\n\tdatum_to_json(val, false, result, tcategory, outfuncoid, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "val",
            "false",
            "result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "val_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nDatum\nto_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tOid\t\t\tval_type = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tStringInfo\tresult;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tjson_categorize_type(val_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tresult = makeStringInfo();\n\n\tdatum_to_json(val, false, result, tcategory, outfuncoid, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "row_to_json_pretty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1895-1907",
    "snippet": "Datum\nrow_to_json_pretty(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tbool\t\tuse_line_feeds = PG_GETARG_BOOL(1);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tcomposite_to_json(array, result, use_line_feeds);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "composite_to_json",
          "args": [
            "array",
            "result",
            "use_line_feeds"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "composite_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1746-1810",
          "snippet": "static void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\n\nDatum\nrow_to_json_pretty(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tbool\t\tuse_line_feeds = PG_GETARG_BOOL(1);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tcomposite_to_json(array, result, use_line_feeds);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "row_to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1879-1890",
    "snippet": "Datum\nrow_to_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tcomposite_to_json(array, result, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "composite_to_json",
          "args": [
            "array",
            "result",
            "false"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "composite_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1746-1810",
          "snippet": "static void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\nrow_to_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tcomposite_to_json(array, result, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "array_to_json_pretty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1862-1874",
    "snippet": "Datum\narray_to_json_pretty(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tbool\t\tuse_line_feeds = PG_GETARG_BOOL(1);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tarray_to_json_internal(array, result, use_line_feeds);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_to_json_internal",
          "args": [
            "array",
            "result",
            "use_line_feeds"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_json_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1699-1741",
          "snippet": "static void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "1"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\n\nDatum\narray_to_json_pretty(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tbool\t\tuse_line_feeds = PG_GETARG_BOOL(1);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tarray_to_json_internal(array, result, use_line_feeds);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "array_to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1846-1857",
    "snippet": "Datum\narray_to_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tarray_to_json_internal(array, result, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(result->data, result->len)"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "result->data",
            "result->len"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_to_json_internal",
          "args": [
            "array",
            "result",
            "false"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_json_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1699-1741",
          "snippet": "static void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\narray_to_json(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tarray = PG_GETARG_DATUM(0);\n\tStringInfo\tresult;\n\n\tresult = makeStringInfo();\n\n\tarray_to_json_internal(array, result, false);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(result->data, result->len));\n}"
  },
  {
    "function_name": "add_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1819-1841",
    "snippet": "static void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
      "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
      "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "val",
            "is_null",
            "result",
            "tcategory",
            "outfuncoid",
            "key_scalar"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "val_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\nadd_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar)\n{\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjson_categorize_type(val_type,\n\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdatum_to_json(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
  },
  {
    "function_name": "composite_to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1746-1810",
    "snippet": "static void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'}'"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "val",
            "isnull",
            "result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "att->atttypid",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tuple",
            "i + 1",
            "tupdesc",
            "&isnull"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "':'"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "result",
            "attname"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "sep"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'{'"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "td"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "td"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "td"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetHeapTupleHeader",
          "args": [
            "composite"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}"
  },
  {
    "function_name": "array_to_json_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1699-1741",
    "snippet": "static void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_dim_to_json",
          "args": [
            "result",
            "0",
            "ndim",
            "dim",
            "elements",
            "nulls",
            "&count",
            "tcategory",
            "outfuncoid",
            "use_line_feeds"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "array_dim_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1657-1694",
          "snippet": "static void\narray_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t  bool *nulls, int *valcount, JsonTypeCategory tcategory,\n\t\t\t\t  Oid outfuncoid, bool use_line_feeds)\n{\n\tint\t\t\ti;\n\tconst char *sep;\n\n\tAssert(dim < ndims);\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tappendStringInfoString(result, sep);\n\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_json(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t  outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Do we want line feeds on inner dimensions of arrays? For now\n\t\t\t * we'll say no.\n\t\t\t */\n\t\t\tarray_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t  valcount, tcategory, outfuncoid, false);\n\t\t}\n\t}\n\n\tappendStringInfoChar(result, ']');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t  bool *nulls, int *valcount, JsonTypeCategory tcategory,\n\t\t\t\t  Oid outfuncoid, bool use_line_feeds)\n{\n\tint\t\t\ti;\n\tconst char *sep;\n\n\tAssert(dim < ndims);\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tappendStringInfoString(result, sep);\n\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_json(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t  outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Do we want line feeds on inner dimensions of arrays? For now\n\t\t\t * we'll say no.\n\t\t\t */\n\t\t\tarray_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t  valcount, tcategory, outfuncoid, false);\n\t\t}\n\t}\n\n\tappendStringInfoChar(result, ']');\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "v",
            "element_type",
            "typlen",
            "typbyval",
            "typalign",
            "&elements",
            "&nulls",
            "&nitems"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_categorize_type",
          "args": [
            "element_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "json_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1347-1438",
          "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&typlen",
            "&typbyval",
            "&typalign"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"[]\""
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "array"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
  },
  {
    "function_name": "array_dim_to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1657-1694",
    "snippet": "static void\narray_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t  bool *nulls, int *valcount, JsonTypeCategory tcategory,\n\t\t\t\t  Oid outfuncoid, bool use_line_feeds)\n{\n\tint\t\t\ti;\n\tconst char *sep;\n\n\tAssert(dim < ndims);\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tappendStringInfoString(result, sep);\n\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_json(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t  outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Do we want line feeds on inner dimensions of arrays? For now\n\t\t\t * we'll say no.\n\t\t\t */\n\t\t\tarray_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t  valcount, tcategory, outfuncoid, false);\n\t\t}\n\t}\n\n\tappendStringInfoChar(result, ']');\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
      "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "']'"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_dim_to_json",
          "args": [
            "result",
            "dim + 1",
            "ndims",
            "dims",
            "vals",
            "nulls",
            "valcount",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "array_dim_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1657-1694",
          "snippet": "static void\narray_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t  bool *nulls, int *valcount, JsonTypeCategory tcategory,\n\t\t\t\t  Oid outfuncoid, bool use_line_feeds)\n{\n\tint\t\t\ti;\n\tconst char *sep;\n\n\tAssert(dim < ndims);\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tappendStringInfoString(result, sep);\n\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_json(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t  outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Do we want line feeds on inner dimensions of arrays? For now\n\t\t\t * we'll say no.\n\t\t\t */\n\t\t\tarray_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t  valcount, tcategory, outfuncoid, false);\n\t\t}\n\t}\n\n\tappendStringInfoChar(result, ']');\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_json",
          "args": [
            "vals[*valcount]",
            "nulls[*valcount]",
            "result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1449-1549",
          "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
            "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
            "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "sep"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "result",
            "'['"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dim < ndims"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t  bool *nulls, int *valcount, JsonTypeCategory tcategory,\n\t\t\t\t  Oid outfuncoid, bool use_line_feeds)\n{\n\tint\t\t\ti;\n\tconst char *sep;\n\n\tAssert(dim < ndims);\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\tappendStringInfoChar(result, '[');\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tappendStringInfoString(result, sep);\n\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_json(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t  outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Do we want line feeds on inner dimensions of arrays? For now\n\t\t\t * we'll say no.\n\t\t\t */\n\t\t\tarray_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t  valcount, tcategory, outfuncoid, false);\n\t\t}\n\t}\n\n\tappendStringInfoChar(result, ']');\n}"
  },
  {
    "function_name": "JsonEncodeDateTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1555-1650",
    "snippet": "char *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb value datetime type oid %d\"",
            "typid"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "&tm",
            "fsec",
            "true",
            "tz",
            "tzn",
            "USE_XSD_DATES",
            "buf"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "&tm",
            "&fsec",
            "&tzn",
            "NULL"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialTimestamp",
          "args": [
            "timestamp",
            "buf"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1522-1531",
          "snippet": "void\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialTimestamp(Timestamp dt, char *str)\n{\n\tif (TIMESTAMP_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (TIMESTAMP_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialTimestamp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestampTz",
          "args": [
            "value"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "value"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeTimeOnly",
          "args": [
            "tm",
            "fsec",
            "true",
            "tz",
            "USE_XSD_DATES",
            "buf"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTimeOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3957-3968",
          "snippet": "void\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timetz2tm",
          "args": [
            "time",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "timetz2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2141-2157",
          "snippet": "int\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTimeTzADTP",
          "args": [
            "value"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time2tm",
          "args": [
            "time",
            "tm",
            "&fsec"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "time2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1278-1289",
          "snippet": "int\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTimeADT",
          "args": [
            "value"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeDateOnly",
          "args": [
            "&tm",
            "USE_XSD_DATES",
            "buf"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3872-3946",
          "snippet": "void\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "date + POSTGRES_EPOCH_JDATE",
            "&(tm.tm_year)",
            "&(tm.tm_mon)",
            "&(tm.tm_mday)"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialDate",
          "args": [
            "date",
            "buf"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "296-305",
          "snippet": "void\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "date"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetDateADT",
          "args": [
            "value"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "MAXDATELEN + 1"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nchar *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "datum_to_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1449-1549",
    "snippet": "static void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *extract_mb_char(char *s);",
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);",
      "static void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);",
      "static void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "outputstr"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "result",
            "outputstr"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidOutputFunctionCall",
          "args": [
            "outfuncoid",
            "val"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "outputstr"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "jsontext"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "OidFunctionCall1(outfuncoid, val)"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidFunctionCall1",
          "args": [
            "outfuncoid",
            "val"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "outputstr"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"\\\"%s\\\"\"",
            "buf"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonEncodeDateTime",
          "args": [
            "buf",
            "val",
            "TIMESTAMPTZOID"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "JsonEncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1555-1650",
          "snippet": "char *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nchar *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"\\\"%s\\\"\"",
            "buf"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "result",
            "\"\\\"%s\\\"\"",
            "buf"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "outputstr"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsValidJsonNumber",
          "args": [
            "outputstr",
            "strlen(outputstr)"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "IsValidJsonNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "192-222",
          "snippet": "bool\nIsValidJsonNumber(const char *str, int len)\n{\n\tbool\t\tnumeric_error;\n\tint\t\t\ttotal_len;\n\tJsonLexContext dummy_lex;\n\n\tif (len <= 0)\n\t\treturn false;\n\n\t/*\n\t * json_lex_number expects a leading  '-' to have been eaten already.\n\t *\n\t * having to cast away the constness of str is ugly, but there's not much\n\t * easy alternative.\n\t */\n\tif (*str == '-')\n\t{\n\t\tdummy_lex.input = (char *) str + 1;\n\t\tdummy_lex.input_length = len - 1;\n\t}\n\telse\n\t{\n\t\tdummy_lex.input = (char *) str;\n\t\tdummy_lex.input_length = len;\n\t}\n\n\tjson_lex_number(&dummy_lex, dummy_lex.input, &numeric_error, &total_len);\n\n\treturn (!numeric_error) && (total_len == dummy_lex.input_length);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);\nstatic char *extract_mb_char(char *s);\n\nbool\nIsValidJsonNumber(const char *str, int len)\n{\n\tbool\t\tnumeric_error;\n\tint\t\t\ttotal_len;\n\tJsonLexContext dummy_lex;\n\n\tif (len <= 0)\n\t\treturn false;\n\n\t/*\n\t * json_lex_number expects a leading  '-' to have been eaten already.\n\t *\n\t * having to cast away the constness of str is ugly, but there's not much\n\t * easy alternative.\n\t */\n\tif (*str == '-')\n\t{\n\t\tdummy_lex.input = (char *) str + 1;\n\t\tdummy_lex.input_length = len - 1;\n\t}\n\telse\n\t{\n\t\tdummy_lex.input = (char *) str;\n\t\tdummy_lex.input_length = len;\n\t}\n\n\tjson_lex_number(&dummy_lex, dummy_lex.input, &numeric_error, &total_len);\n\n\treturn (!numeric_error) && (total_len == dummy_lex.input_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "outputstr"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "outputstr"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "val"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "composite_to_json",
          "args": [
            "val",
            "result",
            "false"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "composite_to_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1746-1810",
          "snippet": "static void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\ncomposite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(att->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_to_json_internal",
          "args": [
            "val",
            "result",
            "false"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_json_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1699-1741",
          "snippet": "static void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);",
            "static void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);",
            "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_json(Datum composite, StringInfo result,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,\n\t\t\t\t  Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t\t  bool use_line_feeds);\nstatic void array_to_json_internal(Datum array, StringInfo result,\n\t\t\t\t\t   bool use_line_feeds);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\narray_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tappendStringInfoString(result, \"[]\");\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjson_categorize_type(element_type,\n\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t  outfuncoid, use_line_feeds);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\"))"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"key value must be scalar, not array, composite, or json\""
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "result",
            "\"null\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(key_scalar && is_null)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\nstatic void datum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar);\nstatic void add_json(Datum val, bool is_null, StringInfo result,\n\t\t Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_json(Datum val, bool is_null, StringInfo result,\n\t\t\t  JsonTypeCategory tcategory, Oid outfuncoid,\n\t\t\t  bool key_scalar)\n{\n\tchar\t   *outputstr;\n\ttext\t   *jsontext;\n\n\tcheck_stack_depth();\n\n\t/* callers are expected to ensure that null keys are not passed in */\n\tAssert(!(key_scalar && is_null));\n\n\tif (is_null)\n\t{\n\t\tappendStringInfoString(result, \"null\");\n\t\treturn;\n\t}\n\n\tif (key_scalar &&\n\t\t(tcategory == JSONTYPE_ARRAY ||\n\t\t tcategory == JSONTYPE_COMPOSITE ||\n\t\t tcategory == JSONTYPE_JSON ||\n\t\t tcategory == JSONTYPE_CAST))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\n\tswitch (tcategory)\n\t{\n\t\tcase JSONTYPE_ARRAY:\n\t\t\tarray_to_json_internal(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_COMPOSITE:\n\t\t\tcomposite_to_json(val, result, false);\n\t\t\tbreak;\n\t\tcase JSONTYPE_BOOL:\n\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\tif (key_scalar)\n\t\t\t\tescape_json(result, outputstr);\n\t\t\telse\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_NUMERIC:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\n\t\t\t/*\n\t\t\t * Don't call escape_json for a non-key if it's a valid JSON\n\t\t\t * number.\n\t\t\t */\n\t\t\tif (!key_scalar && IsValidJsonNumber(outputstr, strlen(outputstr)))\n\t\t\t\tappendStringInfoString(result, outputstr);\n\t\t\telse\n\t\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_DATE:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, DATEOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMP:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_TIMESTAMPTZ:\n\t\t\t{\n\t\t\t\tchar\t\tbuf[MAXDATELEN + 1];\n\n\t\t\t\tJsonEncodeDateTime(buf, val, TIMESTAMPTZOID);\n\t\t\t\tappendStringInfo(result, \"\\\"%s\\\"\", buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JSONTYPE_JSON:\n\t\t\t/* JSON and JSONB output will already be escaped */\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t\tcase JSONTYPE_CAST:\n\t\t\t/* outfuncoid refers to a cast function, not an output function */\n\t\t\tjsontext = DatumGetTextPP(OidFunctionCall1(outfuncoid, val));\n\t\t\toutputstr = text_to_cstring(jsontext);\n\t\t\tappendStringInfoString(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tpfree(jsontext);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\tescape_json(result, outputstr);\n\t\t\tpfree(outputstr);\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "json_categorize_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1347-1438",
    "snippet": "static void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *extract_mb_char(char *s);",
      "static void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "typoid",
            "outfuncoid",
            "&typisvarlena"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "castfunc"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_coercion_pathway",
          "args": [
            "JSONOID",
            "typoid",
            "COERCION_EXPLICIT",
            "&castfunc"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_is_rowtype",
          "args": [
            "typoid"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "type_is_rowtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2432-2449",
          "snippet": "bool\ntype_is_rowtype(Oid typid)\n{\n\tif (typid == RECORDOID)\n\t\treturn true;\t\t\t/* easy case */\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn true;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\tif (get_typtype(getBaseType(typid)) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\ntype_is_rowtype(Oid typid)\n{\n\tif (typid == RECORDOID)\n\t\treturn true;\t\t\t/* easy case */\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn true;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\tif (get_typtype(getBaseType(typid)) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_element_type(typoid)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_element_type",
          "args": [
            "typoid"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "get_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2525-2545",
          "snippet": "Oid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "typoid"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\nstatic void json_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid);\n\nstatic void\njson_categorize_type(Oid typoid,\n\t\t\t\t\t JsonTypeCategory *tcategory,\n\t\t\t\t\t Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, array and composite types, booleans, and non-builtin\n\t * types where there's a cast to json.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\tcase JSONBOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONTYPE_OTHER;\n\t\t\t\t/* but let's look for a cast to json, if it's not built-in */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT,\n\t\t\t\t\t\t\t\t\t\t\t\t  &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONTYPE_CAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* non builtin type with no cast */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "extract_mb_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1326-1338",
    "snippet": "static char *\nextract_mb_char(char *s)\n{\n\tchar\t   *res;\n\tint\t\t\tlen;\n\n\tlen = pg_mblen(s);\n\tres = palloc(len + 1);\n\tmemcpy(res, s, len);\n\tres[len] = '\\0';\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "s",
            "len"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "s"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\n\nstatic char *\nextract_mb_char(char *s)\n{\n\tchar\t   *res;\n\tint\t\t\tlen;\n\n\tlen = pg_mblen(s);\n\tres = palloc(len + 1);\n\tmemcpy(res, s, len);\n\tres[len] = '\\0';\n\n\treturn res;\n}"
  },
  {
    "function_name": "report_json_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1261-1321",
    "snippet": "static int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errcontext",
          "args": [
            "\"JSON data, line %d: %s%s%s\"",
            "line_number",
            "prefix",
            "ctxt",
            "suffix"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "errcontext_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1009-1024",
          "snippet": "int\nerrcontext_msg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->context_domain, context, true, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcontext_msg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->context_domain, context, true, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctxt",
            "context_start",
            "ctxtlen"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ctxtlen + 1"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "context_start"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "*context_start"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}"
  },
  {
    "function_name": "report_invalid_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1232-1249",
    "snippet": "static void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex))"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_json_context",
          "args": [
            "lex"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "report_json_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1261-1321",
          "snippet": "static int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Token \\\"%s\\\" is invalid.\"",
            "token"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s\"",
            "\"json\""
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "token",
            "lex->token_start",
            "toklen"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "toklen + 1"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}"
  },
  {
    "function_name": "report_parse_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1125-1225",
    "snippet": "static void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected json parse state: %d\"",
            "ctx"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_json_context",
          "args": [
            "lex"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "report_json_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1261-1321",
          "snippet": "static int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Expected string, but found \\\"%s\\\".\"",
            "token"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s\"",
            "\"json\""
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex))"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "token",
            "lex->token_start",
            "toklen"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "toklen + 1"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex))"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "json_lex_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "1027-1118",
    "snippet": "static inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_invalid_token",
          "args": [
            "lex"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1232-1249",
          "snippet": "static void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSON_ALPHANUMERIC_CHAR",
          "args": [
            "*s"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}"
  },
  {
    "function_name": "json_lex_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "754-997",
    "snippet": "static inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex))"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_json_context",
          "args": [
            "lex"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "report_json_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1261-1321",
          "snippet": "static int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic int\nreport_json_context(JsonLexContext *lex)\n{\n\tconst char *context_start;\n\tconst char *context_end;\n\tconst char *line_start;\n\tint\t\t\tline_number;\n\tchar\t   *ctxt;\n\tint\t\t\tctxtlen;\n\tconst char *prefix;\n\tconst char *suffix;\n\n\t/* Choose boundaries for the part of the input we will display */\n\tcontext_start = lex->input;\n\tcontext_end = lex->token_terminator;\n\tline_start = context_start;\n\tline_number = 1;\n\tfor (;;)\n\t{\n\t\t/* Always advance over newlines */\n\t\tif (context_start < context_end && *context_start == '\\n')\n\t\t{\n\t\t\tcontext_start++;\n\t\t\tline_start = context_start;\n\t\t\tline_number++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise, done as soon as we are close enough to context_end */\n\t\tif (context_end - context_start < 50)\n\t\t\tbreak;\n\t\t/* Advance to next multibyte character */\n\t\tif (IS_HIGHBIT_SET(*context_start))\n\t\t\tcontext_start += pg_mblen(context_start);\n\t\telse\n\t\t\tcontext_start++;\n\t}\n\n\t/*\n\t * We add \"...\" to indicate that the excerpt doesn't start at the\n\t * beginning of the line ... but if we're within 3 characters of the\n\t * beginning of the line, we might as well just show the whole line.\n\t */\n\tif (context_start - line_start <= 3)\n\t\tcontext_start = line_start;\n\n\t/* Get a null-terminated copy of the data to present */\n\tctxtlen = context_end - context_start;\n\tctxt = palloc(ctxtlen + 1);\n\tmemcpy(ctxt, context_start, ctxtlen);\n\tctxt[ctxtlen] = '\\0';\n\n\t/*\n\t * Show the context, prefixing \"...\" if not starting at start of line, and\n\t * suffixing \"...\" if not ending at end of line.\n\t */\n\tprefix = (context_start > line_start) ? \"...\" : \"\";\n\tsuffix = (lex->token_type != JSON_TOKEN_END && context_end - lex->input < lex->input_length && *context_end != '\\n' && *context_end != '\\r') ? \"...\" : \"\";\n\n\treturn errcontext(\"JSON data, line %d: %s%s%s\",\n\t\t\t\t\t  line_number, prefix, ctxt, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Unicode low surrogate must follow a high surrogate.\""
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s\"",
            "\"json\""
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "*s"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_mb_char",
          "args": [
            "s"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "extract_mb_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1326-1338",
          "snippet": "static char *\nextract_mb_char(char *s)\n{\n\tchar\t   *res;\n\tint\t\t\tlen;\n\n\tlen = pg_mblen(s);\n\tres = palloc(len + 1);\n\tmemcpy(res, s, len);\n\tres[len] = '\\0';\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic char *extract_mb_char(char *s);\n\nstatic char *\nextract_mb_char(char *s)\n{\n\tchar\t   *res;\n\tint\t\t\tlen;\n\n\tlen = pg_mblen(s);\n\tres = palloc(len + 1);\n\tmemcpy(res, s, len);\n\tres[len] = '\\0';\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "s"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"\\\"\\\\/bfnrt\"",
            "*s"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "'\\t'"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "'\\r'"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "'\\n'"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "'\\f'"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "'\\b'"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "*s"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "lex->strval",
            "(char) ch"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "lex->strval",
            "utf8str",
            "utf8len"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_utf_mblen",
          "args": [
            "(unsigned char *) utf8str"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "540-562",
          "snippet": "int\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nint\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unicode_to_utf8",
          "args": [
            "ch",
            "(unsigned char *) utf8str"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "unicode_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "474-501",
          "snippet": "unsigned char *\nunicode_to_utf8(pg_wchar c, unsigned char *utf8string)\n{\n\tif (c <= 0x7F)\n\t{\n\t\tutf8string[0] = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tutf8string[0] = 0xC0 | ((c >> 6) & 0x1F);\n\t\tutf8string[1] = 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tutf8string[0] = 0xE0 | ((c >> 12) & 0x0F);\n\t\tutf8string[1] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[2] = 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tutf8string[0] = 0xF0 | ((c >> 18) & 0x07);\n\t\tutf8string[1] = 0x80 | ((c >> 12) & 0x3F);\n\t\tutf8string[2] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[3] = 0x80 | (c & 0x3F);\n\t}\n\n\treturn utf8string;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nunsigned char *\nunicode_to_utf8(pg_wchar c, unsigned char *utf8string)\n{\n\tif (c <= 0x7F)\n\t{\n\t\tutf8string[0] = c;\n\t}\n\telse if (c <= 0x7FF)\n\t{\n\t\tutf8string[0] = 0xC0 | ((c >> 6) & 0x1F);\n\t\tutf8string[1] = 0x80 | (c & 0x3F);\n\t}\n\telse if (c <= 0xFFFF)\n\t{\n\t\tutf8string[0] = 0xE0 | ((c >> 12) & 0x0F);\n\t\tutf8string[1] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[2] = 0x80 | (c & 0x3F);\n\t}\n\telse\n\t{\n\t\tutf8string[0] = 0xF0 | ((c >> 18) & 0x07);\n\t\tutf8string[1] = 0x80 | ((c >> 12) & 0x3F);\n\t\tutf8string[2] = 0x80 | ((c >> 6) & 0x3F);\n\t\tutf8string[3] = 0x80 | (c & 0x3F);\n\t}\n\n\treturn utf8string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_token",
          "args": [
            "lex"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1232-1249",
          "snippet": "static void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex))"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "lex->input_length > 0"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resetStringInfo",
          "args": [
            "lex->strval"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}"
  },
  {
    "function_name": "json_lex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "613-749",
    "snippet": "static inline void\njson_lex(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\n\t/* Skip leading whitespace. */\n\ts = lex->token_terminator;\n\tlen = s - lex->input;\n\twhile (len < lex->input_length &&\n\t\t   (*s == ' ' || *s == '\\t' || *s == '\\n' || *s == '\\r'))\n\t{\n\t\tif (*s == '\\n')\n\t\t\t++lex->line_number;\n\t\t++s;\n\t\t++len;\n\t}\n\tlex->token_start = s;\n\n\t/* Determine token type. */\n\tif (len >= lex->input_length)\n\t{\n\t\tlex->token_start = NULL;\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\tlex->token_type = JSON_TOKEN_END;\n\t}\n\telse\n\t\tswitch (*s)\n\t\t{\n\t\t\t\t/* Single-character token, some kind of punctuation mark. */\n\t\t\tcase '{':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_OBJECT_START;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_OBJECT_END;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_ARRAY_START;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_ARRAY_END;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_COMMA;\n\t\t\t\tbreak;\n\t\t\tcase ':':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_COLON;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\t/* string */\n\t\t\t\tjson_lex_string(lex);\n\t\t\t\tlex->token_type = JSON_TOKEN_STRING;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\t/* Negative number. */\n\t\t\t\tjson_lex_number(lex, s + 1, NULL, NULL);\n\t\t\t\tlex->token_type = JSON_TOKEN_NUMBER;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\t/* Positive number. */\n\t\t\t\tjson_lex_number(lex, s, NULL, NULL);\n\t\t\t\tlex->token_type = JSON_TOKEN_NUMBER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tchar\t   *p;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're not dealing with a string, number, legal\n\t\t\t\t\t * punctuation mark, or end of string.  The only legal\n\t\t\t\t\t * tokens we might find here are true, false, and null,\n\t\t\t\t\t * but for error reporting purposes we scan until we see a\n\t\t\t\t\t * non-alphanumeric character.  That way, we can report\n\t\t\t\t\t * the whole word as an unexpected token, rather than just\n\t\t\t\t\t * some unintuitive prefix thereof.\n\t\t\t\t\t */\n\t\t\t\t\tfor (p = s; p - s < lex->input_length - len && JSON_ALPHANUMERIC_CHAR(*p); p++)\n\t\t\t\t\t\t /* skip */ ;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We got some sort of unexpected punctuation or an\n\t\t\t\t\t * otherwise unexpected character, so just complain about\n\t\t\t\t\t * that one character.\n\t\t\t\t\t */\n\t\t\t\t\tif (p == s)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We've got a real alphanumeric token here.  If it\n\t\t\t\t\t * happens to be true, false, or null, all is well.  If\n\t\t\t\t\t * not, error out.\n\t\t\t\t\t */\n\t\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\t\tlex->token_terminator = p;\n\t\t\t\t\tif (p - s == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memcmp(s, \"true\", 4) == 0)\n\t\t\t\t\t\t\tlex->token_type = JSON_TOKEN_TRUE;\n\t\t\t\t\t\telse if (memcmp(s, \"null\", 4) == 0)\n\t\t\t\t\t\t\tlex->token_type = JSON_TOKEN_NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (p - s == 5 && memcmp(s, \"false\", 5) == 0)\n\t\t\t\t\t\tlex->token_type = JSON_TOKEN_FALSE;\n\t\t\t\t\telse\n\t\t\t\t\t\treport_invalid_token(lex);\n\n\t\t\t\t}\n\t\t}\t\t\t\t\t\t/* end of switch */\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_invalid_token",
          "args": [
            "lex"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1232-1249",
          "snippet": "static void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_invalid_token(JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Separate out the offending token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t errdetail(\"Token \\\"%s\\\" is invalid.\", token),\n\t\t\t report_json_context(lex)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s",
            "\"false\"",
            "5"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s",
            "\"null\"",
            "4"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s",
            "\"true\"",
            "4"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JSON_ALPHANUMERIC_CHAR",
          "args": [
            "*p"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "json_lex_number",
          "args": [
            "lex",
            "s",
            "NULL",
            "NULL"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1027-1118",
          "snippet": "static inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_lex_string",
          "args": [
            "lex"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "754-997",
          "snippet": "static inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\n\t/* Skip leading whitespace. */\n\ts = lex->token_terminator;\n\tlen = s - lex->input;\n\twhile (len < lex->input_length &&\n\t\t   (*s == ' ' || *s == '\\t' || *s == '\\n' || *s == '\\r'))\n\t{\n\t\tif (*s == '\\n')\n\t\t\t++lex->line_number;\n\t\t++s;\n\t\t++len;\n\t}\n\tlex->token_start = s;\n\n\t/* Determine token type. */\n\tif (len >= lex->input_length)\n\t{\n\t\tlex->token_start = NULL;\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\tlex->token_type = JSON_TOKEN_END;\n\t}\n\telse\n\t\tswitch (*s)\n\t\t{\n\t\t\t\t/* Single-character token, some kind of punctuation mark. */\n\t\t\tcase '{':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_OBJECT_START;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_OBJECT_END;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_ARRAY_START;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_ARRAY_END;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_COMMA;\n\t\t\t\tbreak;\n\t\t\tcase ':':\n\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\tlex->token_type = JSON_TOKEN_COLON;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\t/* string */\n\t\t\t\tjson_lex_string(lex);\n\t\t\t\tlex->token_type = JSON_TOKEN_STRING;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\t/* Negative number. */\n\t\t\t\tjson_lex_number(lex, s + 1, NULL, NULL);\n\t\t\t\tlex->token_type = JSON_TOKEN_NUMBER;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\t/* Positive number. */\n\t\t\t\tjson_lex_number(lex, s, NULL, NULL);\n\t\t\t\tlex->token_type = JSON_TOKEN_NUMBER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tchar\t   *p;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're not dealing with a string, number, legal\n\t\t\t\t\t * punctuation mark, or end of string.  The only legal\n\t\t\t\t\t * tokens we might find here are true, false, and null,\n\t\t\t\t\t * but for error reporting purposes we scan until we see a\n\t\t\t\t\t * non-alphanumeric character.  That way, we can report\n\t\t\t\t\t * the whole word as an unexpected token, rather than just\n\t\t\t\t\t * some unintuitive prefix thereof.\n\t\t\t\t\t */\n\t\t\t\t\tfor (p = s; p - s < lex->input_length - len && JSON_ALPHANUMERIC_CHAR(*p); p++)\n\t\t\t\t\t\t /* skip */ ;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We got some sort of unexpected punctuation or an\n\t\t\t\t\t * otherwise unexpected character, so just complain about\n\t\t\t\t\t * that one character.\n\t\t\t\t\t */\n\t\t\t\t\tif (p == s)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\t\t\tlex->token_terminator = s + 1;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We've got a real alphanumeric token here.  If it\n\t\t\t\t\t * happens to be true, false, or null, all is well.  If\n\t\t\t\t\t * not, error out.\n\t\t\t\t\t */\n\t\t\t\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\t\t\t\tlex->token_terminator = p;\n\t\t\t\t\tif (p - s == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memcmp(s, \"true\", 4) == 0)\n\t\t\t\t\t\t\tlex->token_type = JSON_TOKEN_TRUE;\n\t\t\t\t\t\telse if (memcmp(s, \"null\", 4) == 0)\n\t\t\t\t\t\t\tlex->token_type = JSON_TOKEN_NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (p - s == 5 && memcmp(s, \"false\", 5) == 0)\n\t\t\t\t\t\tlex->token_type = JSON_TOKEN_FALSE;\n\t\t\t\t\telse\n\t\t\t\t\t\treport_invalid_token(lex);\n\n\t\t\t\t}\n\t\t}\t\t\t\t\t\t/* end of switch */\n}"
  },
  {
    "function_name": "parse_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "569-608",
    "snippet": "static void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lex_expect",
          "args": [
            "JSON_PARSE_ARRAY_NEXT",
            "lex",
            "JSON_TOKEN_ARRAY_END"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "lex_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "172-177",
          "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_array_element",
          "args": [
            "lex",
            "sem"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "parse_array_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "538-567",
          "snippet": "static void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "lex",
            "JSON_TOKEN_COMMA",
            "NULL"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}"
  },
  {
    "function_name": "parse_array_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "538-567",
    "snippet": "static void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate",
            "isnull"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_scalar",
          "args": [
            "lex",
            "sem"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "406-440",
          "snippet": "static inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_array",
          "args": [
            "lex",
            "sem"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "parse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "569-608",
          "snippet": "static void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_object",
          "args": [
            "lex",
            "sem"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "parse_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "488-536",
          "snippet": "static void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate",
            "isnull"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}"
  },
  {
    "function_name": "parse_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "488-536",
    "snippet": "static void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lex_expect",
          "args": [
            "JSON_PARSE_OBJECT_NEXT",
            "lex",
            "JSON_TOKEN_OBJECT_END"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "lex_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "172-177",
          "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_parse_error",
          "args": [
            "JSON_PARSE_OBJECT_START",
            "lex"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "report_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1125-1225",
          "snippet": "static void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_object_field",
          "args": [
            "lex",
            "sem"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "parse_object_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "442-486",
          "snippet": "static void\nparse_object_field(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * An object field is \"fieldname\" : value where value can be a scalar,\n\t * object or array.  Note: in user-facing docs and error messages, we\n\t * generally call a field name a \"key\".\n\t */\n\n\tchar\t   *fname = NULL;\t/* keep compiler quiet */\n\tjson_ofield_action ostart = sem->object_field_start;\n\tjson_ofield_action oend = sem->object_field_end;\n\tbool\t\tisnull;\n\tchar\t  **fnameaddr = NULL;\n\tJsonTokenType tok;\n\n\tif (ostart != NULL || oend != NULL)\n\t\tfnameaddr = &fname;\n\n\tif (!lex_accept(lex, JSON_TOKEN_STRING, fnameaddr))\n\t\treport_parse_error(JSON_PARSE_STRING, lex);\n\n\tlex_expect(JSON_PARSE_OBJECT_LABEL, lex, JSON_TOKEN_COLON);\n\n\ttok = lex_peek(lex);\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate, fname, isnull);\n\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate, fname, isnull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object_field(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * An object field is \"fieldname\" : value where value can be a scalar,\n\t * object or array.  Note: in user-facing docs and error messages, we\n\t * generally call a field name a \"key\".\n\t */\n\n\tchar\t   *fname = NULL;\t/* keep compiler quiet */\n\tjson_ofield_action ostart = sem->object_field_start;\n\tjson_ofield_action oend = sem->object_field_end;\n\tbool\t\tisnull;\n\tchar\t  **fnameaddr = NULL;\n\tJsonTokenType tok;\n\n\tif (ostart != NULL || oend != NULL)\n\t\tfnameaddr = &fname;\n\n\tif (!lex_accept(lex, JSON_TOKEN_STRING, fnameaddr))\n\t\treport_parse_error(JSON_PARSE_STRING, lex);\n\n\tlex_expect(JSON_PARSE_OBJECT_LABEL, lex, JSON_TOKEN_COLON);\n\n\ttok = lex_peek(lex);\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate, fname, isnull);\n\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate, fname, isnull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "lex",
            "JSON_TOKEN_COMMA",
            "NULL"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}"
  },
  {
    "function_name": "parse_object_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "442-486",
    "snippet": "static void\nparse_object_field(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * An object field is \"fieldname\" : value where value can be a scalar,\n\t * object or array.  Note: in user-facing docs and error messages, we\n\t * generally call a field name a \"key\".\n\t */\n\n\tchar\t   *fname = NULL;\t/* keep compiler quiet */\n\tjson_ofield_action ostart = sem->object_field_start;\n\tjson_ofield_action oend = sem->object_field_end;\n\tbool\t\tisnull;\n\tchar\t  **fnameaddr = NULL;\n\tJsonTokenType tok;\n\n\tif (ostart != NULL || oend != NULL)\n\t\tfnameaddr = &fname;\n\n\tif (!lex_accept(lex, JSON_TOKEN_STRING, fnameaddr))\n\t\treport_parse_error(JSON_PARSE_STRING, lex);\n\n\tlex_expect(JSON_PARSE_OBJECT_LABEL, lex, JSON_TOKEN_COLON);\n\n\ttok = lex_peek(lex);\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate, fname, isnull);\n\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate, fname, isnull);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate",
            "fname",
            "isnull"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_scalar",
          "args": [
            "lex",
            "sem"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "406-440",
          "snippet": "static inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_array",
          "args": [
            "lex",
            "sem"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "parse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "569-608",
          "snippet": "static void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_object",
          "args": [
            "lex",
            "sem"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "parse_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "488-536",
          "snippet": "static void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate",
            "fname",
            "isnull"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_expect",
          "args": [
            "JSON_PARSE_OBJECT_LABEL",
            "lex",
            "JSON_TOKEN_COLON"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "lex_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "172-177",
          "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_parse_error",
          "args": [
            "JSON_PARSE_STRING",
            "lex"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "report_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1125-1225",
          "snippet": "static void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "lex",
            "JSON_TOKEN_STRING",
            "fnameaddr"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object_field(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * An object field is \"fieldname\" : value where value can be a scalar,\n\t * object or array.  Note: in user-facing docs and error messages, we\n\t * generally call a field name a \"key\".\n\t */\n\n\tchar\t   *fname = NULL;\t/* keep compiler quiet */\n\tjson_ofield_action ostart = sem->object_field_start;\n\tjson_ofield_action oend = sem->object_field_end;\n\tbool\t\tisnull;\n\tchar\t  **fnameaddr = NULL;\n\tJsonTokenType tok;\n\n\tif (ostart != NULL || oend != NULL)\n\t\tfnameaddr = &fname;\n\n\tif (!lex_accept(lex, JSON_TOKEN_STRING, fnameaddr))\n\t\treport_parse_error(JSON_PARSE_STRING, lex);\n\n\tlex_expect(JSON_PARSE_OBJECT_LABEL, lex, JSON_TOKEN_COLON);\n\n\ttok = lex_peek(lex);\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate, fname, isnull);\n\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate, fname, isnull);\n}"
  },
  {
    "function_name": "parse_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "406-440",
    "snippet": "static inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sem->semstate",
            "val",
            "tok"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_parse_error",
          "args": [
            "JSON_PARSE_VALUE",
            "lex"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "report_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1125-1225",
          "snippet": "static void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "lex",
            "JSON_TOKEN_STRING",
            "valaddr"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}"
  },
  {
    "function_name": "json_count_array_elements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "366-395",
    "snippet": "int\njson_count_array_elements(JsonLexContext *lex)\n{\n\tJsonLexContext copylex;\n\tint\t\t\tcount;\n\n\t/*\n\t * It's safe to do this with a shallow copy because the lexical routines\n\t * don't scribble on the input. They do scribble on the other pointers\n\t * etc, so doing this with a copy makes that safe.\n\t */\n\tmemcpy(&copylex, lex, sizeof(JsonLexContext));\n\tcopylex.strval = NULL;\t\t/* not interested in values here */\n\tcopylex.lex_level++;\n\n\tcount = 0;\n\tlex_expect(JSON_PARSE_ARRAY_START, &copylex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(&copylex) != JSON_TOKEN_ARRAY_END)\n\t{\n\t\tdo\n\t\t{\n\t\t\tcount++;\n\t\t\tparse_array_element(&copylex, &nullSemAction);\n\t\t}\n\t\twhile (lex_accept(&copylex, JSON_TOKEN_COMMA, NULL));\n\t}\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, &copylex, JSON_TOKEN_ARRAY_END);\n\n\treturn count;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static char *extract_mb_char(char *s);",
      "static JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lex_expect",
          "args": [
            "JSON_PARSE_ARRAY_NEXT",
            "&copylex",
            "JSON_TOKEN_ARRAY_END"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "lex_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "172-177",
          "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "&copylex",
            "JSON_TOKEN_COMMA",
            "NULL"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_array_element",
          "args": [
            "&copylex",
            "&nullSemAction"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "parse_array_element",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "538-567",
          "snippet": "static void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array_element(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tjson_aelem_action astart = sem->array_element_start;\n\tjson_aelem_action aend = sem->array_element_end;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tbool\t\tisnull;\n\n\tisnull = tok == JSON_TOKEN_NULL;\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate, isnull);\n\n\t/* an array element is any object, array or scalar */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem);\n\t}\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate, isnull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "&copylex"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&copylex",
            "lex",
            "sizeof(JsonLexContext)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\nstatic JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};\n\nint\njson_count_array_elements(JsonLexContext *lex)\n{\n\tJsonLexContext copylex;\n\tint\t\t\tcount;\n\n\t/*\n\t * It's safe to do this with a shallow copy because the lexical routines\n\t * don't scribble on the input. They do scribble on the other pointers\n\t * etc, so doing this with a copy makes that safe.\n\t */\n\tmemcpy(&copylex, lex, sizeof(JsonLexContext));\n\tcopylex.strval = NULL;\t\t/* not interested in values here */\n\tcopylex.lex_level++;\n\n\tcount = 0;\n\tlex_expect(JSON_PARSE_ARRAY_START, &copylex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(&copylex) != JSON_TOKEN_ARRAY_END)\n\t{\n\t\tdo\n\t\t{\n\t\t\tcount++;\n\t\t\tparse_array_element(&copylex, &nullSemAction);\n\t\t}\n\t\twhile (lex_accept(&copylex, JSON_TOKEN_COMMA, NULL));\n\t}\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, &copylex, JSON_TOKEN_ARRAY_END);\n\n\treturn count;\n}"
  },
  {
    "function_name": "pg_parse_json",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "331-356",
    "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
      "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lex_expect",
          "args": [
            "JSON_PARSE_END",
            "lex",
            "JSON_TOKEN_END"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "lex_expect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "172-177",
          "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_scalar",
          "args": [
            "lex",
            "sem"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "406-440",
          "snippet": "static inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nparse_scalar(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tchar\t   *val = NULL;\n\tjson_scalar_action sfunc = sem->scalar;\n\tchar\t  **valaddr;\n\tJsonTokenType tok = lex_peek(lex);\n\n\tvaladdr = sfunc == NULL ? NULL : &val;\n\n\t/* a scalar must be a string, a number, true, false, or null */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tlex_accept(lex, JSON_TOKEN_TRUE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tlex_accept(lex, JSON_TOKEN_FALSE, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tlex_accept(lex, JSON_TOKEN_NULL, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\tlex_accept(lex, JSON_TOKEN_NUMBER, valaddr);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tlex_accept(lex, JSON_TOKEN_STRING, valaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treport_parse_error(JSON_PARSE_VALUE, lex);\n\t}\n\n\tif (sfunc != NULL)\n\t\t(*sfunc) (sem->semstate, val, tok);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_array",
          "args": [
            "lex",
            "sem"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "parse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "569-608",
          "snippet": "static void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_array(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an array is a possibly empty sequence of array elements, separated by\n\t * commas and surrounded by square brackets.\n\t */\n\tjson_struct_action astart = sem->array_start;\n\tjson_struct_action aend = sem->array_end;\n\n\tcheck_stack_depth();\n\n\tif (astart != NULL)\n\t\t(*astart) (sem->semstate);\n\n\t/*\n\t * Data inside an array is at a higher nesting level than the array\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the array start and restore it before we call the routine for the\n\t * array end.\n\t */\n\tlex->lex_level++;\n\n\tlex_expect(JSON_PARSE_ARRAY_START, lex, JSON_TOKEN_ARRAY_START);\n\tif (lex_peek(lex) != JSON_TOKEN_ARRAY_END)\n\t{\n\n\t\tparse_array_element(lex, sem);\n\n\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\tparse_array_element(lex, sem);\n\t}\n\n\tlex_expect(JSON_PARSE_ARRAY_NEXT, lex, JSON_TOKEN_ARRAY_END);\n\n\tlex->lex_level--;\n\n\tif (aend != NULL)\n\t\t(*aend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_object",
          "args": [
            "lex",
            "sem"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "parse_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "488-536",
          "snippet": "static void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic void\nparse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n\tjson_struct_action oend = sem->object_end;\n\tJsonTokenType tok;\n\n\tcheck_stack_depth();\n\n\tif (ostart != NULL)\n\t\t(*ostart) (sem->semstate);\n\n\t/*\n\t * Data inside an object is at a higher nesting level than the object\n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_peek",
          "args": [
            "lex"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lex_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "123-127",
          "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "json_lex",
          "args": [
            "lex"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "754-997",
          "snippet": "static inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
  },
  {
    "function_name": "makeJsonLexContextCstringLen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "308-319",
    "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonLexContext)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
  },
  {
    "function_name": "makeJsonLexContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "300-306",
    "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeJsonLexContextCstringLen",
          "args": [
            "VARDATA_ANY(json)",
            "VARSIZE_ANY_EXHDR(json)",
            "need_escapes"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContextCstringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "308-319",
          "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "json"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "json"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
  },
  {
    "function_name": "json_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "271-286",
    "snippet": "Datum\njson_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\tJsonLexContext *lex;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\t/* Validate it. */\n\tlex = makeJsonLexContextCstringLen(str, nbytes, false);\n\tpg_parse_json(lex, &nullSemAction);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(str, nbytes));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(str, nbytes)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str",
            "nbytes"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "&nullSemAction"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContextCstringLen",
          "args": [
            "str",
            "nbytes",
            "false"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContextCstringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "308-319",
          "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};\n\nDatum\njson_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\tJsonLexContext *lex;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\t/* Validate it. */\n\tlex = makeJsonLexContextCstringLen(str, nbytes, false);\n\tpg_parse_json(lex, &nullSemAction);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(str, nbytes));\n}"
  },
  {
    "function_name": "json_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "257-266",
    "snippet": "Datum\njson_send(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "VARDATA_ANY(t)",
            "VARSIZE_ANY_EXHDR(t)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_send(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "json_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "245-252",
    "snippet": "Datum\njson_out(PG_FUNCTION_ARGS)\n{\n\t/* we needn't detoast because text_to_cstring will handle that */\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "TextDatumGetCString(txt)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "txt"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\njson_out(PG_FUNCTION_ARGS)\n{\n\t/* we needn't detoast because text_to_cstring will handle that */\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}"
  },
  {
    "function_name": "json_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "227-240",
    "snippet": "Datum\njson_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *json = PG_GETARG_CSTRING(0);\n\ttext\t   *result = cstring_to_text(json);\n\tJsonLexContext *lex;\n\n\t/* validate it */\n\tlex = makeJsonLexContext(result, false);\n\tpg_parse_json(lex, &nullSemAction);\n\n\t/* Internal representation is the same as text, for now */\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);",
      "static JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "&nullSemAction"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "result",
            "false"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "json"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic JsonSemAction nullSemAction =\n{\n\tNULL, NULL, NULL, NULL, NULL,\n\tNULL, NULL, NULL, NULL, NULL\n};\n\nDatum\njson_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *json = PG_GETARG_CSTRING(0);\n\ttext\t   *result = cstring_to_text(json);\n\tJsonLexContext *lex;\n\n\t/* validate it */\n\tlex = makeJsonLexContext(result, false);\n\tpg_parse_json(lex, &nullSemAction);\n\n\t/* Internal representation is the same as text, for now */\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "IsValidJsonNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "192-222",
    "snippet": "bool\nIsValidJsonNumber(const char *str, int len)\n{\n\tbool\t\tnumeric_error;\n\tint\t\t\ttotal_len;\n\tJsonLexContext dummy_lex;\n\n\tif (len <= 0)\n\t\treturn false;\n\n\t/*\n\t * json_lex_number expects a leading  '-' to have been eaten already.\n\t *\n\t * having to cast away the constness of str is ugly, but there's not much\n\t * easy alternative.\n\t */\n\tif (*str == '-')\n\t{\n\t\tdummy_lex.input = (char *) str + 1;\n\t\tdummy_lex.input_length = len - 1;\n\t}\n\telse\n\t{\n\t\tdummy_lex.input = (char *) str;\n\t\tdummy_lex.input_length = len;\n\t}\n\n\tjson_lex_number(&dummy_lex, dummy_lex.input, &numeric_error, &total_len);\n\n\treturn (!numeric_error) && (total_len == dummy_lex.input_length);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);",
      "static char *extract_mb_char(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "json_lex_number",
          "args": [
            "&dummy_lex",
            "dummy_lex.input",
            "&numeric_error",
            "&total_len"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1027-1118",
          "snippet": "static inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len)\n{\n\tbool\t\terror = false;\n\tint\t\t\tlen = s - lex->input;\n\n\t/* Part (1): leading sign indicator. */\n\t/* Caller already did this for us; so do nothing. */\n\n\t/* Part (2): parse main digit string. */\n\tif (len < lex->input_length && *s == '0')\n\t{\n\t\ts++;\n\t\tlen++;\n\t}\n\telse if (len < lex->input_length && *s >= '1' && *s <= '9')\n\t{\n\t\tdo\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t}\n\telse\n\t\terror = true;\n\n\t/* Part (3): parse optional decimal portion. */\n\tif (len < lex->input_length && *s == '.')\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/* Part (4): parse optional exponent. */\n\tif (len < lex->input_length && (*s == 'e' || *s == 'E'))\n\t{\n\t\ts++;\n\t\tlen++;\n\t\tif (len < lex->input_length && (*s == '+' || *s == '-'))\n\t\t{\n\t\t\ts++;\n\t\t\tlen++;\n\t\t}\n\t\tif (len == lex->input_length || *s < '0' || *s > '9')\n\t\t\terror = true;\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts++;\n\t\t\t\tlen++;\n\t\t\t} while (len < lex->input_length && *s >= '0' && *s <= '9');\n\t\t}\n\t}\n\n\t/*\n\t * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff\n\t * here should be considered part of the token for error-reporting\n\t * purposes.\n\t */\n\tfor (; len < lex->input_length && JSON_ALPHANUMERIC_CHAR(*s); s++, len++)\n\t\terror = true;\n\n\tif (total_len != NULL)\n\t\t*total_len = len;\n\n\tif (num_err != NULL)\n\t{\n\t\t/* let the caller handle any error */\n\t\t*num_err = error;\n\t}\n\telse\n\t{\n\t\t/* return token endpoint */\n\t\tlex->prev_token_terminator = lex->token_terminator;\n\t\tlex->token_terminator = s;\n\t\t/* handle error if any */\n\t\tif (error)\n\t\t\treport_invalid_token(lex);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex_number(JsonLexContext *lex, char *s,\n\t\t\t\tbool *num_err, int *total_len);\nstatic char *extract_mb_char(char *s);\n\nbool\nIsValidJsonNumber(const char *str, int len)\n{\n\tbool\t\tnumeric_error;\n\tint\t\t\ttotal_len;\n\tJsonLexContext dummy_lex;\n\n\tif (len <= 0)\n\t\treturn false;\n\n\t/*\n\t * json_lex_number expects a leading  '-' to have been eaten already.\n\t *\n\t * having to cast away the constness of str is ugly, but there's not much\n\t * easy alternative.\n\t */\n\tif (*str == '-')\n\t{\n\t\tdummy_lex.input = (char *) str + 1;\n\t\tdummy_lex.input_length = len - 1;\n\t}\n\telse\n\t{\n\t\tdummy_lex.input = (char *) str;\n\t\tdummy_lex.input_length = len;\n\t}\n\n\tjson_lex_number(&dummy_lex, dummy_lex.input, &numeric_error, &total_len);\n\n\treturn (!numeric_error) && (total_len == dummy_lex.input_length);\n}"
  },
  {
    "function_name": "lex_expect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "172-177",
    "snippet": "static inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_parse_error",
          "args": [
            "ctx",
            "lex"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "report_parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1125-1225",
          "snippet": "static void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic void\nreport_parse_error(JsonParseContext ctx, JsonLexContext *lex)\n{\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\n\t/* Handle case where the input ended prematurely. */\n\tif (lex->token_start == NULL || lex->token_type == JSON_TOKEN_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"The input string ended unexpectedly.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Separate out the current token. */\n\ttoklen = lex->token_terminator - lex->token_start;\n\ttoken = palloc(toklen + 1);\n\tmemcpy(token, lex->token_start, toklen);\n\ttoken[toklen] = '\\0';\n\n\t/* Complain, with the appropriate detail message. */\n\tif (ctx == JSON_PARSE_END)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Expected end of input, but found \\\"%s\\\".\",\n\t\t\t\t\t\t   token),\n\t\t\t\t report_json_context(lex)));\n\telse\n\t{\n\t\tswitch (ctx)\n\t\t{\n\t\t\tcase JSON_PARSE_VALUE:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected JSON value, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_STRING:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected array element or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_ARRAY_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"]\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_START:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_LABEL:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\":\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_NEXT:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected \\\",\\\" or \\\"}\\\", but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tcase JSON_PARSE_OBJECT_COMMA:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Expected string, but found \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t   token),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected json parse state: %d\", ctx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lex_accept",
          "args": [
            "lex",
            "token",
            "NULL"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "lex_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "138-164",
          "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline void\nlex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token)\n{\n\tif (!lex_accept(lex, token, NULL))\n\t\treport_parse_error(ctx, lex);\n}"
  },
  {
    "function_name": "lex_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "138-164",
    "snippet": "static inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "json_lex",
          "args": [
            "lex"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "json_lex_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "754-997",
          "snippet": "static inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);",
            "static char *extract_mb_char(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\nstatic char *extract_mb_char(char *s);\n\nstatic inline void\njson_lex_string(JsonLexContext *lex)\n{\n\tchar\t   *s;\n\tint\t\t\tlen;\n\tint\t\t\thi_surrogate = -1;\n\n\tif (lex->strval != NULL)\n\t\tresetStringInfo(lex->strval);\n\n\tAssert(lex->input_length > 0);\n\ts = lex->token_start;\n\tlen = lex->token_start - lex->input;\n\tfor (;;)\n\t{\n\t\ts++;\n\t\tlen++;\n\t\t/* Premature end of the string. */\n\t\tif (len >= lex->input_length)\n\t\t{\n\t\t\tlex->token_terminator = s;\n\t\t\treport_invalid_token(lex);\n\t\t}\n\t\telse if (*s == '\"')\n\t\t\tbreak;\n\t\telse if ((unsigned char) *s < 32)\n\t\t{\n\t\t\t/* Per RFC4627, these characters MUST be escaped. */\n\t\t\t/* Since *s isn't printable, exclude it from the context string */\n\t\t\tlex->token_terminator = s;\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t errdetail(\"Character with value 0x%02x must be escaped.\",\n\t\t\t\t\t\t\t   (unsigned char) *s),\n\t\t\t\t\t report_json_context(lex)));\n\t\t}\n\t\telse if (*s == '\\\\')\n\t\t{\n\t\t\t/* OK, we have an escape character. */\n\t\t\ts++;\n\t\t\tlen++;\n\t\t\tif (len >= lex->input_length)\n\t\t\t{\n\t\t\t\tlex->token_terminator = s;\n\t\t\t\treport_invalid_token(lex);\n\t\t\t}\n\t\t\telse if (*s == 'u')\n\t\t\t{\n\t\t\t\tint\t\t\ti;\n\t\t\t\tint\t\t\tch = 0;\n\n\t\t\t\tfor (i = 1; i <= 4; i++)\n\t\t\t\t{\n\t\t\t\t\ts++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (len >= lex->input_length)\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s;\n\t\t\t\t\t\treport_invalid_token(lex);\n\t\t\t\t\t}\n\t\t\t\t\telse if (*s >= '0' && *s <= '9')\n\t\t\t\t\t\tch = (ch * 16) + (*s - '0');\n\t\t\t\t\telse if (*s >= 'a' && *s <= 'f')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'a') + 10;\n\t\t\t\t\telse if (*s >= 'A' && *s <= 'F')\n\t\t\t\t\t\tch = (ch * 16) + (*s - 'A') + 10;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\"\\\\u\\\" must be followed by four hexadecimal digits.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tutf8str[5];\n\t\t\t\t\tint\t\t\tutf8len;\n\n\t\t\t\t\tif (ch >= 0xd800 && ch <= 0xdbff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode high surrogate must not follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\thi_surrogate = (ch & 0x3ff) << 10;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch >= 0xdc00 && ch <= 0xdfff)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (hi_surrogate == -1)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t\tch = 0x10000 + hi_surrogate + (ch & 0x3ff);\n\t\t\t\t\t\thi_surrogate = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For UTF8, replace the escape sequence by the actual\n\t\t\t\t\t * utf8 character in lex->strval. Do this also for other\n\t\t\t\t\t * encodings if the escape designates an ASCII character,\n\t\t\t\t\t * otherwise raise an error.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (ch == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* We can't allow this, since our TEXT type doesn't */\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"\\\\u0000 cannot be converted to text.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t\t{\n\t\t\t\t\t\tunicode_to_utf8(ch, (unsigned char *) utf8str);\n\t\t\t\t\t\tutf8len = pg_utf_mblen((unsigned char *) utf8str);\n\t\t\t\t\t\tappendBinaryStringInfo(lex->strval, utf8str, utf8len);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch <= 0x007f)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is the only way to designate things like a\n\t\t\t\t\t\t * form feed character in JSON, so it's useful in all\n\t\t\t\t\t\t * encodings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, (char) ch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t\t\t\t\t\t errmsg(\"unsupported Unicode escape sequence\"),\n\t\t\t\t\t\t\t\t errdetail(\"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8.\"),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lex->strval != NULL)\n\t\t\t{\n\t\t\t\tif (hi_surrogate != -1)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\t\tswitch (*s)\n\t\t\t\t{\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\b');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\f');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\r');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tappendStringInfoChar(lex->strval, '\\t');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Not a valid string escape, so error out. */\n\t\t\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\",\n\t\t\t\t\t\t\t\t\t\t\"json\"),\n\t\t\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strchr(\"\\\"\\\\/bfnrt\", *s) == NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Simpler processing if we're not bothered about de-escaping\n\t\t\t\t *\n\t\t\t\t * It's very tempting to remove the strchr() call here and\n\t\t\t\t * replace it with a switch statement, but testing so far has\n\t\t\t\t * shown it's not a performance win.\n\t\t\t\t */\n\t\t\t\tlex->token_terminator = s + pg_mblen(s);\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Escape sequence \\\"\\\\%s\\\" is invalid.\",\n\t\t\t\t\t\t\t\t   extract_mb_char(s)),\n\t\t\t\t\t\t report_json_context(lex)));\n\t\t\t}\n\n\t\t}\n\t\telse if (lex->strval != NULL)\n\t\t{\n\t\t\tif (hi_surrogate != -1)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t\t\t report_json_context(lex)));\n\n\t\t\tappendStringInfoChar(lex->strval, *s);\n\t\t}\n\n\t}\n\n\tif (hi_surrogate != -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"json\"),\n\t\t\t\t errdetail(\"Unicode low surrogate must follow a high surrogate.\"),\n\t\t\t\t report_json_context(lex)));\n\n\t/* Hooray, we found the end of the string! */\n\tlex->prev_token_terminator = lex->token_terminator;\n\tlex->token_terminator = s + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tokstr",
            "lex->token_start",
            "len"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "lex->strval->data"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline bool\nlex_accept(JsonLexContext *lex, JsonTokenType token, char **lexeme)\n{\n\tif (lex->token_type == token)\n\t{\n\t\tif (lexeme != NULL)\n\t\t{\n\t\t\tif (lex->token_type == JSON_TOKEN_STRING)\n\t\t\t{\n\t\t\t\tif (lex->strval != NULL)\n\t\t\t\t\t*lexeme = pstrdup(lex->strval->data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\t\t\tlen = (lex->token_terminator - lex->token_start);\n\t\t\t\tchar\t   *tokstr = palloc(len + 1);\n\n\t\t\t\tmemcpy(tokstr, lex->token_start, len);\n\t\t\t\ttokstr[len] = '\\0';\n\t\t\t\t*lexeme = tokstr;\n\t\t\t}\n\t\t}\n\t\tjson_lex(lex);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "lex_peek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
    "lines": "123-127",
    "snippet": "static inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void json_lex(JsonLexContext *lex);",
      "static inline void json_lex_string(JsonLexContext *lex);",
      "static int\treport_json_context(JsonLexContext *lex);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nstatic inline JsonTokenType\nlex_peek(JsonLexContext *lex)\n{\n\treturn lex->token_type;\n}"
  }
]