[
  {
    "function_name": "GenerationCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "743-836",
    "snippet": "static void\nGenerationCheck(MemoryContext context)\n{\n\tGenerationContext *gen = (GenerationContext *) context;\n\tconst char *name = context->name;\n\tdlist_iter\titer;\n\n\t/* walk all blocks in this context */\n\tdlist_foreach(iter, &gen->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\t\tint\t\t\tnfree,\n\t\t\t\t\tnchunks;\n\t\tchar\t   *ptr;\n\n\t\t/*\n\t\t * nfree > nchunks is surely wrong, and we don't expect to see\n\t\t * equality either, because such a block should have gotten freed.\n\t\t */\n\t\tif (block->nfree >= block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p exceeds %d allocated\",\n\t\t\t\t name, block->nfree, block, block->nchunks);\n\n\t\t/* Now walk through the chunks and count them. */\n\t\tnfree = 0;\n\t\tnchunks = 0;\n\t\tptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\n\t\twhile (ptr < block->freeptr)\n\t\t{\n\t\t\tGenerationChunk *chunk = (GenerationChunk *) ptr;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\t\t/* move to the next chunk */\n\t\t\tptr += (chunk->size + Generation_CHUNKHDRSZ);\n\n\t\t\tnchunks += 1;\n\n\t\t\t/* chunks have both block and context pointers, so check both */\n\t\t\tif (chunk->block != block)\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for valid context pointer.  Note this is an incomplete\n\t\t\t * test, since palloc(0) produces an allocated chunk with\n\t\t\t * requested_size == 0.\n\t\t\t */\n\t\t\tif ((chunk->requested_size > 0 && chunk->context != gen) ||\n\t\t\t\t(chunk->context != gen && chunk->context != NULL))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus context link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* now make sure the chunk size is correct */\n\t\t\tif (chunk->size < chunk->requested_size ||\n\t\t\t\tchunk->size != MAXALIGN(chunk->size))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus chunk size in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* is chunk allocated? */\n\t\t\tif (chunk->context != NULL)\n\t\t\t{\n\t\t\t\t/* check sentinel, but only in allocated blocks */\n\t\t\t\tif (chunk->requested_size < chunk->size &&\n\t\t\t\t\t!sentinel_ok(chunk, Generation_CHUNKHDRSZ + chunk->requested_size))\n\t\t\t\t\telog(WARNING, \"problem in Generation %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t name, block, chunk);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnfree += 1;\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->context != NULL)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we got the expected number of allocated and free chunks\n\t\t * (as tracked in the block header).\n\t\t */\n\t\tif (nchunks != block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of allocated chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nchunks, block, block->nchunks);\n\n\t\tif (nfree != block->nfree)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nfree, block, block->nfree);\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)",
      "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)",
      "#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void GenerationFree(MemoryContext context, void *pointer);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"problem in Generation %s: number of free chunks %d in block %p does not match header %d\"",
            "name",
            "nfree",
            "block",
            "block->nfree"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "chunk",
            "Generation_CHUNKHDRSZ + chunk->requested_size"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "chunk->size"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "GenerationBlock",
            "node",
            "iter.cur"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "&gen->blocks"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationCheck(MemoryContext context)\n{\n\tGenerationContext *gen = (GenerationContext *) context;\n\tconst char *name = context->name;\n\tdlist_iter\titer;\n\n\t/* walk all blocks in this context */\n\tdlist_foreach(iter, &gen->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\t\tint\t\t\tnfree,\n\t\t\t\t\tnchunks;\n\t\tchar\t   *ptr;\n\n\t\t/*\n\t\t * nfree > nchunks is surely wrong, and we don't expect to see\n\t\t * equality either, because such a block should have gotten freed.\n\t\t */\n\t\tif (block->nfree >= block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p exceeds %d allocated\",\n\t\t\t\t name, block->nfree, block, block->nchunks);\n\n\t\t/* Now walk through the chunks and count them. */\n\t\tnfree = 0;\n\t\tnchunks = 0;\n\t\tptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\n\t\twhile (ptr < block->freeptr)\n\t\t{\n\t\t\tGenerationChunk *chunk = (GenerationChunk *) ptr;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\t\t/* move to the next chunk */\n\t\t\tptr += (chunk->size + Generation_CHUNKHDRSZ);\n\n\t\t\tnchunks += 1;\n\n\t\t\t/* chunks have both block and context pointers, so check both */\n\t\t\tif (chunk->block != block)\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for valid context pointer.  Note this is an incomplete\n\t\t\t * test, since palloc(0) produces an allocated chunk with\n\t\t\t * requested_size == 0.\n\t\t\t */\n\t\t\tif ((chunk->requested_size > 0 && chunk->context != gen) ||\n\t\t\t\t(chunk->context != gen && chunk->context != NULL))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus context link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* now make sure the chunk size is correct */\n\t\t\tif (chunk->size < chunk->requested_size ||\n\t\t\t\tchunk->size != MAXALIGN(chunk->size))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus chunk size in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* is chunk allocated? */\n\t\t\tif (chunk->context != NULL)\n\t\t\t{\n\t\t\t\t/* check sentinel, but only in allocated blocks */\n\t\t\t\tif (chunk->requested_size < chunk->size &&\n\t\t\t\t\t!sentinel_ok(chunk, Generation_CHUNKHDRSZ + chunk->requested_size))\n\t\t\t\t\telog(WARNING, \"problem in Generation %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t name, block, chunk);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnfree += 1;\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->context != NULL)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we got the expected number of allocated and free chunks\n\t\t * (as tracked in the block header).\n\t\t */\n\t\tif (nchunks != block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of allocated chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nchunks, block, block->nchunks);\n\n\t\tif (nfree != block->nfree)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nfree, block, block->nfree);\n\t}\n}"
  },
  {
    "function_name": "GenerationStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "685-730",
    "snippet": "static void\nGenerationStats(MemoryContext context,\n\t\t\t\tMemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t\tMemoryContextCounters *totals)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tSize\t\tnblocks = 0;\n\tSize\t\tnchunks = 0;\n\tSize\t\tnfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tdlist_iter\titer;\n\n\t/* Include context header in totalspace */\n\ttotalspace = MAXALIGN(sizeof(GenerationContext));\n\n\tdlist_foreach(iter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\n\t\tnblocks++;\n\t\tnchunks += block->nchunks;\n\t\tnfreechunks += block->nfree;\n\t\ttotalspace += block->blksize;\n\t\tfreespace += (block->endptr - block->freeptr);\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks (%zd chunks); %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, nchunks, freespace,\n\t\t\t\t nfreechunks, totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += nfreechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);",
      "static void GenerationStats(MemoryContext context,\n\t\t\t\tMemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t\tMemoryContextCounters *totals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printfunc",
          "args": [
            "context",
            "passthru",
            "stats_string"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "stats_string",
            "sizeof(stats_string)",
            "\"%zu total in %zd blocks (%zd chunks); %zu free (%zd chunks); %zu used\"",
            "totalspace",
            "nblocks",
            "nchunks",
            "freespace",
            "nfreechunks",
            "totalspace - freespace"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "GenerationBlock",
            "node",
            "iter.cur"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "&set->blocks"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(GenerationContext)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\nstatic void GenerationStats(MemoryContext context,\n\t\t\t\tMemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t\tMemoryContextCounters *totals);\n\nstatic void\nGenerationStats(MemoryContext context,\n\t\t\t\tMemoryStatsPrintFunc printfunc, void *passthru,\n\t\t\t\tMemoryContextCounters *totals)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tSize\t\tnblocks = 0;\n\tSize\t\tnchunks = 0;\n\tSize\t\tnfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tdlist_iter\titer;\n\n\t/* Include context header in totalspace */\n\ttotalspace = MAXALIGN(sizeof(GenerationContext));\n\n\tdlist_foreach(iter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\n\t\tnblocks++;\n\t\tnchunks += block->nchunks;\n\t\tnfreechunks += block->nfree;\n\t\ttotalspace += block->blksize;\n\t\tfreespace += (block->endptr - block->freeptr);\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks (%zd chunks); %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, nchunks, freespace,\n\t\t\t\t nfreechunks, totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += nfreechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}"
  },
  {
    "function_name": "GenerationIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "666-672",
    "snippet": "static bool\nGenerationIsEmpty(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\n\treturn dlist_is_empty(&set->blocks);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlist_is_empty",
          "args": [
            "&set->blocks"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic bool\nGenerationIsEmpty(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\n\treturn dlist_is_empty(&set->blocks);\n}"
  },
  {
    "function_name": "GenerationGetChunkSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "650-660",
    "snippet": "static Size\nGenerationGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tSize\t\tresult;\n\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\tresult = chunk->size + Generation_CHUNKHDRSZ;\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\treturn result;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)",
      "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void GenerationFree(MemoryContext context, void *pointer);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic Size\nGenerationGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tSize\t\tresult;\n\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\tresult = chunk->size + Generation_CHUNKHDRSZ;\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\treturn result;\n}"
  },
  {
    "function_name": "GenerationRealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "534-643",
    "snippet": "static void *\nGenerationRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationPointer newPointer;\n\tSize\t\toldsize;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\toldsize = chunk->size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < oldsize)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n\t/*\n\t * Maybe the allocated area already is >= the new size.  (In particular,\n\t * we always fall out here if the requested size is a decrease.)\n\t *\n\t * This memory context does not use power-of-2 chunk sizing and instead\n\t * carves the chunks to be as small as possible, so most repalloc() calls\n\t * will end up in the palloc/memcpy/pfree branch.\n\t *\n\t * XXX Perhaps we should annotate this condition with unlikely()?\n\t */\n\tif (oldsize >= size)\n\t{\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tSize\t\toldrequest = chunk->requested_size;\n\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\tif (size > oldrequest)\n\t\t\trandomize_mem((char *) pointer + oldrequest,\n\t\t\t\t\t\t  size - oldrequest);\n#endif\n\n\t\tchunk->requested_size = size;\n\n\t\t/*\n\t\t * If this is an increase, mark any newly-available part UNDEFINED.\n\t\t * Otherwise, mark the obsolete part NOACCESS.\n\t\t */\n\t\tif (size > oldrequest)\n\t\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + oldrequest,\n\t\t\t\t\t\t\t\t\t\tsize - oldrequest);\n\t\telse\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size,\n\t\t\t\t\t\t\t\t\t   oldsize - size);\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < oldsize)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't have the information to determine whether we're growing\n\t\t * the old request or shrinking it, so we conservatively mark the\n\t\t * entire new allocation DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(pointer, oldsize);\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, size);\n#endif\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\n\t/* allocate new chunk */\n\tnewPointer = GenerationAlloc((MemoryContext) set, size);\n\n\t/* leave immediately if request was not completed */\n\tif (newPointer == NULL)\n\t{\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * GenerationAlloc() may have returned a region that is still NOACCESS.\n\t * Change it to UNDEFINED for the moment; memcpy() will then transfer\n\t * definedness from the old allocation to the new.  If we know the old\n\t * allocation, copy just that much.  Otherwise, make the entire old chunk\n\t * defined to avoid errors as we copy the currently-NOACCESS trailing\n\t * bytes.\n\t */\n\tVALGRIND_MAKE_MEM_UNDEFINED(newPointer, size);\n#ifdef MEMORY_CONTEXT_CHECKING\n\toldsize = chunk->requested_size;\n#else\n\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t/* transfer existing data (certain to fit) */\n\tmemcpy(newPointer, pointer, oldsize);\n\n\t/* free old chunk */\n\tGenerationFree((MemoryContext) set, pointer);\n\n\treturn newPointer;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void GenerationFree(MemoryContext context, void *pointer);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerationFree",
          "args": [
            "(MemoryContext) set",
            "pointer"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "GenerationFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
          "lines": "474-526",
          "snippet": "static void\nGenerationFree(MemoryContext context, void *pointer)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationBlock *block;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\tblock = chunk->block;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n#ifdef CLOBBER_FREED_MEMORY\n\twipe_mem(pointer, chunk->size);\n#endif\n\n\t/* Reset context to NULL in freed chunks */\n\tchunk->context = NULL;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Reset requested_size to 0 in freed chunks */\n\tchunk->requested_size = 0;\n#endif\n\n\tblock->nfree += 1;\n\n\tAssert(block->nchunks > 0);\n\tAssert(block->nfree <= block->nchunks);\n\n\t/* If there are still allocated chunks in the block, we're done. */\n\tif (block->nfree < block->nchunks)\n\t\treturn;\n\n\t/*\n\t * The block is empty, so let's get rid of it. First remove it from the\n\t * list of blocks, then return it to malloc().\n\t */\n\tdlist_delete(&block->node);\n\n\t/* Also make sure the block is not marked as the current block. */\n\tif (set->block == block)\n\t\tset->block = NULL;\n\n\tfree(block);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)"
          ],
          "globals_used": [
            "static void *GenerationAlloc(MemoryContext context, Size size);",
            "static void GenerationFree(MemoryContext context, void *pointer);",
            "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
            "static void GenerationReset(MemoryContext context);",
            "static void GenerationDelete(MemoryContext context);",
            "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
            "static bool GenerationIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationFree(MemoryContext context, void *pointer)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationBlock *block;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\tblock = chunk->block;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n#ifdef CLOBBER_FREED_MEMORY\n\twipe_mem(pointer, chunk->size);\n#endif\n\n\t/* Reset context to NULL in freed chunks */\n\tchunk->context = NULL;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Reset requested_size to 0 in freed chunks */\n\tchunk->requested_size = 0;\n#endif\n\n\tblock->nfree += 1;\n\n\tAssert(block->nchunks > 0);\n\tAssert(block->nfree <= block->nchunks);\n\n\t/* If there are still allocated chunks in the block, we're done. */\n\tif (block->nfree < block->nchunks)\n\t\treturn;\n\n\t/*\n\t * The block is empty, so let's get rid of it. First remove it from the\n\t * list of blocks, then return it to malloc().\n\t */\n\tdlist_delete(&block->node);\n\n\t/* Also make sure the block is not marked as the current block. */\n\tif (set->block == block)\n\t\tset->block = NULL;\n\n\tfree(block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newPointer",
            "pointer",
            "oldsize"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "pointer",
            "oldsize"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "newPointer",
            "size"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationAlloc",
          "args": [
            "(MemoryContext) set",
            "size"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "GenerationAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
          "lines": "338-467",
          "snippet": "static void *\nGenerationAlloc(MemoryContext context, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationBlock *block;\n\tGenerationChunk *chunk;\n\tSize\t\tchunk_size = MAXALIGN(size);\n\n\t/* is it an over-sized chunk? if yes, allocate special block */\n\tif (chunk_size > set->blockSize / 8)\n\t{\n\t\tSize\t\tblksize = chunk_size + Generation_BLOCKHDRSZ + Generation_CHUNKHDRSZ;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\t/* block with a single (used) chunk */\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 1;\n\t\tblock->nfree = 0;\n\n\t\t/* the block is completely full */\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (GenerationChunk *) (((char *) block) + Generation_BLOCKHDRSZ);\n\t\tchunk->block = block;\n\t\tchunk->context = set;\n\t\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\t\t/* add the block to the list of allocated blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\tGenerationAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn GenerationChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Not an over-sized chunk. Is there enough space in the current block? If\n\t * not, allocate a new \"regular\" block.\n\t */\n\tblock = set->block;\n\n\tif ((block == NULL) ||\n\t\t(block->endptr - block->freeptr) < Generation_CHUNKHDRSZ + chunk_size)\n\t{\n\t\tSize\t\tblksize = set->blockSize;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 0;\n\t\tblock->nfree = 0;\n\n\t\tblock->freeptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - Generation_BLOCKHDRSZ);\n\n\t\t/* add it to the doubly-linked list of blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\t/* and also use it as the current allocation block */\n\t\tset->block = block;\n\t}\n\n\t/* we're supposed to have a block with enough free space now */\n\tAssert(block != NULL);\n\tAssert((block->endptr - block->freeptr) >= Generation_CHUNKHDRSZ + chunk_size);\n\n\tchunk = (GenerationChunk *) block->freeptr;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, Generation_CHUNKHDRSZ);\n\n\tblock->nchunks += 1;\n\tblock->freeptr += (Generation_CHUNKHDRSZ + chunk_size);\n\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->block = block;\n\tchunk->context = set;\n\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\tGenerationAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\treturn GenerationChunkGetPointer(chunk);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)",
            "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)",
            "#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))"
          ],
          "globals_used": [
            "static void *GenerationAlloc(MemoryContext context, Size size);",
            "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
            "static void GenerationReset(MemoryContext context);",
            "static void GenerationDelete(MemoryContext context);",
            "static bool GenerationIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void *\nGenerationAlloc(MemoryContext context, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationBlock *block;\n\tGenerationChunk *chunk;\n\tSize\t\tchunk_size = MAXALIGN(size);\n\n\t/* is it an over-sized chunk? if yes, allocate special block */\n\tif (chunk_size > set->blockSize / 8)\n\t{\n\t\tSize\t\tblksize = chunk_size + Generation_BLOCKHDRSZ + Generation_CHUNKHDRSZ;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\t/* block with a single (used) chunk */\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 1;\n\t\tblock->nfree = 0;\n\n\t\t/* the block is completely full */\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (GenerationChunk *) (((char *) block) + Generation_BLOCKHDRSZ);\n\t\tchunk->block = block;\n\t\tchunk->context = set;\n\t\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\t\t/* add the block to the list of allocated blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\tGenerationAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn GenerationChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Not an over-sized chunk. Is there enough space in the current block? If\n\t * not, allocate a new \"regular\" block.\n\t */\n\tblock = set->block;\n\n\tif ((block == NULL) ||\n\t\t(block->endptr - block->freeptr) < Generation_CHUNKHDRSZ + chunk_size)\n\t{\n\t\tSize\t\tblksize = set->blockSize;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 0;\n\t\tblock->nfree = 0;\n\n\t\tblock->freeptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - Generation_BLOCKHDRSZ);\n\n\t\t/* add it to the doubly-linked list of blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\t/* and also use it as the current allocation block */\n\t\tset->block = block;\n\t}\n\n\t/* we're supposed to have a block with enough free space now */\n\tAssert(block != NULL);\n\tAssert((block->endptr - block->freeptr) >= Generation_CHUNKHDRSZ + chunk_size);\n\n\tchunk = (GenerationChunk *) block->freeptr;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, Generation_CHUNKHDRSZ);\n\n\tblock->nchunks += 1;\n\tblock->freeptr += (Generation_CHUNKHDRSZ + chunk_size);\n\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->block = block;\n\tchunk->context = set;\n\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\tGenerationAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\treturn GenerationChunkGetPointer(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "pointer",
            "size"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "pointer",
            "oldsize"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "pointer",
            "size"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) pointer + size",
            "oldsize - size"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "(char *) pointer + oldrequest",
            "size - oldrequest"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randomize_mem",
          "args": [
            "(char *) pointer + oldrequest",
            "size - oldrequest"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/memdebug.c",
          "lines": "74-91",
          "snippet": "void\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}",
          "includes": [
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nvoid\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"detected write past chunk end in %s %p\"",
            "((MemoryContext) set)->name",
            "chunk"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "pointer",
            "chunk->requested_size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void *\nGenerationRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationPointer newPointer;\n\tSize\t\toldsize;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\toldsize = chunk->size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < oldsize)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n\t/*\n\t * Maybe the allocated area already is >= the new size.  (In particular,\n\t * we always fall out here if the requested size is a decrease.)\n\t *\n\t * This memory context does not use power-of-2 chunk sizing and instead\n\t * carves the chunks to be as small as possible, so most repalloc() calls\n\t * will end up in the palloc/memcpy/pfree branch.\n\t *\n\t * XXX Perhaps we should annotate this condition with unlikely()?\n\t */\n\tif (oldsize >= size)\n\t{\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tSize\t\toldrequest = chunk->requested_size;\n\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* We can only fill the extra space if we know the prior request */\n\t\tif (size > oldrequest)\n\t\t\trandomize_mem((char *) pointer + oldrequest,\n\t\t\t\t\t\t  size - oldrequest);\n#endif\n\n\t\tchunk->requested_size = size;\n\n\t\t/*\n\t\t * If this is an increase, mark any newly-available part UNDEFINED.\n\t\t * Otherwise, mark the obsolete part NOACCESS.\n\t\t */\n\t\tif (size > oldrequest)\n\t\t\tVALGRIND_MAKE_MEM_UNDEFINED((char *) pointer + oldrequest,\n\t\t\t\t\t\t\t\t\t\tsize - oldrequest);\n\t\telse\n\t\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) pointer + size,\n\t\t\t\t\t\t\t\t\t   oldsize - size);\n\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < oldsize)\n\t\t\tset_sentinel(pointer, size);\n#else\t\t\t\t\t\t\t/* !MEMORY_CONTEXT_CHECKING */\n\n\t\t/*\n\t\t * We don't have the information to determine whether we're growing\n\t\t * the old request or shrinking it, so we conservatively mark the\n\t\t * entire new allocation DEFINED.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(pointer, oldsize);\n\t\tVALGRIND_MAKE_MEM_DEFINED(pointer, size);\n#endif\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn pointer;\n\t}\n\n\t/* allocate new chunk */\n\tnewPointer = GenerationAlloc((MemoryContext) set, size);\n\n\t/* leave immediately if request was not completed */\n\tif (newPointer == NULL)\n\t{\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * GenerationAlloc() may have returned a region that is still NOACCESS.\n\t * Change it to UNDEFINED for the moment; memcpy() will then transfer\n\t * definedness from the old allocation to the new.  If we know the old\n\t * allocation, copy just that much.  Otherwise, make the entire old chunk\n\t * defined to avoid errors as we copy the currently-NOACCESS trailing\n\t * bytes.\n\t */\n\tVALGRIND_MAKE_MEM_UNDEFINED(newPointer, size);\n#ifdef MEMORY_CONTEXT_CHECKING\n\toldsize = chunk->requested_size;\n#else\n\tVALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);\n#endif\n\n\t/* transfer existing data (certain to fit) */\n\tmemcpy(newPointer, pointer, oldsize);\n\n\t/* free old chunk */\n\tGenerationFree((MemoryContext) set, pointer);\n\n\treturn newPointer;\n}"
  },
  {
    "function_name": "GenerationFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "474-526",
    "snippet": "static void\nGenerationFree(MemoryContext context, void *pointer)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationBlock *block;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\tblock = chunk->block;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n#ifdef CLOBBER_FREED_MEMORY\n\twipe_mem(pointer, chunk->size);\n#endif\n\n\t/* Reset context to NULL in freed chunks */\n\tchunk->context = NULL;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Reset requested_size to 0 in freed chunks */\n\tchunk->requested_size = 0;\n#endif\n\n\tblock->nfree += 1;\n\n\tAssert(block->nchunks > 0);\n\tAssert(block->nfree <= block->nchunks);\n\n\t/* If there are still allocated chunks in the block, we're done. */\n\tif (block->nfree < block->nchunks)\n\t\treturn;\n\n\t/*\n\t * The block is empty, so let's get rid of it. First remove it from the\n\t * list of blocks, then return it to malloc().\n\t */\n\tdlist_delete(&block->node);\n\n\t/* Also make sure the block is not marked as the current block. */\n\tif (set->block == block)\n\t\tset->block = NULL;\n\n\tfree(block);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void GenerationFree(MemoryContext context, void *pointer);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "&block->node"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->nfree <= block->nchunks"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->nchunks > 0"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "pointer",
            "chunk->size"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"detected write past chunk end in %s %p\"",
            "((MemoryContext) set)->name",
            "chunk"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "pointer",
            "chunk->requested_size"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationFree(MemoryContext context, void *pointer)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationChunk *chunk = GenerationPointerGetChunk(pointer);\n\tGenerationBlock *block;\n\n\t/* Allow access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\tblock = chunk->block;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (chunk->requested_size < chunk->size)\n\t\tif (!sentinel_ok(pointer, chunk->requested_size))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t ((MemoryContext) set)->name, chunk);\n#endif\n\n#ifdef CLOBBER_FREED_MEMORY\n\twipe_mem(pointer, chunk->size);\n#endif\n\n\t/* Reset context to NULL in freed chunks */\n\tchunk->context = NULL;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Reset requested_size to 0 in freed chunks */\n\tchunk->requested_size = 0;\n#endif\n\n\tblock->nfree += 1;\n\n\tAssert(block->nchunks > 0);\n\tAssert(block->nfree <= block->nchunks);\n\n\t/* If there are still allocated chunks in the block, we're done. */\n\tif (block->nfree < block->nchunks)\n\t\treturn;\n\n\t/*\n\t * The block is empty, so let's get rid of it. First remove it from the\n\t * list of blocks, then return it to malloc().\n\t */\n\tdlist_delete(&block->node);\n\n\t/* Also make sure the block is not marked as the current block. */\n\tif (set->block == block)\n\t\tset->block = NULL;\n\n\tfree(block);\n}"
  },
  {
    "function_name": "GenerationAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "338-467",
    "snippet": "static void *\nGenerationAlloc(MemoryContext context, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationBlock *block;\n\tGenerationChunk *chunk;\n\tSize\t\tchunk_size = MAXALIGN(size);\n\n\t/* is it an over-sized chunk? if yes, allocate special block */\n\tif (chunk_size > set->blockSize / 8)\n\t{\n\t\tSize\t\tblksize = chunk_size + Generation_BLOCKHDRSZ + Generation_CHUNKHDRSZ;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\t/* block with a single (used) chunk */\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 1;\n\t\tblock->nfree = 0;\n\n\t\t/* the block is completely full */\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (GenerationChunk *) (((char *) block) + Generation_BLOCKHDRSZ);\n\t\tchunk->block = block;\n\t\tchunk->context = set;\n\t\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\t\t/* add the block to the list of allocated blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\tGenerationAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn GenerationChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Not an over-sized chunk. Is there enough space in the current block? If\n\t * not, allocate a new \"regular\" block.\n\t */\n\tblock = set->block;\n\n\tif ((block == NULL) ||\n\t\t(block->endptr - block->freeptr) < Generation_CHUNKHDRSZ + chunk_size)\n\t{\n\t\tSize\t\tblksize = set->blockSize;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 0;\n\t\tblock->nfree = 0;\n\n\t\tblock->freeptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - Generation_BLOCKHDRSZ);\n\n\t\t/* add it to the doubly-linked list of blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\t/* and also use it as the current allocation block */\n\t\tset->block = block;\n\t}\n\n\t/* we're supposed to have a block with enough free space now */\n\tAssert(block != NULL);\n\tAssert((block->endptr - block->freeptr) >= Generation_CHUNKHDRSZ + chunk_size);\n\n\tchunk = (GenerationChunk *) block->freeptr;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, Generation_CHUNKHDRSZ);\n\n\tblock->nchunks += 1;\n\tblock->freeptr += (Generation_CHUNKHDRSZ + chunk_size);\n\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->block = block;\n\tchunk->context = set;\n\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\tGenerationAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\treturn GenerationChunkGetPointer(chunk);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)",
      "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)",
      "#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) GenerationChunkGetPointer(chunk) + size",
            "chunk_size - size"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationAllocInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randomize_mem",
          "args": [
            "(char *) GenerationChunkGetPointer(chunk)",
            "size"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/memdebug.c",
          "lines": "74-91",
          "snippet": "void\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}",
          "includes": [
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nvoid\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "GenerationChunkGetPointer(chunk)",
            "size"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->freeptr <= block->endptr"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "chunk",
            "Generation_CHUNKHDRSZ"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(block->endptr - block->freeptr) >= Generation_CHUNKHDRSZ + chunk_size"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block != NULL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&set->blocks",
            "&block->node"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "block->freeptr",
            "blksize - Generation_BLOCKHDRSZ"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "blksize"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "chunk",
            "GENERATIONCHUNK_PRIVATE_LEN"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "(char *) GenerationChunkGetPointer(chunk) + size",
            "chunk_size - size"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationAllocInfo",
          "args": [
            "set",
            "chunk"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&set->blocks",
            "&block->node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "GenerationChunkGetPointer(chunk)",
            "size"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "blksize"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "size"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void *\nGenerationAlloc(MemoryContext context, Size size)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tGenerationBlock *block;\n\tGenerationChunk *chunk;\n\tSize\t\tchunk_size = MAXALIGN(size);\n\n\t/* is it an over-sized chunk? if yes, allocate special block */\n\tif (chunk_size > set->blockSize / 8)\n\t{\n\t\tSize\t\tblksize = chunk_size + Generation_BLOCKHDRSZ + Generation_CHUNKHDRSZ;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\t/* block with a single (used) chunk */\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 1;\n\t\tblock->nfree = 0;\n\n\t\t/* the block is completely full */\n\t\tblock->freeptr = block->endptr = ((char *) block) + blksize;\n\n\t\tchunk = (GenerationChunk *) (((char *) block) + Generation_BLOCKHDRSZ);\n\t\tchunk->block = block;\n\t\tchunk->context = set;\n\t\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t\tchunk->requested_size = size;\n\t\t/* set mark to catch clobber of \"unused\" space */\n\t\tif (size < chunk_size)\n\t\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t\t/* fill the allocated space with junk */\n\t\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\t\t/* add the block to the list of allocated blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\tGenerationAllocInfo(set, chunk);\n\n\t\t/* Ensure any padding bytes are marked NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t\t   chunk_size - size);\n\n\t\t/* Disallow external access to private part of chunk header. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\treturn GenerationChunkGetPointer(chunk);\n\t}\n\n\t/*\n\t * Not an over-sized chunk. Is there enough space in the current block? If\n\t * not, allocate a new \"regular\" block.\n\t */\n\tblock = set->block;\n\n\tif ((block == NULL) ||\n\t\t(block->endptr - block->freeptr) < Generation_CHUNKHDRSZ + chunk_size)\n\t{\n\t\tSize\t\tblksize = set->blockSize;\n\n\t\tblock = (GenerationBlock *) malloc(blksize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->blksize = blksize;\n\t\tblock->nchunks = 0;\n\t\tblock->nfree = 0;\n\n\t\tblock->freeptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\t\tblock->endptr = ((char *) block) + blksize;\n\n\t\t/* Mark unallocated space NOACCESS. */\n\t\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr,\n\t\t\t\t\t\t\t\t   blksize - Generation_BLOCKHDRSZ);\n\n\t\t/* add it to the doubly-linked list of blocks */\n\t\tdlist_push_head(&set->blocks, &block->node);\n\n\t\t/* and also use it as the current allocation block */\n\t\tset->block = block;\n\t}\n\n\t/* we're supposed to have a block with enough free space now */\n\tAssert(block != NULL);\n\tAssert((block->endptr - block->freeptr) >= Generation_CHUNKHDRSZ + chunk_size);\n\n\tchunk = (GenerationChunk *) block->freeptr;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, Generation_CHUNKHDRSZ);\n\n\tblock->nchunks += 1;\n\tblock->freeptr += (Generation_CHUNKHDRSZ + chunk_size);\n\n\tAssert(block->freeptr <= block->endptr);\n\n\tchunk->block = block;\n\tchunk->context = set;\n\tchunk->size = chunk_size;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\tchunk->requested_size = size;\n\t/* set mark to catch clobber of \"unused\" space */\n\tif (size < chunk->size)\n\t\tset_sentinel(GenerationChunkGetPointer(chunk), size);\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) GenerationChunkGetPointer(chunk), size);\n#endif\n\n\tGenerationAllocInfo(set, chunk);\n\n\t/* Ensure any padding bytes are marked NOACCESS. */\n\tVALGRIND_MAKE_MEM_NOACCESS((char *) GenerationChunkGetPointer(chunk) + size,\n\t\t\t\t\t\t\t   chunk_size - size);\n\n\t/* Disallow external access to private part of chunk header. */\n\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\treturn GenerationChunkGetPointer(chunk);\n}"
  },
  {
    "function_name": "GenerationDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "316-323",
    "snippet": "static void\nGenerationDelete(MemoryContext context)\n{\n\t/* Reset to release all the GenerationBlocks */\n\tGenerationReset(context);\n\t/* And free the context header */\n\tfree(context);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "context"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenerationReset",
          "args": [
            "context"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "GenerationReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
          "lines": "281-310",
          "snippet": "static void\nGenerationReset(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tdlist_mutable_iter miter;\n\n\tAssertArg(GenerationIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tGenerationCheck(context);\n#endif\n\n\tdlist_foreach_modify(miter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, miter.cur);\n\n\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->blksize);\n#endif\n\n\t\tfree(block);\n\t}\n\n\tset->block = NULL;\n\n\tAssert(dlist_is_empty(&set->blocks));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void GenerationReset(MemoryContext context);",
            "static void GenerationDelete(MemoryContext context);",
            "static bool GenerationIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationReset(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tdlist_mutable_iter miter;\n\n\tAssertArg(GenerationIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tGenerationCheck(context);\n#endif\n\n\tdlist_foreach_modify(miter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, miter.cur);\n\n\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->blksize);\n#endif\n\n\t\tfree(block);\n\t}\n\n\tset->block = NULL;\n\n\tAssert(dlist_is_empty(&set->blocks));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationDelete(MemoryContext context)\n{\n\t/* Reset to release all the GenerationBlocks */\n\tGenerationReset(context);\n\t/* And free the context header */\n\tfree(context);\n}"
  },
  {
    "function_name": "GenerationReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "281-310",
    "snippet": "static void\nGenerationReset(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tdlist_mutable_iter miter;\n\n\tAssertArg(GenerationIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tGenerationCheck(context);\n#endif\n\n\tdlist_foreach_modify(miter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, miter.cur);\n\n\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->blksize);\n#endif\n\n\t\tfree(block);\n\t}\n\n\tset->block = NULL;\n\n\tAssert(dlist_is_empty(&set->blocks));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dlist_is_empty(&set->blocks)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_is_empty",
          "args": [
            "&set->blocks"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "block",
            "block->blksize"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "miter.cur"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "GenerationBlock",
            "node",
            "miter.cur"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "miter",
            "&set->blocks"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationCheck",
          "args": [
            "context"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "GenerationCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
          "lines": "743-836",
          "snippet": "static void\nGenerationCheck(MemoryContext context)\n{\n\tGenerationContext *gen = (GenerationContext *) context;\n\tconst char *name = context->name;\n\tdlist_iter\titer;\n\n\t/* walk all blocks in this context */\n\tdlist_foreach(iter, &gen->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\t\tint\t\t\tnfree,\n\t\t\t\t\tnchunks;\n\t\tchar\t   *ptr;\n\n\t\t/*\n\t\t * nfree > nchunks is surely wrong, and we don't expect to see\n\t\t * equality either, because such a block should have gotten freed.\n\t\t */\n\t\tif (block->nfree >= block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p exceeds %d allocated\",\n\t\t\t\t name, block->nfree, block, block->nchunks);\n\n\t\t/* Now walk through the chunks and count them. */\n\t\tnfree = 0;\n\t\tnchunks = 0;\n\t\tptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\n\t\twhile (ptr < block->freeptr)\n\t\t{\n\t\t\tGenerationChunk *chunk = (GenerationChunk *) ptr;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\t\t/* move to the next chunk */\n\t\t\tptr += (chunk->size + Generation_CHUNKHDRSZ);\n\n\t\t\tnchunks += 1;\n\n\t\t\t/* chunks have both block and context pointers, so check both */\n\t\t\tif (chunk->block != block)\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for valid context pointer.  Note this is an incomplete\n\t\t\t * test, since palloc(0) produces an allocated chunk with\n\t\t\t * requested_size == 0.\n\t\t\t */\n\t\t\tif ((chunk->requested_size > 0 && chunk->context != gen) ||\n\t\t\t\t(chunk->context != gen && chunk->context != NULL))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus context link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* now make sure the chunk size is correct */\n\t\t\tif (chunk->size < chunk->requested_size ||\n\t\t\t\tchunk->size != MAXALIGN(chunk->size))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus chunk size in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* is chunk allocated? */\n\t\t\tif (chunk->context != NULL)\n\t\t\t{\n\t\t\t\t/* check sentinel, but only in allocated blocks */\n\t\t\t\tif (chunk->requested_size < chunk->size &&\n\t\t\t\t\t!sentinel_ok(chunk, Generation_CHUNKHDRSZ + chunk->requested_size))\n\t\t\t\t\telog(WARNING, \"problem in Generation %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t name, block, chunk);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnfree += 1;\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->context != NULL)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we got the expected number of allocated and free chunks\n\t\t * (as tracked in the block header).\n\t\t */\n\t\tif (nchunks != block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of allocated chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nchunks, block, block->nchunks);\n\n\t\tif (nfree != block->nfree)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nfree, block, block->nfree);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"lib/ilist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)",
            "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)",
            "#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))"
          ],
          "globals_used": [
            "static void *GenerationAlloc(MemoryContext context, Size size);",
            "static void GenerationFree(MemoryContext context, void *pointer);",
            "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
            "static void GenerationReset(MemoryContext context);",
            "static void GenerationDelete(MemoryContext context);",
            "static Size GenerationGetChunkSpace(MemoryContext context, void *pointer);",
            "static bool GenerationIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define GENERATIONCHUNK_PRIVATE_LEN\toffsetof(GenerationChunk, context)\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n#define Generation_BLOCKHDRSZ\tMAXALIGN(sizeof(GenerationBlock))\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void GenerationFree(MemoryContext context, void *pointer);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic Size GenerationGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationCheck(MemoryContext context)\n{\n\tGenerationContext *gen = (GenerationContext *) context;\n\tconst char *name = context->name;\n\tdlist_iter\titer;\n\n\t/* walk all blocks in this context */\n\tdlist_foreach(iter, &gen->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, iter.cur);\n\t\tint\t\t\tnfree,\n\t\t\t\t\tnchunks;\n\t\tchar\t   *ptr;\n\n\t\t/*\n\t\t * nfree > nchunks is surely wrong, and we don't expect to see\n\t\t * equality either, because such a block should have gotten freed.\n\t\t */\n\t\tif (block->nfree >= block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p exceeds %d allocated\",\n\t\t\t\t name, block->nfree, block, block->nchunks);\n\n\t\t/* Now walk through the chunks and count them. */\n\t\tnfree = 0;\n\t\tnchunks = 0;\n\t\tptr = ((char *) block) + Generation_BLOCKHDRSZ;\n\n\t\twhile (ptr < block->freeptr)\n\t\t{\n\t\t\tGenerationChunk *chunk = (GenerationChunk *) ptr;\n\n\t\t\t/* Allow access to private part of chunk header. */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\n\t\t\t/* move to the next chunk */\n\t\t\tptr += (chunk->size + Generation_CHUNKHDRSZ);\n\n\t\t\tnchunks += 1;\n\n\t\t\t/* chunks have both block and context pointers, so check both */\n\t\t\tif (chunk->block != block)\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/*\n\t\t\t * Check for valid context pointer.  Note this is an incomplete\n\t\t\t * test, since palloc(0) produces an allocated chunk with\n\t\t\t * requested_size == 0.\n\t\t\t */\n\t\t\tif ((chunk->requested_size > 0 && chunk->context != gen) ||\n\t\t\t\t(chunk->context != gen && chunk->context != NULL))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus context link in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* now make sure the chunk size is correct */\n\t\t\tif (chunk->size < chunk->requested_size ||\n\t\t\t\tchunk->size != MAXALIGN(chunk->size))\n\t\t\t\telog(WARNING, \"problem in Generation %s: bogus chunk size in block %p, chunk %p\",\n\t\t\t\t\t name, block, chunk);\n\n\t\t\t/* is chunk allocated? */\n\t\t\tif (chunk->context != NULL)\n\t\t\t{\n\t\t\t\t/* check sentinel, but only in allocated blocks */\n\t\t\t\tif (chunk->requested_size < chunk->size &&\n\t\t\t\t\t!sentinel_ok(chunk, Generation_CHUNKHDRSZ + chunk->requested_size))\n\t\t\t\t\telog(WARNING, \"problem in Generation %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t name, block, chunk);\n\t\t\t}\n\t\t\telse\n\t\t\t\tnfree += 1;\n\n\t\t\t/*\n\t\t\t * If chunk is allocated, disallow external access to private part\n\t\t\t * of chunk header.\n\t\t\t */\n\t\t\tif (chunk->context != NULL)\n\t\t\t\tVALGRIND_MAKE_MEM_NOACCESS(chunk, GENERATIONCHUNK_PRIVATE_LEN);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we got the expected number of allocated and free chunks\n\t\t * (as tracked in the block header).\n\t\t */\n\t\tif (nchunks != block->nchunks)\n\t\t\telog(WARNING, \"problem in Generation %s: number of allocated chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nchunks, block, block->nchunks);\n\n\t\tif (nfree != block->nfree)\n\t\t\telog(WARNING, \"problem in Generation %s: number of free chunks %d in block %p does not match header %d\",\n\t\t\t\t name, nfree, block, block->nfree);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "GenerationIsValid(set)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerationIsValid",
          "args": [
            "set"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\n\nstatic void\nGenerationReset(MemoryContext context)\n{\n\tGenerationContext *set = (GenerationContext *) context;\n\tdlist_mutable_iter miter;\n\n\tAssertArg(GenerationIsValid(set));\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tGenerationCheck(context);\n#endif\n\n\tdlist_foreach_modify(miter, &set->blocks)\n\t{\n\t\tGenerationBlock *block = dlist_container(GenerationBlock, node, miter.cur);\n\n\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\twipe_mem(block, block->blksize);\n#endif\n\n\t\tfree(block);\n\t}\n\n\tset->block = NULL;\n\n\tAssert(dlist_is_empty(&set->blocks));\n}"
  },
  {
    "function_name": "GenerationContextCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/generation.c",
    "lines": "211-272",
    "snippet": "MemoryContext\nGenerationContextCreate(MemoryContext parent,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tSize blockSize)\n{\n\tGenerationContext *set;\n\n\t/* Assert we padded GenerationChunk properly */\n\tStaticAssertStmt(Generation_CHUNKHDRSZ == MAXALIGN(Generation_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(GenerationChunk) is not maxaligned\");\n\tStaticAssertStmt(offsetof(GenerationChunk, context) + sizeof(MemoryContext) ==\n\t\t\t\t\t Generation_CHUNKHDRSZ,\n\t\t\t\t\t \"padding calculation in GenerationChunk is wrong\");\n\n\t/*\n\t * First, validate allocation parameters.  (If we're going to throw an\n\t * error, we should do so before the context is created, not after.)  We\n\t * somewhat arbitrarily enforce a minimum 1K block size, mostly because\n\t * that's what AllocSet does.\n\t */\n\tif (blockSize != MAXALIGN(blockSize) ||\n\t\tblockSize < 1024 ||\n\t\t!AllocHugeSizeIsValid(blockSize))\n\t\telog(ERROR, \"invalid blockSize for memory context: %zu\",\n\t\t\t blockSize);\n\n\t/*\n\t * Allocate the context header.  Unlike aset.c, we never try to combine\n\t * this with the first regular block, since that would prevent us from\n\t * freeing the first generation of allocations.\n\t */\n\n\tset = (GenerationContext *) malloc(MAXALIGN(sizeof(GenerationContext)));\n\tif (set == NULL)\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header if we ereport in this stretch.\n\t */\n\n\t/* Fill in GenerationContext-specific header fields */\n\tset->blockSize = blockSize;\n\tset->block = NULL;\n\tdlist_init(&set->blocks);\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_GenerationContext,\n\t\t\t\t\t\t&GenerationMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) set;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"lib/ilist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)"
    ],
    "globals_used": [
      "static void *GenerationAlloc(MemoryContext context, Size size);",
      "static void *GenerationRealloc(MemoryContext context, void *pointer, Size size);",
      "static void GenerationReset(MemoryContext context);",
      "static void GenerationDelete(MemoryContext context);",
      "static bool GenerationIsEmpty(MemoryContext context);",
      "static const MemoryContextMethods GenerationMethods = {\n\tGenerationAlloc,\n\tGenerationFree,\n\tGenerationRealloc,\n\tGenerationReset,\n\tGenerationDelete,\n\tGenerationGetChunkSpace,\n\tGenerationIsEmpty,\n\tGenerationStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,GenerationCheck\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextCreate",
          "args": [
            "(MemoryContext) set",
            "T_GenerationContext",
            "&GenerationMethods",
            "parent",
            "name"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "723-761",
          "snippet": "void\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_init",
          "args": [
            "&set->blocks"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Failed while creating memory context \\\"%s\\\".\"",
            "name"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStats",
          "args": [
            "TopMemoryContext"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "473-478",
          "snippet": "void\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "MAXALIGN(sizeof(GenerationContext))"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(GenerationContext)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid blockSize for memory context: %zu\"",
            "blockSize"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocHugeSizeIsValid",
          "args": [
            "blockSize"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "blockSize"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "offsetof(GenerationChunk, context) + sizeof(MemoryContext) ==\n\t\t\t\t\t Generation_CHUNKHDRSZ",
            "\"padding calculation in GenerationChunk is wrong\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "Generation_CHUNKHDRSZ == MAXALIGN(Generation_CHUNKHDRSZ)",
            "\"sizeof(GenerationChunk) is not maxaligned\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "Generation_CHUNKHDRSZ"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"lib/ilist.h\"\n#include \"postgres.h\"\n\n#define Generation_CHUNKHDRSZ\tsizeof(GenerationChunk)\n\nstatic void *GenerationAlloc(MemoryContext context, Size size);\nstatic void *GenerationRealloc(MemoryContext context, void *pointer, Size size);\nstatic void GenerationReset(MemoryContext context);\nstatic void GenerationDelete(MemoryContext context);\nstatic bool GenerationIsEmpty(MemoryContext context);\nstatic const MemoryContextMethods GenerationMethods = {\n\tGenerationAlloc,\n\tGenerationFree,\n\tGenerationRealloc,\n\tGenerationReset,\n\tGenerationDelete,\n\tGenerationGetChunkSpace,\n\tGenerationIsEmpty,\n\tGenerationStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,GenerationCheck\n#endif\n};\n\nMemoryContext\nGenerationContextCreate(MemoryContext parent,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tSize blockSize)\n{\n\tGenerationContext *set;\n\n\t/* Assert we padded GenerationChunk properly */\n\tStaticAssertStmt(Generation_CHUNKHDRSZ == MAXALIGN(Generation_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(GenerationChunk) is not maxaligned\");\n\tStaticAssertStmt(offsetof(GenerationChunk, context) + sizeof(MemoryContext) ==\n\t\t\t\t\t Generation_CHUNKHDRSZ,\n\t\t\t\t\t \"padding calculation in GenerationChunk is wrong\");\n\n\t/*\n\t * First, validate allocation parameters.  (If we're going to throw an\n\t * error, we should do so before the context is created, not after.)  We\n\t * somewhat arbitrarily enforce a minimum 1K block size, mostly because\n\t * that's what AllocSet does.\n\t */\n\tif (blockSize != MAXALIGN(blockSize) ||\n\t\tblockSize < 1024 ||\n\t\t!AllocHugeSizeIsValid(blockSize))\n\t\telog(ERROR, \"invalid blockSize for memory context: %zu\",\n\t\t\t blockSize);\n\n\t/*\n\t * Allocate the context header.  Unlike aset.c, we never try to combine\n\t * this with the first regular block, since that would prevent us from\n\t * freeing the first generation of allocations.\n\t */\n\n\tset = (GenerationContext *) malloc(MAXALIGN(sizeof(GenerationContext)));\n\tif (set == NULL)\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header if we ereport in this stretch.\n\t */\n\n\t/* Fill in GenerationContext-specific header fields */\n\tset->blockSize = blockSize;\n\tset->block = NULL;\n\tdlist_init(&set->blocks);\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_GenerationContext,\n\t\t\t\t\t\t&GenerationMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) set;\n}"
  }
]