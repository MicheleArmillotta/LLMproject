[
  {
    "function_name": "like_escape_bytea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "434-442",
    "snippet": "Datum\nlike_escape_bytea(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *esc = PG_GETARG_BYTEA_PP(1);\n\tbytea\t   *result = SB_do_like_escape((text *) pat, (text *) esc);\n\n\tPG_RETURN_BYTEA_P((bytea *) result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "(bytea *) result"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_do_like_escape",
          "args": [
            "(text *) pat",
            "(text *) esc"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\nlike_escape_bytea(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *esc = PG_GETARG_BYTEA_PP(1);\n\tbytea\t   *result = SB_do_like_escape((text *) pat, (text *) esc);\n\n\tPG_RETURN_BYTEA_P((bytea *) result);\n}"
  },
  {
    "function_name": "like_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "415-428",
    "snippet": "Datum\nlike_escape(PG_FUNCTION_ARGS)\n{\n\ttext\t   *pat = PG_GETARG_TEXT_PP(0);\n\ttext\t   *esc = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tif (pg_database_encoding_max_length() == 1)\n\t\tresult = SB_do_like_escape(pat, esc);\n\telse\n\t\tresult = MB_do_like_escape(pat, esc);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_do_like_escape",
          "args": [
            "pat",
            "esc"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_do_like_escape",
          "args": [
            "pat",
            "esc"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\nlike_escape(PG_FUNCTION_ARGS)\n{\n\ttext\t   *pat = PG_GETARG_TEXT_PP(0);\n\ttext\t   *esc = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tif (pg_database_encoding_max_length() == 1)\n\t\tresult = SB_do_like_escape(pat, esc);\n\telse\n\t\tresult = MB_do_like_escape(pat, esc);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "texticnlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "399-409",
    "snippet": "Datum\ntexticnlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (Generic_Text_IC_like(str, pat, PG_GET_COLLATION()) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Generic_Text_IC_like",
          "args": [
            "str",
            "pat",
            "PG_GET_COLLATION()"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "Generic_Text_IC_like",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "161-221",
          "snippet": "static inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *SB_do_like_escape(text *, text *);",
            "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *MB_do_like_escape(text *, text *);",
            "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
            "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);",
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);",
            "static int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *SB_do_like_escape(text *, text *);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\nstatic int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);\n\nstatic inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\ntexticnlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (Generic_Text_IC_like(str, pat, PG_GET_COLLATION()) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "texticlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "387-397",
    "snippet": "Datum\ntexticlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (Generic_Text_IC_like(str, pat, PG_GET_COLLATION()) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Generic_Text_IC_like",
          "args": [
            "str",
            "pat",
            "PG_GET_COLLATION()"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "Generic_Text_IC_like",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "161-221",
          "snippet": "static inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *SB_do_like_escape(text *, text *);",
            "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *MB_do_like_escape(text *, text *);",
            "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
            "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);",
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);",
            "static int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *SB_do_like_escape(text *, text *);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\nstatic int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);\n\nstatic inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\ntexticlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (Generic_Text_IC_like(str, pat, PG_GET_COLLATION()) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "nameicnlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "372-385",
    "snippet": "Datum\nnameicnlike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\ttext\t   *strtext;\n\n\tstrtext = DatumGetTextPP(DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str)));\n\tresult = (Generic_Text_IC_like(strtext, pat, PG_GET_COLLATION()) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Generic_Text_IC_like",
          "args": [
            "strtext",
            "pat",
            "PG_GET_COLLATION()"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "Generic_Text_IC_like",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "161-221",
          "snippet": "static inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *SB_do_like_escape(text *, text *);",
            "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *MB_do_like_escape(text *, text *);",
            "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
            "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);",
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);",
            "static int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *SB_do_like_escape(text *, text *);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\nstatic int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);\n\nstatic inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "name_text",
            "NameGetDatum(str)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameGetDatum",
          "args": [
            "str"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\nnameicnlike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\ttext\t   *strtext;\n\n\tstrtext = DatumGetTextPP(DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str)));\n\tresult = (Generic_Text_IC_like(strtext, pat, PG_GET_COLLATION()) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "nameiclike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "357-370",
    "snippet": "Datum\nnameiclike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\ttext\t   *strtext;\n\n\tstrtext = DatumGetTextPP(DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str)));\n\tresult = (Generic_Text_IC_like(strtext, pat, PG_GET_COLLATION()) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Generic_Text_IC_like",
          "args": [
            "strtext",
            "pat",
            "PG_GET_COLLATION()"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "Generic_Text_IC_like",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "161-221",
          "snippet": "static inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *SB_do_like_escape(text *, text *);",
            "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
            "static text *MB_do_like_escape(text *, text *);",
            "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
            "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);",
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);",
            "static int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *SB_do_like_escape(text *, text *);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\nstatic int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);\n\nstatic inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str))"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "name_text",
            "NameGetDatum(str)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameGetDatum",
          "args": [
            "str"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\n\nDatum\nnameiclike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\ttext\t   *strtext;\n\n\tstrtext = DatumGetTextPP(DirectFunctionCall1(name_text,\n\t\t\t\t\t\t\t\t\t\t\t\t NameGetDatum(str)));\n\tresult = (Generic_Text_IC_like(strtext, pat, PG_GET_COLLATION()) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "byteanlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "332-351",
    "snippet": "Datum\nbyteanlike(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *str = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (SB_MatchText(s, slen, p, plen, 0, true) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\nbyteanlike(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *str = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (SB_MatchText(s, slen, p, plen, 0, true) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bytealike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "311-330",
    "snippet": "Datum\nbytealike(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *str = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (SB_MatchText(s, slen, p, plen, 0, true) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\nbytealike(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *str = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *pat = PG_GETARG_BYTEA_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (SB_MatchText(s, slen, p, plen, 0, true) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "textnlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "290-309",
    "snippet": "Datum\ntextnlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);",
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenericMatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "GenericMatchText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "150-159",
          "snippet": "static inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nstatic inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\ntextnlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "textlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "269-288",
    "snippet": "Datum\ntextlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);",
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenericMatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "GenericMatchText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "150-159",
          "snippet": "static inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nstatic inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\ntextlike(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = VARDATA_ANY(str);\n\tslen = VARSIZE_ANY_EXHDR(str);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "namenlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "248-267",
    "snippet": "Datum\nnamenlike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = NameStr(*str);\n\tslen = strlen(s);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);",
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenericMatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "GenericMatchText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "150-159",
          "snippet": "static inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nstatic inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*str"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\nnamenlike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = NameStr(*str);\n\tslen = strlen(s);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) != LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "namelike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "227-246",
    "snippet": "Datum\nnamelike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = NameStr(*str);\n\tslen = strlen(s);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIKE_TRUE\t\t\t\t\t\t1"
    ],
    "globals_used": [
      "static text *SB_do_like_escape(text *, text *);",
      "static text *MB_do_like_escape(text *, text *);",
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenericMatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "GenericMatchText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
          "lines": "150-159",
          "snippet": "static inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}",
          "includes": [
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"like_match.c\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nstatic inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*str"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define LIKE_TRUE\t\t\t\t\t\t1\n\nstatic text *SB_do_like_escape(text *, text *);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nDatum\nnamelike(PG_FUNCTION_ARGS)\n{\n\tName\t\tstr = PG_GETARG_NAME(0);\n\ttext\t   *pat = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\n\ts = NameStr(*str);\n\tslen = strlen(s);\n\tp = VARDATA_ANY(pat);\n\tplen = VARSIZE_ANY_EXHDR(pat);\n\n\tresult = (GenericMatchText(s, slen, p, plen) == LIKE_TRUE);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "Generic_Text_IC_like",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "161-221",
    "snippet": "static inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
      "static text *SB_do_like_escape(text *, text *);",
      "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
      "static text *MB_do_like_escape(text *, text *);",
      "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
      "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);",
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);",
      "static int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_IMatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "locale",
            "locale_is_c"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTF8_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str))"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1Coll",
          "args": [
            "lower",
            "collation",
            "PointerGetDatum(str)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "DirectFunctionCall1Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "792-810",
          "snippet": "Datum\nDirectFunctionCall1Coll(PGFunction func, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall1Coll(PGFunction func, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "str"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "pat"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "pat"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat))"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "pat"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collation"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine which collation to use for ILIKE\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INDETERMINATE_COLLATION"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lc_ctype_is_c",
          "args": [
            "collation"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "lc_ctype_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1236-1281",
          "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *SB_do_like_escape(text *, text *);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic text *MB_do_like_escape(text *, text *);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\nstatic int\tGeneric_Text_IC_like(text *str, text *pat, Oid collation);\n\nstatic inline int\nGeneric_Text_IC_like(text *str, text *pat, Oid collation)\n{\n\tchar\t   *s,\n\t\t\t   *p;\n\tint\t\t\tslen,\n\t\t\t\tplen;\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\tif (lc_ctype_is_c(collation))\n\t\tlocale_is_c = true;\n\telse if (collation != DEFAULT_COLLATION_OID)\n\t{\n\t\tif (!OidIsValid(collation))\n\t\t{\n\t\t\t/*\n\t\t\t * This typically means that the parser could not resolve a\n\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t}\n\t\tlocale = pg_newlocale_from_collation(collation);\n\t}\n\n\t/*\n\t * For efficiency reasons, in the single byte case we don't call lower()\n\t * on the pattern and text, but instead call SB_lower_char on each\n\t * character.  In the multi-byte case we don't have much choice :-(. Also,\n\t * ICU does not support single-character case folding, so we go the long\n\t * way.\n\t */\n\n\tif (pg_database_encoding_max_length() > 1 || (locale && locale->provider == COLLPROVIDER_ICU))\n\t{\n\t\t/* lower's result is never packed, so OK to use old macros here */\n\t\tpat = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(pat)));\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\tstr = DatumGetTextPP(DirectFunctionCall1Coll(lower, collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t PointerGetDatum(str)));\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\t\telse\n\t\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n\t}\n\telse\n\t{\n\t\tp = VARDATA_ANY(pat);\n\t\tplen = VARSIZE_ANY_EXHDR(pat);\n\t\ts = VARDATA_ANY(str);\n\t\tslen = VARSIZE_ANY_EXHDR(str);\n\t\treturn SB_IMatchText(s, slen, p, plen, locale, locale_is_c);\n\t}\n}"
  },
  {
    "function_name": "GenericMatchText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "150-159",
    "snippet": "static inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tGenericMatchText(char *s, int slen, char *p, int plen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MB_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UTF8_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_MatchText",
          "args": [
            "s",
            "slen",
            "p",
            "plen",
            "0",
            "true"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGenericMatchText(char *s, int slen, char *p, int plen);\n\nstatic inline int\nGenericMatchText(char *s, int slen, char *p, int plen)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn SB_MatchText(s, slen, p, plen, 0, true);\n\telse if (GetDatabaseEncoding() == PG_UTF8)\n\t\treturn UTF8_MatchText(s, slen, p, plen, 0, true);\n\telse\n\t\treturn MB_MatchText(s, slen, p, plen, 0, true);\n}"
  },
  {
    "function_name": "SB_lower_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "92-103",
    "snippet": "static char\nSB_lower_char(unsigned char c, pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn pg_ascii_tolower(c);\n#ifdef HAVE_LOCALE_T\n\telse if (locale)\n\t\treturn tolower_l(c, locale->info.lt);\n#endif\n\telse\n\t\treturn pg_tolower(c);\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
      "static int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);",
      "static int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);",
      "static int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower_l",
          "args": [
            "c",
            "locale->info.lt"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_ascii_tolower",
          "args": [
            "c"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int SB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic int MB_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t pg_locale_t locale, bool locale_is_c);\nstatic int UTF8_MatchText(char *t, int tlen, char *p, int plen,\n\t\t\t   pg_locale_t locale, bool locale_is_c);\nstatic int SB_IMatchText(char *t, int tlen, char *p, int plen,\n\t\t\t  pg_locale_t locale, bool locale_is_c);\n\nstatic char\nSB_lower_char(unsigned char c, pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn pg_ascii_tolower(c);\n#ifdef HAVE_LOCALE_T\n\telse if (locale)\n\t\treturn tolower_l(c, locale->info.lt);\n#endif\n\telse\n\t\treturn pg_tolower(c);\n}"
  },
  {
    "function_name": "wchareq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/like.c",
    "lines": "56-76",
    "snippet": "static inline int\nwchareq(char *p1, char *p2)\n{\n\tint\t\t\tp1_len;\n\n\t/* Optimization:  quickly compare the first byte. */\n\tif (*p1 != *p2)\n\t\treturn 0;\n\n\tp1_len = pg_mblen(p1);\n\tif (pg_mblen(p2) != p1_len)\n\t\treturn 0;\n\n\t/* They are the same length */\n\twhile (p1_len--)\n\t{\n\t\tif (*p1++ != *p2++)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"like_match.c\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p2"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"like_match.c\"\n#include \"utils/pg_locale.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline int\nwchareq(char *p1, char *p2)\n{\n\tint\t\t\tp1_len;\n\n\t/* Optimization:  quickly compare the first byte. */\n\tif (*p1 != *p2)\n\t\treturn 0;\n\n\tp1_len = pg_mblen(p1);\n\tif (pg_mblen(p2) != p1_len)\n\t\treturn 0;\n\n\t/* They are the same length */\n\twhile (p1_len--)\n\t{\n\t\tif (*p1++ != *p2++)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  }
]