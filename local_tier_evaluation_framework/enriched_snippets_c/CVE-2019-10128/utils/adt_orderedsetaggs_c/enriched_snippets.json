[
  {
    "function_name": "hypothetical_dense_rank_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1287-1421",
    "snippet": "Datum\nhypothetical_dense_rank_final(PG_FUNCTION_ARGS)\n{\n\tExprContext *econtext;\n\tExprState  *compareTuple;\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tint64\t\tduplicate_count = 0;\n\tOSAPerGroupState *osastate;\n\tint\t\t\tnumDistinctCols;\n\tDatum\t\tabbrevVal = (Datum) 0;\n\tDatum\t\tabbrevOld = (Datum) 0;\n\tTupleTableSlot *slot;\n\tTupleTableSlot *extraslot;\n\tTupleTableSlot *slot2;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_INT64(rank);\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\tecontext = osastate->qstate->econtext;\n\tif (!econtext)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\t/* Make sure to we create econtext under correct parent context. */\n\t\toldcontext = MemoryContextSwitchTo(osastate->qstate->qcontext);\n\t\tosastate->qstate->econtext = CreateStandaloneExprContext();\n\t\tecontext = osastate->qstate->econtext;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/*\n\t * When comparing tuples, we can omit the flag column since we will only\n\t * compare rows with flag == 0.\n\t */\n\tnumDistinctCols = osastate->qstate->numSortCols - 1;\n\n\t/* Build tuple comparator, if we didn't already */\n\tcompareTuple = osastate->qstate->compareTuple;\n\tif (compareTuple == NULL)\n\t{\n\t\tAttrNumber *sortColIdx = osastate->qstate->sortColIdx;\n\t\tMemoryContext oldContext;\n\n\t\toldContext = MemoryContextSwitchTo(osastate->qstate->qcontext);\n\t\tcompareTuple = execTuplesMatchPrepare(osastate->qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t  numDistinctCols,\n\t\t\t\t\t\t\t\t\t\t\t  sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t  osastate->qstate->eqOperators,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tMemoryContextSwitchTo(oldContext);\n\t\tosastate->qstate->compareTuple = compareTuple;\n\t}\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(-1);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/*\n\t * We alternate fetching into tupslot and extraslot so that we have the\n\t * previous row available for comparisons.  This is accomplished by\n\t * swapping the slot pointer variables after each row.\n\t */\n\textraslot = MakeSingleTupleTableSlot(osastate->qstate->tupdesc);\n\tslot2 = extraslot;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot,\n\t\t\t\t\t\t\t\t  &abbrevVal))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\t\tTupleTableSlot *tmpslot;\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\t/* count non-distinct tuples */\n\t\tecontext->ecxt_outertuple = slot;\n\t\tecontext->ecxt_innertuple = slot2;\n\n\t\tif (!TupIsNull(slot2) &&\n\t\t\tabbrevVal == abbrevOld &&\n\t\t\tExecQualAndReset(compareTuple, econtext))\n\t\t\tduplicate_count++;\n\n\t\ttmpslot = slot2;\n\t\tslot2 = slot;\n\t\tslot = tmpslot;\n\t\t/* avoid ExecQual() calls by reusing abbreviated keys */\n\t\tabbrevOld = abbrevVal;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\tExecClearTuple(slot2);\n\n\tExecDropSingleTupleTableSlot(extraslot);\n\n\trank = rank - duplicate_count;\n\n\tPG_RETURN_INT64(rank);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "rank"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecDropSingleTupleTableSlot",
          "args": [
            "extraslot"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot2"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecQualAndReset",
          "args": [
            "compareTuple",
            "econtext"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupIsNull",
          "args": [
            "slot2"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "d"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_getattr",
          "args": [
            "slot",
            "nargs + 1",
            "&isnull"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettupleslot",
          "args": [
            "osastate->sortstate",
            "true",
            "true",
            "slot",
            "&abbrevVal"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettupleslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2157-2186",
          "snippet": "bool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeSingleTupleTableSlot",
          "args": [
            "osastate->qstate->tupdesc"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_puttupleslot",
          "args": [
            "osastate->sortstate",
            "slot"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_puttupleslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1433-1448",
          "snippet": "void\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecStoreVirtualTuple",
          "args": [
            "slot"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i + 1"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "i + 1"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!osastate->sort_done"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldContext"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execTuplesMatchPrepare",
          "args": [
            "osastate->qstate->tupdesc",
            "numDistinctCols",
            "sortColIdx",
            "osastate->qstate->eqOperators",
            "NULL"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "osastate->qstate->qcontext"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypothetical_check_argtypes",
          "args": [
            "fcinfo",
            "nargs",
            "osastate->qstate->tupdesc"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "hypothetical_check_argtypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "1134-1154",
          "snippet": "static void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"wrong number of arguments in hypothetical-set function\""
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateStandaloneExprContext",
          "args": [],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "osastate->qstate->qcontext"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "rank"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nhypothetical_dense_rank_final(PG_FUNCTION_ARGS)\n{\n\tExprContext *econtext;\n\tExprState  *compareTuple;\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tint64\t\tduplicate_count = 0;\n\tOSAPerGroupState *osastate;\n\tint\t\t\tnumDistinctCols;\n\tDatum\t\tabbrevVal = (Datum) 0;\n\tDatum\t\tabbrevOld = (Datum) 0;\n\tTupleTableSlot *slot;\n\tTupleTableSlot *extraslot;\n\tTupleTableSlot *slot2;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_INT64(rank);\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\tecontext = osastate->qstate->econtext;\n\tif (!econtext)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\t/* Make sure to we create econtext under correct parent context. */\n\t\toldcontext = MemoryContextSwitchTo(osastate->qstate->qcontext);\n\t\tosastate->qstate->econtext = CreateStandaloneExprContext();\n\t\tecontext = osastate->qstate->econtext;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/*\n\t * When comparing tuples, we can omit the flag column since we will only\n\t * compare rows with flag == 0.\n\t */\n\tnumDistinctCols = osastate->qstate->numSortCols - 1;\n\n\t/* Build tuple comparator, if we didn't already */\n\tcompareTuple = osastate->qstate->compareTuple;\n\tif (compareTuple == NULL)\n\t{\n\t\tAttrNumber *sortColIdx = osastate->qstate->sortColIdx;\n\t\tMemoryContext oldContext;\n\n\t\toldContext = MemoryContextSwitchTo(osastate->qstate->qcontext);\n\t\tcompareTuple = execTuplesMatchPrepare(osastate->qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t  numDistinctCols,\n\t\t\t\t\t\t\t\t\t\t\t  sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t  osastate->qstate->eqOperators,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tMemoryContextSwitchTo(oldContext);\n\t\tosastate->qstate->compareTuple = compareTuple;\n\t}\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(-1);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/*\n\t * We alternate fetching into tupslot and extraslot so that we have the\n\t * previous row available for comparisons.  This is accomplished by\n\t * swapping the slot pointer variables after each row.\n\t */\n\textraslot = MakeSingleTupleTableSlot(osastate->qstate->tupdesc);\n\tslot2 = extraslot;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot,\n\t\t\t\t\t\t\t\t  &abbrevVal))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\t\tTupleTableSlot *tmpslot;\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\t/* count non-distinct tuples */\n\t\tecontext->ecxt_outertuple = slot;\n\t\tecontext->ecxt_innertuple = slot2;\n\n\t\tif (!TupIsNull(slot2) &&\n\t\t\tabbrevVal == abbrevOld &&\n\t\t\tExecQualAndReset(compareTuple, econtext))\n\t\t\tduplicate_count++;\n\n\t\ttmpslot = slot2;\n\t\tslot2 = slot;\n\t\tslot = tmpslot;\n\t\t/* avoid ExecQual() calls by reusing abbreviated keys */\n\t\tabbrevOld = abbrevVal;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\tExecClearTuple(slot2);\n\n\tExecDropSingleTupleTableSlot(extraslot);\n\n\trank = rank - duplicate_count;\n\n\tPG_RETURN_INT64(rank);\n}"
  },
  {
    "function_name": "hypothetical_cume_dist_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1270-1282",
    "snippet": "Datum\nhypothetical_cume_dist_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\tdouble\t\tresult_val;\n\n\trank = hypothetical_rank_common(fcinfo, 1, &rowcount);\n\n\tresult_val = (double) (rank) / (double) (rowcount + 1);\n\n\tPG_RETURN_FLOAT8(result_val);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result_val"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypothetical_rank_common",
          "args": [
            "fcinfo",
            "1",
            "&rowcount"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "hypothetical_rank_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "1163-1230",
          "snippet": "static int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nhypothetical_cume_dist_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\tdouble\t\tresult_val;\n\n\trank = hypothetical_rank_common(fcinfo, 1, &rowcount);\n\n\tresult_val = (double) (rank) / (double) (rowcount + 1);\n\n\tPG_RETURN_FLOAT8(result_val);\n}"
  },
  {
    "function_name": "hypothetical_percent_rank_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1250-1265",
    "snippet": "Datum\nhypothetical_percent_rank_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\tdouble\t\tresult_val;\n\n\trank = hypothetical_rank_common(fcinfo, -1, &rowcount);\n\n\tif (rowcount == 0)\n\t\tPG_RETURN_FLOAT8(0);\n\n\tresult_val = (double) (rank - 1) / (double) (rowcount);\n\n\tPG_RETURN_FLOAT8(result_val);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result_val"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypothetical_rank_common",
          "args": [
            "fcinfo",
            "-1",
            "&rowcount"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "hypothetical_rank_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "1163-1230",
          "snippet": "static int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nhypothetical_percent_rank_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\tdouble\t\tresult_val;\n\n\trank = hypothetical_rank_common(fcinfo, -1, &rowcount);\n\n\tif (rowcount == 0)\n\t\tPG_RETURN_FLOAT8(0);\n\n\tresult_val = (double) (rank - 1) / (double) (rowcount);\n\n\tPG_RETURN_FLOAT8(result_val);\n}"
  },
  {
    "function_name": "hypothetical_rank_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1236-1245",
    "snippet": "Datum\nhypothetical_rank_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\n\trank = hypothetical_rank_common(fcinfo, -1, &rowcount);\n\n\tPG_RETURN_INT64(rank);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "rank"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypothetical_rank_common",
          "args": [
            "fcinfo",
            "-1",
            "&rowcount"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "hypothetical_rank_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "1163-1230",
          "snippet": "static int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nhypothetical_rank_final(PG_FUNCTION_ARGS)\n{\n\tint64\t\trank;\n\tint64\t\trowcount;\n\n\trank = hypothetical_rank_common(fcinfo, -1, &rowcount);\n\n\tPG_RETURN_INT64(rank);\n}"
  },
  {
    "function_name": "hypothetical_rank_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1163-1230",
    "snippet": "static int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "d"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_getattr",
          "args": [
            "slot",
            "nargs + 1",
            "&isnull"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettupleslot",
          "args": [
            "osastate->sortstate",
            "true",
            "true",
            "slot",
            "NULL"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettupleslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2157-2186",
          "snippet": "bool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_puttupleslot",
          "args": [
            "osastate->sortstate",
            "slot"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_puttupleslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1433-1448",
          "snippet": "void\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecStoreVirtualTuple",
          "args": [
            "slot"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "flag"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i + 1"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "i + 1"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!osastate->sort_done"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypothetical_check_argtypes",
          "args": [
            "fcinfo",
            "nargs",
            "osastate->qstate->tupdesc"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "hypothetical_check_argtypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "1134-1154",
          "snippet": "static void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"wrong number of arguments in hypothetical-set function\""
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic int64\nhypothetical_rank_common(FunctionCallInfo fcinfo, int flag,\n\t\t\t\t\t\t int64 *number_of_rows)\n{\n\tint\t\t\tnargs = PG_NARGS() - 1;\n\tint64\t\trank = 1;\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the rank is always 1 */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\t*number_of_rows = 0;\n\t\treturn 1;\n\t}\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\t*number_of_rows = osastate->number_of_rows;\n\n\t/* Adjust nargs to be the number of direct (or aggregated) args */\n\tif (nargs % 2 != 0)\n\t\telog(ERROR, \"wrong number of arguments in hypothetical-set function\");\n\tnargs /= 2;\n\n\thypothetical_check_argtypes(fcinfo, nargs, osastate->qstate->tupdesc);\n\n\t/* because we need a hypothetical row, we can't share transition state */\n\tAssert(!osastate->sort_done);\n\n\t/* insert the hypothetical row into the sort */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tslot->tts_values[i] = Int32GetDatum(flag);\n\tslot->tts_isnull[i] = false;\n\tExecStoreVirtualTuple(slot);\n\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\n\t/* finish the sort */\n\ttuplesort_performsort(osastate->sortstate);\n\tosastate->sort_done = true;\n\n\t/* iterate till we find the hypothetical row */\n\twhile (tuplesort_gettupleslot(osastate->sortstate, true, true, slot, NULL))\n\t{\n\t\tbool\t\tisnull;\n\t\tDatum\t\td = slot_getattr(slot, nargs + 1, &isnull);\n\n\t\tif (!isnull && DatumGetInt32(d) != 0)\n\t\t\tbreak;\n\n\t\trank++;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tExecClearTuple(slot);\n\n\treturn rank;\n}"
  },
  {
    "function_name": "hypothetical_check_argtypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1134-1154",
    "snippet": "static void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"type mismatch in hypothetical-set function\""
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "i + 1"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "nargs"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void\nhypothetical_check_argtypes(FunctionCallInfo fcinfo, int nargs,\n\t\t\t\t\t\t\tTupleDesc tupdesc)\n{\n\tint\t\t\ti;\n\n\t/* check that we have an int4 flag column */\n\tif (!tupdesc ||\n\t\t(nargs + 1) != tupdesc->natts ||\n\t\tTupleDescAttr(tupdesc, nargs)->atttypid != INT4OID)\n\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\n\t/* check that direct args match in type with aggregated args */\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, i);\n\n\t\tif (get_fn_expr_argtype(fcinfo->flinfo, i + 1) != attr->atttypid)\n\t\t\telog(ERROR, \"type mismatch in hypothetical-set function\");\n\t}\n}"
  },
  {
    "function_name": "mode_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1026-1126",
    "snippet": "Datum\nmode_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tDatum\t\tmode_val = (Datum) 0;\n\tint64\t\tmode_freq = 0;\n\tDatum\t\tlast_val = (Datum) 0;\n\tint64\t\tlast_val_freq = 0;\n\tbool\t\tlast_val_is_mode = false;\n\tFmgrInfo   *equalfn;\n\tDatum\t\tabbrev_val = (Datum) 0;\n\tDatum\t\tlast_abbrev_val = (Datum) 0;\n\tbool\t\tshouldfree;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Look up the equality function for the datatype, if we didn't already */\n\tequalfn = &(osastate->qstate->equalfn);\n\tif (!OidIsValid(equalfn->fn_oid))\n\t\tfmgr_info_cxt(get_opcode(osastate->qstate->eqOperator), equalfn,\n\t\t\t\t\t  osastate->qstate->qcontext);\n\n\tshouldfree = !(osastate->qstate->typByVal);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\t/* Scan tuples and count frequencies */\n\twhile (tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, &abbrev_val))\n\t{\n\t\t/* we don't expect any nulls, but ignore them if found */\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\tif (last_val_freq == 0)\n\t\t{\n\t\t\t/* first nonnull value - it's the mode for now */\n\t\t\tmode_val = last_val = val;\n\t\t\tmode_freq = last_val_freq = 1;\n\t\t\tlast_val_is_mode = true;\n\t\t\tlast_abbrev_val = abbrev_val;\n\t\t}\n\t\telse if (abbrev_val == last_abbrev_val &&\n\t\t\t\t DatumGetBool(FunctionCall2(equalfn, val, last_val)))\n\t\t{\n\t\t\t/* value equal to previous value, count it */\n\t\t\tif (last_val_is_mode)\n\t\t\t\tmode_freq++;\t/* needn't maintain last_val_freq */\n\t\t\telse if (++last_val_freq > mode_freq)\n\t\t\t{\n\t\t\t\t/* last_val becomes new mode */\n\t\t\t\tif (shouldfree)\n\t\t\t\t\tpfree(DatumGetPointer(mode_val));\n\t\t\t\tmode_val = last_val;\n\t\t\t\tmode_freq = last_val_freq;\n\t\t\t\tlast_val_is_mode = true;\n\t\t\t}\n\t\t\tif (shouldfree)\n\t\t\t\tpfree(DatumGetPointer(val));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* val should replace last_val */\n\t\t\tif (shouldfree && !last_val_is_mode)\n\t\t\t\tpfree(DatumGetPointer(last_val));\n\t\t\tlast_val = val;\n\t\t\t/* avoid equality function calls by reusing abbreviated keys */\n\t\t\tlast_abbrev_val = abbrev_val;\n\t\t\tlast_val_freq = 1;\n\t\t\tlast_val_is_mode = false;\n\t\t}\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tif (shouldfree && !last_val_is_mode)\n\t\tpfree(DatumGetPointer(last_val));\n\n\tif (mode_freq)\n\t\tPG_RETURN_DATUM(mode_val);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "mode_val"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "DatumGetPointer(last_val)"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "last_val"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "last_val"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "val"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "mode_val"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2(equalfn, val, last_val)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2",
          "args": [
            "equalfn",
            "val",
            "last_val"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_getdatum",
          "args": [
            "osastate->sortstate",
            "true",
            "&val",
            "&isnull",
            "&abbrev_val"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_getdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2243-2276",
          "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_rescan",
          "args": [
            "osastate->sortstate"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3027-3057",
          "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "get_opcode(osastate->qstate->eqOperator)",
            "equalfn",
            "osastate->qstate->qcontext"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "osastate->qstate->eqOperator"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "equalfn->fn_oid"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nmode_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tDatum\t\tmode_val = (Datum) 0;\n\tint64\t\tmode_freq = 0;\n\tDatum\t\tlast_val = (Datum) 0;\n\tint64\t\tlast_val_freq = 0;\n\tbool\t\tlast_val_is_mode = false;\n\tFmgrInfo   *equalfn;\n\tDatum\t\tabbrev_val = (Datum) 0;\n\tDatum\t\tlast_abbrev_val = (Datum) 0;\n\tbool\t\tshouldfree;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Look up the equality function for the datatype, if we didn't already */\n\tequalfn = &(osastate->qstate->equalfn);\n\tif (!OidIsValid(equalfn->fn_oid))\n\t\tfmgr_info_cxt(get_opcode(osastate->qstate->eqOperator), equalfn,\n\t\t\t\t\t  osastate->qstate->qcontext);\n\n\tshouldfree = !(osastate->qstate->typByVal);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\t/* Scan tuples and count frequencies */\n\twhile (tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, &abbrev_val))\n\t{\n\t\t/* we don't expect any nulls, but ignore them if found */\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\tif (last_val_freq == 0)\n\t\t{\n\t\t\t/* first nonnull value - it's the mode for now */\n\t\t\tmode_val = last_val = val;\n\t\t\tmode_freq = last_val_freq = 1;\n\t\t\tlast_val_is_mode = true;\n\t\t\tlast_abbrev_val = abbrev_val;\n\t\t}\n\t\telse if (abbrev_val == last_abbrev_val &&\n\t\t\t\t DatumGetBool(FunctionCall2(equalfn, val, last_val)))\n\t\t{\n\t\t\t/* value equal to previous value, count it */\n\t\t\tif (last_val_is_mode)\n\t\t\t\tmode_freq++;\t/* needn't maintain last_val_freq */\n\t\t\telse if (++last_val_freq > mode_freq)\n\t\t\t{\n\t\t\t\t/* last_val becomes new mode */\n\t\t\t\tif (shouldfree)\n\t\t\t\t\tpfree(DatumGetPointer(mode_val));\n\t\t\t\tmode_val = last_val;\n\t\t\t\tmode_freq = last_val_freq;\n\t\t\t\tlast_val_is_mode = true;\n\t\t\t}\n\t\t\tif (shouldfree)\n\t\t\t\tpfree(DatumGetPointer(val));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* val should replace last_val */\n\t\t\tif (shouldfree && !last_val_is_mode)\n\t\t\t\tpfree(DatumGetPointer(last_val));\n\t\t\tlast_val = val;\n\t\t\t/* avoid equality function calls by reusing abbreviated keys */\n\t\t\tlast_abbrev_val = abbrev_val;\n\t\t\tlast_val_freq = 1;\n\t\t\tlast_val_is_mode = false;\n\t\t}\n\n\t\tCHECK_FOR_INTERRUPTS();\n\t}\n\n\tif (shouldfree && !last_val_is_mode)\n\t\tpfree(DatumGetPointer(last_val));\n\n\tif (mode_freq)\n\t\tPG_RETURN_DATUM(mode_val);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "percentile_cont_interval_multi_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "1012-1020",
    "snippet": "Datum\npercentile_cont_interval_multi_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_multi_final_common(fcinfo,\n\t\t\t\t\t\t\t\t\t\t\t  INTERVALOID,\n\t/* hard-wired info on type interval */\n\t\t\t\t\t\t\t\t\t\t\t  16, false, 'd',\n\t\t\t\t\t\t\t\t\t\t\t  interval_lerp);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percentile_cont_multi_final_common",
          "args": [
            "fcinfo",
            "INTERVALOID",
            "/* hard-wired info on type interval */16",
            "false",
            "'d'",
            "interval_lerp"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "percentile_cont_multi_final_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "841-994",
          "snippet": "static Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_cont_interval_multi_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_multi_final_common(fcinfo,\n\t\t\t\t\t\t\t\t\t\t\t  INTERVALOID,\n\t/* hard-wired info on type interval */\n\t\t\t\t\t\t\t\t\t\t\t  16, false, 'd',\n\t\t\t\t\t\t\t\t\t\t\t  interval_lerp);\n}"
  },
  {
    "function_name": "percentile_cont_float8_multi_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "999-1007",
    "snippet": "Datum\npercentile_cont_float8_multi_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_multi_final_common(fcinfo,\n\t\t\t\t\t\t\t\t\t\t\t  FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t\t\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t\t\t\t\t\t\t  float8_lerp);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percentile_cont_multi_final_common",
          "args": [
            "fcinfo",
            "FLOAT8OID",
            "/* hard-wired info on type float8 */8",
            "FLOAT8PASSBYVAL",
            "'d'",
            "float8_lerp"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "percentile_cont_multi_final_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "841-994",
          "snippet": "static Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_cont_float8_multi_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_multi_final_common(fcinfo,\n\t\t\t\t\t\t\t\t\t\t\t  FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t\t\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t\t\t\t\t\t\t  float8_lerp);\n}"
  },
  {
    "function_name": "percentile_cont_multi_final_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "841-994",
    "snippet": "static Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "result_datum",
            "result_isnull",
            "ARR_NDIM(param)",
            "ARR_DIMS(param)",
            "ARR_LBOUND(param)",
            "expect_type",
            "typLen",
            "typByVal",
            "typAlign"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "param"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "param"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "param"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lerpfunc",
          "args": [
            "first_val",
            "second_val",
            "pct_info[i].proportion"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "second_row == rownum"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing row in percentile_cont\""
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_getdatum",
          "args": [
            "osastate->sortstate",
            "true",
            "&second_val",
            "&isnull",
            "NULL"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_getdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2243-2276",
          "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_skiptuples",
          "args": [
            "osastate->sortstate",
            "first_row - rownum - 1",
            "true"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_skiptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2283-2343",
          "snippet": "bool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_rescan",
          "args": [
            "osastate->sortstate"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3027-3057",
          "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "num_percentiles * sizeof(bool)"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_pct_info",
          "args": [
            "num_percentiles",
            "percentiles_datum",
            "percentiles_null",
            "osastate->number_of_rows",
            "true"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "setup_pct_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "654-718",
          "snippet": "static struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "construct_empty_array(osastate->qstate->sortColType)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "osastate->qstate->sortColType"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "param",
            "FLOAT8OID",
            "/* hard-wired info on type float8 */8",
            "FLOAT8PASSBYVAL",
            "'d'",
            "&percentiles_datum",
            "&percentiles_null",
            "&num_percentiles"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "expect_type == osastate->qstate->sortColType"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_multi_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t\t   Oid expect_type,\n\t\t\t\t\t\t\t\t   int16 typLen, bool typByVal, char typAlign,\n\t\t\t\t\t\t\t\t   LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tfirst_val = (Datum) 0;\n\tDatum\t\tsecond_val = (Datum) 0;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  true);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\tfirst_row = pct_info[i].first_row;\n\t\t\tint64\t\tsecond_row = pct_info[i].second_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/*\n\t\t\t * Advance to first_row, if not already there.  Note that we might\n\t\t\t * already have rownum beyond first_row, in which case first_val\n\t\t\t * is already correct.  (This occurs when interpolating between\n\t\t\t * the same two input rows as for the previous percentile.)\n\t\t\t */\n\t\t\tif (first_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, first_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\t\t\trownum = first_row;\n\t\t\t\t/* Always advance second_val to be latest input value */\n\t\t\t\tsecond_val = first_val;\n\t\t\t}\n\t\t\telse if (first_row == rownum)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We are already at the desired row, so we must previously\n\t\t\t\t * have read its value into second_val (and perhaps first_val\n\t\t\t\t * as well, but this assignment is harmless in that case).\n\t\t\t\t */\n\t\t\t\tfirst_val = second_val;\n\t\t\t}\n\n\t\t\t/* Fetch second_row if needed */\n\t\t\tif (second_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val,\n\t\t\t\t\t\t\t\t\t\t&isnull, NULL) || isnull)\n\t\t\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\t\t\t\trownum++;\n\t\t\t}\n\t\t\t/* We should now certainly be on second_row exactly */\n\t\t\tAssert(second_row == rownum);\n\n\t\t\t/* Compute appropriate result */\n\t\t\tif (second_row > first_row)\n\t\t\t\tresult_datum[idx] = lerpfunc(first_val, second_val,\n\t\t\t\t\t\t\t\t\t\t\t pct_info[i].proportion);\n\t\t\telse\n\t\t\t\tresult_datum[idx] = first_val;\n\n\t\t\tresult_isnull[idx] = false;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param), ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t expect_type,\n\t\t\t\t\t\t\t\t\t\t typLen,\n\t\t\t\t\t\t\t\t\t\t typByVal,\n\t\t\t\t\t\t\t\t\t\t typAlign));\n}"
  },
  {
    "function_name": "percentile_disc_multi_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "723-836",
    "snippet": "Datum\npercentile_disc_multi_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tval = (Datum) 0;\n\tbool\t\tisnull = true;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  false);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\ttarget_row = pct_info[i].first_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/* Advance to target row, if not already there */\n\t\t\tif (target_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, target_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, NULL))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t\t\t\trownum = target_row;\n\t\t\t}\n\n\t\t\tresult_datum[idx] = val;\n\t\t\tresult_isnull[idx] = isnull;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param),\n\t\t\t\t\t\t\t\t\t\t ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typLen,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typByVal,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typAlign));\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param),\n\t\t\t\t\t\t\t\t\t\t ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typLen,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typByVal,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typAlign)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "result_datum",
            "result_isnull",
            "ARR_NDIM(param)",
            "ARR_DIMS(param)",
            "ARR_LBOUND(param)",
            "osastate->qstate->sortColType",
            "osastate->qstate->typLen",
            "osastate->qstate->typByVal",
            "osastate->qstate->typAlign"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "param"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "param"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "param"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing row in percentile_disc\""
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_getdatum",
          "args": [
            "osastate->sortstate",
            "true",
            "&val",
            "&isnull",
            "NULL"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_getdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2243-2276",
          "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_skiptuples",
          "args": [
            "osastate->sortstate",
            "target_row - rownum - 1",
            "true"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_skiptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2283-2343",
          "snippet": "bool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_rescan",
          "args": [
            "osastate->sortstate"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3027-3057",
          "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "num_percentiles * sizeof(bool)"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_pct_info",
          "args": [
            "num_percentiles",
            "percentiles_datum",
            "percentiles_null",
            "osastate->number_of_rows",
            "false"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "setup_pct_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "654-718",
          "snippet": "static struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "construct_empty_array(osastate->qstate->sortColType)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "osastate->qstate->sortColType"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "param",
            "FLOAT8OID",
            "/* hard-wired info on type float8 */8",
            "FLOAT8PASSBYVAL",
            "'d'",
            "&percentiles_datum",
            "&percentiles_null",
            "&num_percentiles"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_disc_multi_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tArrayType  *param;\n\tDatum\t   *percentiles_datum;\n\tbool\t   *percentiles_null;\n\tint\t\t\tnum_percentiles;\n\tstruct pct_info *pct_info;\n\tDatum\t   *result_datum;\n\tbool\t   *result_isnull;\n\tint64\t\trownum = 0;\n\tDatum\t\tval = (Datum) 0;\n\tbool\t\tisnull = true;\n\tint\t\t\ti;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Deconstruct the percentile-array input */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tparam = PG_GETARG_ARRAYTYPE_P(1);\n\n\tdeconstruct_array(param, FLOAT8OID,\n\t/* hard-wired info on type float8 */\n\t\t\t\t\t  8, FLOAT8PASSBYVAL, 'd',\n\t\t\t\t\t  &percentiles_datum,\n\t\t\t\t\t  &percentiles_null,\n\t\t\t\t\t  &num_percentiles);\n\n\tif (num_percentiles == 0)\n\t\tPG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));\n\n\tpct_info = setup_pct_info(num_percentiles,\n\t\t\t\t\t\t\t  percentiles_datum,\n\t\t\t\t\t\t\t  percentiles_null,\n\t\t\t\t\t\t\t  osastate->number_of_rows,\n\t\t\t\t\t\t\t  false);\n\n\tresult_datum = (Datum *) palloc(num_percentiles * sizeof(Datum));\n\tresult_isnull = (bool *) palloc(num_percentiles * sizeof(bool));\n\n\t/*\n\t * Start by dealing with any nulls in the param array - those are sorted\n\t * to the front on row=0, so set the corresponding result indexes to null\n\t */\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\tif (pct_info[i].first_row > 0)\n\t\t\tbreak;\n\n\t\tresult_datum[idx] = (Datum) 0;\n\t\tresult_isnull[idx] = true;\n\t}\n\n\t/*\n\t * If there's anything left after doing the nulls, then grind the input\n\t * and extract the needed values\n\t */\n\tif (i < num_percentiles)\n\t{\n\t\t/* Finish the sort, or rescan if we already did */\n\t\tif (!osastate->sort_done)\n\t\t{\n\t\t\ttuplesort_performsort(osastate->sortstate);\n\t\t\tosastate->sort_done = true;\n\t\t}\n\t\telse\n\t\t\ttuplesort_rescan(osastate->sortstate);\n\n\t\tfor (; i < num_percentiles; i++)\n\t\t{\n\t\t\tint64\t\ttarget_row = pct_info[i].first_row;\n\t\t\tint\t\t\tidx = pct_info[i].idx;\n\n\t\t\t/* Advance to target row, if not already there */\n\t\t\tif (target_row > rownum)\n\t\t\t{\n\t\t\t\tif (!tuplesort_skiptuples(osastate->sortstate, target_row - rownum - 1, true))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t\t\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, NULL))\n\t\t\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t\t\t\trownum = target_row;\n\t\t\t}\n\n\t\t\tresult_datum[idx] = val;\n\t\t\tresult_isnull[idx] = isnull;\n\t\t}\n\t}\n\n\t/* We make the output array the same shape as the input */\n\tPG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,\n\t\t\t\t\t\t\t\t\t\t ARR_NDIM(param),\n\t\t\t\t\t\t\t\t\t\t ARR_DIMS(param),\n\t\t\t\t\t\t\t\t\t\t ARR_LBOUND(param),\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typLen,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typByVal,\n\t\t\t\t\t\t\t\t\t\t osastate->qstate->typAlign));\n}"
  },
  {
    "function_name": "setup_pct_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "654-718",
    "snippet": "static struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "pct_info",
            "num_percentiles",
            "sizeof(struct pct_info)",
            "pct_info_cmp"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "1",
            "row"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "p * rowcount"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "p * (rowcount - 1)"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp))"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"percentile value %g is not between 0 and 1\"",
            "p"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "p"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "percentiles_datum[i]"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "num_percentiles * sizeof(struct pct_info)"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic struct pct_info *\nsetup_pct_info(int num_percentiles,\n\t\t\t   Datum *percentiles_datum,\n\t\t\t   bool *percentiles_null,\n\t\t\t   int64 rowcount,\n\t\t\t   bool continuous)\n{\n\tstruct pct_info *pct_info;\n\tint\t\t\ti;\n\n\tpct_info = (struct pct_info *) palloc(num_percentiles * sizeof(struct pct_info));\n\n\tfor (i = 0; i < num_percentiles; i++)\n\t{\n\t\tpct_info[i].idx = i;\n\n\t\tif (percentiles_null[i])\n\t\t{\n\t\t\t/* dummy entry for any NULL in array */\n\t\t\tpct_info[i].first_row = 0;\n\t\t\tpct_info[i].second_row = 0;\n\t\t\tpct_info[i].proportion = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble\t\tp = DatumGetFloat8(percentiles_datum[i]);\n\n\t\t\tif (p < 0 || p > 1 || isnan(p))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\t\t\tp)));\n\n\t\t\tif (continuous)\n\t\t\t{\n\t\t\t\tpct_info[i].first_row = 1 + floor(p * (rowcount - 1));\n\t\t\t\tpct_info[i].second_row = 1 + ceil(p * (rowcount - 1));\n\t\t\t\tpct_info[i].proportion = (p * (rowcount - 1)) - floor(p * (rowcount - 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*----------\n\t\t\t\t * We need the smallest K such that (K/N) >= percentile.\n\t\t\t\t * N>0, therefore K >= N*percentile, therefore\n\t\t\t\t * K = ceil(N*percentile); but not less than 1.\n\t\t\t\t *----------\n\t\t\t\t */\n\t\t\t\tint64\t\trow = (int64) ceil(p * rowcount);\n\n\t\t\t\trow = Max(1, row);\n\t\t\t\tpct_info[i].first_row = row;\n\t\t\t\tpct_info[i].second_row = row;\n\t\t\t\tpct_info[i].proportion = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The parameter array wasn't necessarily in sorted order, but we need to\n\t * visit the rows in order, so sort by first_row/second_row.\n\t */\n\tqsort(pct_info, num_percentiles, sizeof(struct pct_info), pct_info_cmp);\n\n\treturn pct_info;\n}"
  },
  {
    "function_name": "pct_info_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "638-649",
    "snippet": "static int\npct_info_cmp(const void *pa, const void *pb)\n{\n\tconst struct pct_info *a = (const struct pct_info *) pa;\n\tconst struct pct_info *b = (const struct pct_info *) pb;\n\n\tif (a->first_row != b->first_row)\n\t\treturn (a->first_row < b->first_row) ? -1 : 1;\n\tif (a->second_row != b->second_row)\n\t\treturn (a->second_row < b->second_row) ? -1 : 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic int\npct_info_cmp(const void *pa, const void *pb)\n{\n\tconst struct pct_info *a = (const struct pct_info *) pa;\n\tconst struct pct_info *b = (const struct pct_info *) pb;\n\n\tif (a->first_row != b->first_row)\n\t\treturn (a->first_row < b->first_row) ? -1 : 1;\n\tif (a->second_row != b->second_row)\n\t\treturn (a->second_row < b->second_row) ? -1 : 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "percentile_cont_interval_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "614-618",
    "snippet": "Datum\npercentile_cont_interval_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_final_common(fcinfo, INTERVALOID, interval_lerp);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percentile_cont_final_common",
          "args": [
            "fcinfo",
            "INTERVALOID",
            "interval_lerp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "percentile_cont_final_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "520-600",
          "snippet": "static Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_cont_interval_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_final_common(fcinfo, INTERVALOID, interval_lerp);\n}"
  },
  {
    "function_name": "percentile_cont_float8_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "605-609",
    "snippet": "Datum\npercentile_cont_float8_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_final_common(fcinfo, FLOAT8OID, float8_lerp);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percentile_cont_final_common",
          "args": [
            "fcinfo",
            "FLOAT8OID",
            "float8_lerp"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "percentile_cont_final_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "520-600",
          "snippet": "static Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_cont_float8_final(PG_FUNCTION_ARGS)\n{\n\treturn percentile_cont_final_common(fcinfo, FLOAT8OID, float8_lerp);\n}"
  },
  {
    "function_name": "percentile_cont_final_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "520-600",
    "snippet": "static Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "val"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lerpfunc",
          "args": [
            "first_val",
            "second_val",
            "proportion"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing row in percentile_cont\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_getdatum",
          "args": [
            "osastate->sortstate",
            "true",
            "&second_val",
            "&isnull",
            "NULL"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_getdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2243-2276",
          "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_skiptuples",
          "args": [
            "osastate->sortstate",
            "first_row",
            "true"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_skiptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2283-2343",
          "snippet": "bool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "first_row < osastate->number_of_rows"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "percentile * (osastate->number_of_rows - 1)"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "percentile * (osastate->number_of_rows - 1)"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_rescan",
          "args": [
            "osastate->sortstate"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3027-3057",
          "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "expect_type == osastate->qstate->sortColType"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile))"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"percentile value %g is not between 0 and 1\"",
            "percentile"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "percentile"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\npercentile_cont_final_common(FunctionCallInfo fcinfo,\n\t\t\t\t\t\t\t Oid expect_type,\n\t\t\t\t\t\t\t LerpFunc lerpfunc)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tint64\t\tfirst_row = 0;\n\tint64\t\tsecond_row = 0;\n\tDatum\t\tval;\n\tDatum\t\tfirst_val;\n\tDatum\t\tsecond_val;\n\tdouble\t\tproportion;\n\tbool\t\tisnull;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\tAssert(expect_type == osastate->qstate->sortColType);\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\tfirst_row = floor(percentile * (osastate->number_of_rows - 1));\n\tsecond_row = ceil(percentile * (osastate->number_of_rows - 1));\n\n\tAssert(first_row < osastate->number_of_rows);\n\n\tif (!tuplesort_skiptuples(osastate->sortstate, first_row, true))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &first_val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_cont\");\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\n\tif (first_row == second_row)\n\t{\n\t\tval = first_val;\n\t}\n\telse\n\t{\n\t\tif (!tuplesort_getdatum(osastate->sortstate, true, &second_val, &isnull, NULL))\n\t\t\telog(ERROR, \"missing row in percentile_cont\");\n\n\t\tif (isnull)\n\t\t\tPG_RETURN_NULL();\n\n\t\tproportion = (percentile * (osastate->number_of_rows - 1)) - first_row;\n\t\tval = lerpfunc(first_val, second_val, proportion);\n\t}\n\n\tPG_RETURN_DATUM(val);\n}"
  },
  {
    "function_name": "interval_lerp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "506-515",
    "snippet": "static Datum\ninterval_lerp(Datum lo, Datum hi, double pct)\n{\n\tDatum\t\tdiff_result = DirectFunctionCall2(interval_mi, hi, lo);\n\tDatum\t\tmul_result = DirectFunctionCall2(interval_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t diff_result,\n\t\t\t\t\t\t\t\t\t\t\t\t Float8GetDatumFast(pct));\n\n\treturn DirectFunctionCall2(interval_pl, mul_result, lo);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_pl",
            "mul_result",
            "lo"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_mul",
            "diff_result",
            "Float8GetDatumFast(pct)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Float8GetDatumFast",
          "args": [
            "pct"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "interval_mi",
            "hi",
            "lo"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\ninterval_lerp(Datum lo, Datum hi, double pct)\n{\n\tDatum\t\tdiff_result = DirectFunctionCall2(interval_mi, hi, lo);\n\tDatum\t\tmul_result = DirectFunctionCall2(interval_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t diff_result,\n\t\t\t\t\t\t\t\t\t\t\t\t Float8GetDatumFast(pct));\n\n\treturn DirectFunctionCall2(interval_pl, mul_result, lo);\n}"
  },
  {
    "function_name": "float8_lerp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "497-504",
    "snippet": "static Datum\nfloat8_lerp(Datum lo, Datum hi, double pct)\n{\n\tdouble\t\tloval = DatumGetFloat8(lo);\n\tdouble\t\thival = DatumGetFloat8(hi);\n\n\treturn Float8GetDatum(loval + (pct * (hival - loval)));\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Float8GetDatum",
          "args": [
            "loval + (pct * (hival - loval))"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "Float8GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1900-1907",
          "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "hi"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "lo"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic Datum\nfloat8_lerp(Datum lo, Datum hi, double pct)\n{\n\tdouble\t\tloval = DatumGetFloat8(lo);\n\tdouble\t\thival = DatumGetFloat8(hi);\n\n\treturn Float8GetDatum(loval + (pct * (hival - loval)));\n}"
  },
  {
    "function_name": "percentile_disc_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "422-487",
    "snippet": "Datum\npercentile_disc_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint64\t\trownum;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\t/*----------\n\t * We need the smallest K such that (K/N) >= percentile.\n\t * N>0, therefore K >= N*percentile, therefore K = ceil(N*percentile).\n\t * So we skip K-1 rows (if K>0) and return the next row fetched.\n\t *----------\n\t */\n\trownum = (int64) ceil(percentile * osastate->number_of_rows);\n\tAssert(rownum <= osastate->number_of_rows);\n\n\tif (rownum > 1)\n\t{\n\t\tif (!tuplesort_skiptuples(osastate->sortstate, rownum - 1, true))\n\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\t}\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t/* We shouldn't have stored any nulls, but do the right thing anyway */\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(val);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "val"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing row in percentile_disc\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_getdatum",
          "args": [
            "osastate->sortstate",
            "true",
            "&val",
            "&isnull",
            "NULL"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_getdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2243-2276",
          "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_skiptuples",
          "args": [
            "osastate->sortstate",
            "rownum - 1",
            "true"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_skiptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2283-2343",
          "snippet": "bool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rownum <= osastate->number_of_rows"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "percentile * osastate->number_of_rows"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_rescan",
          "args": [
            "osastate->sortstate"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_rescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3027-3057",
          "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_performsort",
          "args": [
            "osastate->sortstate"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_performsort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1789-1891",
          "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile))"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"percentile value %g is not between 0 and 1\"",
            "percentile"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "percentile"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\npercentile_disc_final(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tdouble\t\tpercentile;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint64\t\trownum;\n\n\tAssert(AggCheckCallContext(fcinfo, NULL) == AGG_CONTEXT_AGGREGATE);\n\n\t/* Get and check the percentile argument */\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tpercentile = PG_GETARG_FLOAT8(1);\n\n\tif (percentile < 0 || percentile > 1 || isnan(percentile))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"percentile value %g is not between 0 and 1\",\n\t\t\t\t\t\tpercentile)));\n\n\t/* If there were no regular rows, the result is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* number_of_rows could be zero if we only saw NULL input values */\n\tif (osastate->number_of_rows == 0)\n\t\tPG_RETURN_NULL();\n\n\t/* Finish the sort, or rescan if we already did */\n\tif (!osastate->sort_done)\n\t{\n\t\ttuplesort_performsort(osastate->sortstate);\n\t\tosastate->sort_done = true;\n\t}\n\telse\n\t\ttuplesort_rescan(osastate->sortstate);\n\n\t/*----------\n\t * We need the smallest K such that (K/N) >= percentile.\n\t * N>0, therefore K >= N*percentile, therefore K = ceil(N*percentile).\n\t * So we skip K-1 rows (if K>0) and return the next row fetched.\n\t *----------\n\t */\n\trownum = (int64) ceil(percentile * osastate->number_of_rows);\n\tAssert(rownum <= osastate->number_of_rows);\n\n\tif (rownum > 1)\n\t{\n\t\tif (!tuplesort_skiptuples(osastate->sortstate, rownum - 1, true))\n\t\t\telog(ERROR, \"missing row in percentile_disc\");\n\t}\n\n\tif (!tuplesort_getdatum(osastate->sortstate, true, &val, &isnull, NULL))\n\t\telog(ERROR, \"missing row in percentile_disc\");\n\n\t/* We shouldn't have stored any nulls, but do the right thing anyway */\n\tif (isnull)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(val);\n}"
  },
  {
    "function_name": "ordered_set_transition_multi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "378-416",
    "snippet": "Datum\nordered_set_transition_multi(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\n\t/* If first call, create the transition state workspace */\n\tif (PG_ARGISNULL(0))\n\t\tosastate = ordered_set_startup(fcinfo, true);\n\telse\n\t\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* Form a tuple from all the other inputs besides the transition value */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tnargs = PG_NARGS() - 1;\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tif (osastate->qstate->aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t{\n\t\t/* Add a zero flag value to mark this row as a normal input row */\n\t\tslot->tts_values[i] = Int32GetDatum(0);\n\t\tslot->tts_isnull[i] = false;\n\t\ti++;\n\t}\n\tAssert(i == slot->tts_tupleDescriptor->natts);\n\tExecStoreVirtualTuple(slot);\n\n\t/* Load the row into the tuplesort object */\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\tosastate->number_of_rows++;\n\n\tPG_RETURN_POINTER(osastate);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "osastate"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_puttupleslot",
          "args": [
            "osastate->sortstate",
            "slot"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_puttupleslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1433-1448",
          "snippet": "void\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecStoreVirtualTuple",
          "args": [
            "slot"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "i == slot->tts_tupleDescriptor->natts"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i + 1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "i + 1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordered_set_startup",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ordered_set_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "115-319",
          "snippet": "static OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nordered_set_transition_multi(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\tTupleTableSlot *slot;\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\n\t/* If first call, create the transition state workspace */\n\tif (PG_ARGISNULL(0))\n\t\tosastate = ordered_set_startup(fcinfo, true);\n\telse\n\t\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* Form a tuple from all the other inputs besides the transition value */\n\tslot = osastate->qstate->tupslot;\n\tExecClearTuple(slot);\n\tnargs = PG_NARGS() - 1;\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tslot->tts_values[i] = PG_GETARG_DATUM(i + 1);\n\t\tslot->tts_isnull[i] = PG_ARGISNULL(i + 1);\n\t}\n\tif (osastate->qstate->aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t{\n\t\t/* Add a zero flag value to mark this row as a normal input row */\n\t\tslot->tts_values[i] = Int32GetDatum(0);\n\t\tslot->tts_isnull[i] = false;\n\t\ti++;\n\t}\n\tAssert(i == slot->tts_tupleDescriptor->natts);\n\tExecStoreVirtualTuple(slot);\n\n\t/* Load the row into the tuplesort object */\n\ttuplesort_puttupleslot(osastate->sortstate, slot);\n\tosastate->number_of_rows++;\n\n\tPG_RETURN_POINTER(osastate);\n}"
  },
  {
    "function_name": "ordered_set_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "353-372",
    "snippet": "Datum\nordered_set_transition(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\n\t/* If first call, create the transition state workspace */\n\tif (PG_ARGISNULL(0))\n\t\tosastate = ordered_set_startup(fcinfo, false);\n\telse\n\t\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* Load the datum into the tuplesort object, but only if it's not null */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\ttuplesort_putdatum(osastate->sortstate, PG_GETARG_DATUM(1), false);\n\t\tosastate->number_of_rows++;\n\t}\n\n\tPG_RETURN_POINTER(osastate);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "osastate"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_putdatum",
          "args": [
            "osastate->sortstate",
            "PG_GETARG_DATUM(1)",
            "false"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_putdatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1554-1631",
          "snippet": "void\ntuplesort_putdatum(Tuplesortstate *state, Datum val, bool isNull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Pass-by-value types or null values are just stored directly in\n\t * stup.datum1 (and stup.tuple is not used and set to NULL).\n\t *\n\t * Non-null pass-by-reference values need to be copied into memory we\n\t * control, and possibly abbreviated. The copied value is pointed to by\n\t * stup.tuple and is treated as the canonical copy (e.g. to return via\n\t * tuplesort_getdatum or when writing to tape); stup.datum1 gets the\n\t * abbreviated value if abbreviation is happening, otherwise it's\n\t * identical to stup.tuple.\n\t */\n\n\tif (isNull || !state->tuples)\n\t{\n\t\t/*\n\t\t * Set datum1 to zeroed representation for NULLs (to be consistent,\n\t\t * and to support cheap inequality tests for NULL abbreviated keys).\n\t\t */\n\t\tstup.datum1 = !isNull ? val : (Datum) 0;\n\t\tstup.isnull1 = isNull;\n\t\tstup.tuple = NULL;\t\t/* no separate storage */\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\t}\n\telse\n\t{\n\t\tDatum\t\toriginal = datumCopy(val, false, state->datumTypeLen);\n\n\t\tstup.isnull1 = false;\n\t\tstup.tuple = DatumGetPointer(original);\n\t\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\n\t\tif (!state->sortKeys->abbrev_converter)\n\t\t{\n\t\t\tstup.datum1 = original;\n\t\t}\n\t\telse if (!consider_abort_common(state))\n\t\t{\n\t\t\t/* Store abbreviated key representation */\n\t\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Abort abbreviation */\n\t\t\tint\t\t\ti;\n\n\t\t\tstup.datum1 = original;\n\n\t\t\t/*\n\t\t\t * Set state to be consistent with never trying abbreviation.\n\t\t\t *\n\t\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t\t * ensure a consistent representation (current tuple was just\n\t\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t\t * (TSS_BUILDRUNS state prevents control reaching here in any\n\t\t\t * case).\n\t\t\t */\n\t\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t\t{\n\t\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\t\tmtup->datum1 = PointerGetDatum(mtup->tuple);\n\t\t\t}\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_putdatum(Tuplesortstate *state, Datum val, bool isNull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Pass-by-value types or null values are just stored directly in\n\t * stup.datum1 (and stup.tuple is not used and set to NULL).\n\t *\n\t * Non-null pass-by-reference values need to be copied into memory we\n\t * control, and possibly abbreviated. The copied value is pointed to by\n\t * stup.tuple and is treated as the canonical copy (e.g. to return via\n\t * tuplesort_getdatum or when writing to tape); stup.datum1 gets the\n\t * abbreviated value if abbreviation is happening, otherwise it's\n\t * identical to stup.tuple.\n\t */\n\n\tif (isNull || !state->tuples)\n\t{\n\t\t/*\n\t\t * Set datum1 to zeroed representation for NULLs (to be consistent,\n\t\t * and to support cheap inequality tests for NULL abbreviated keys).\n\t\t */\n\t\tstup.datum1 = !isNull ? val : (Datum) 0;\n\t\tstup.isnull1 = isNull;\n\t\tstup.tuple = NULL;\t\t/* no separate storage */\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\t}\n\telse\n\t{\n\t\tDatum\t\toriginal = datumCopy(val, false, state->datumTypeLen);\n\n\t\tstup.isnull1 = false;\n\t\tstup.tuple = DatumGetPointer(original);\n\t\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\n\t\tif (!state->sortKeys->abbrev_converter)\n\t\t{\n\t\t\tstup.datum1 = original;\n\t\t}\n\t\telse if (!consider_abort_common(state))\n\t\t{\n\t\t\t/* Store abbreviated key representation */\n\t\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Abort abbreviation */\n\t\t\tint\t\t\ti;\n\n\t\t\tstup.datum1 = original;\n\n\t\t\t/*\n\t\t\t * Set state to be consistent with never trying abbreviation.\n\t\t\t *\n\t\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t\t * ensure a consistent representation (current tuple was just\n\t\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t\t * (TSS_BUILDRUNS state prevents control reaching here in any\n\t\t\t * case).\n\t\t\t */\n\t\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t\t{\n\t\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\t\tmtup->datum1 = PointerGetDatum(mtup->tuple);\n\t\t\t}\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordered_set_startup",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ordered_set_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
          "lines": "115-319",
          "snippet": "static OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}",
          "includes": [
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nDatum\nordered_set_transition(PG_FUNCTION_ARGS)\n{\n\tOSAPerGroupState *osastate;\n\n\t/* If first call, create the transition state workspace */\n\tif (PG_ARGISNULL(0))\n\t\tosastate = ordered_set_startup(fcinfo, false);\n\telse\n\t\tosastate = (OSAPerGroupState *) PG_GETARG_POINTER(0);\n\n\t/* Load the datum into the tuplesort object, but only if it's not null */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\ttuplesort_putdatum(osastate->sortstate, PG_GETARG_DATUM(1), false);\n\t\tosastate->number_of_rows++;\n\t}\n\n\tPG_RETURN_POINTER(osastate);\n}"
  },
  {
    "function_name": "ordered_set_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "334-346",
    "snippet": "static void\nordered_set_shutdown(Datum arg)\n{\n\tOSAPerGroupState *osastate = (OSAPerGroupState *) DatumGetPointer(arg);\n\n\t/* Tuplesort object might have temp files. */\n\tif (osastate->sortstate)\n\t\ttuplesort_end(osastate->sortstate);\n\tosastate->sortstate = NULL;\n\t/* The tupleslot probably can't be holding a pin, but let's be safe. */\n\tif (osastate->qstate->tupslot)\n\t\tExecClearTuple(osastate->qstate->tupslot);\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ordered_set_shutdown(Datum arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "osastate->qstate->tupslot"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_end",
          "args": [
            "osastate->sortstate"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1234-1297",
          "snippet": "void\ntuplesort_end(Tuplesortstate *state)\n{\n\t/* context swap probably not needed, but let's be safe */\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tlong\t\tspaceUsed;\n\n\tif (state->tapeset)\n\t\tspaceUsed = LogicalTapeSetBlocks(state->tapeset);\n\telse\n\t\tspaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n#endif\n\n\t/*\n\t * Delete temporary \"tape\" files, if any.\n\t *\n\t * Note: want to include this in reported total cost of sort, hence need\n\t * for two #ifdef TRACE_SORT sections.\n\t */\n\tif (state->tapeset)\n\t\tLogicalTapeSetClose(state->tapeset);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->tapeset)\n\t\t\telog(LOG, \"%s of worker %d ended, %ld disk blocks used: %s\",\n\t\t\t\t SERIAL(state) ? \"external sort\" : \"parallel external sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"%s of worker %d ended, %ld KB used: %s\",\n\t\t\t\t SERIAL(state) ? \"internal sort\" : \"unperformed parallel sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t}\n\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, spaceUsed);\n#else\n\n\t/*\n\t * If you disabled TRACE_SORT, you can still probe sort__done, but you\n\t * ain't getting space-used stats.\n\t */\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, 0L);\n#endif\n\n\t/* Free any execution state created for CLUSTER case */\n\tif (state->estate != NULL)\n\t{\n\t\tExprContext *econtext = GetPerTupleExprContext(state->estate);\n\n\t\tExecDropSingleTupleTableSlot(econtext->ecxt_scantuple);\n\t\tFreeExecutorState(state->estate);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * Free the per-sort memory context, thereby releasing all working memory,\n\t * including the Tuplesortstate struct itself.\n\t */\n\tMemoryContextDelete(state->sortcontext);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_end(Tuplesortstate *state)\n{\n\t/* context swap probably not needed, but let's be safe */\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tlong\t\tspaceUsed;\n\n\tif (state->tapeset)\n\t\tspaceUsed = LogicalTapeSetBlocks(state->tapeset);\n\telse\n\t\tspaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n#endif\n\n\t/*\n\t * Delete temporary \"tape\" files, if any.\n\t *\n\t * Note: want to include this in reported total cost of sort, hence need\n\t * for two #ifdef TRACE_SORT sections.\n\t */\n\tif (state->tapeset)\n\t\tLogicalTapeSetClose(state->tapeset);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->tapeset)\n\t\t\telog(LOG, \"%s of worker %d ended, %ld disk blocks used: %s\",\n\t\t\t\t SERIAL(state) ? \"external sort\" : \"parallel external sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"%s of worker %d ended, %ld KB used: %s\",\n\t\t\t\t SERIAL(state) ? \"internal sort\" : \"unperformed parallel sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t}\n\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, spaceUsed);\n#else\n\n\t/*\n\t * If you disabled TRACE_SORT, you can still probe sort__done, but you\n\t * ain't getting space-used stats.\n\t */\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, 0L);\n#endif\n\n\t/* Free any execution state created for CLUSTER case */\n\tif (state->estate != NULL)\n\t{\n\t\tExprContext *econtext = GetPerTupleExprContext(state->estate);\n\n\t\tExecDropSingleTupleTableSlot(econtext->ecxt_scantuple);\n\t\tFreeExecutorState(state->estate);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * Free the per-sort memory context, thereby releasing all working memory,\n\t * including the Tuplesortstate struct itself.\n\t */\n\tMemoryContextDelete(state->sortcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arg"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void ordered_set_shutdown(Datum arg);\n\nstatic void\nordered_set_shutdown(Datum arg)\n{\n\tOSAPerGroupState *osastate = (OSAPerGroupState *) DatumGetPointer(arg);\n\n\t/* Tuplesort object might have temp files. */\n\tif (osastate->sortstate)\n\t\ttuplesort_end(osastate->sortstate);\n\tosastate->sortstate = NULL;\n\t/* The tupleslot probably can't be holding a pin, but let's be safe. */\n\tif (osastate->qstate->tupslot)\n\t\tExecClearTuple(osastate->qstate->tupslot);\n}"
  },
  {
    "function_name": "ordered_set_startup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/orderedsetaggs.c",
    "lines": "115-319",
    "snippet": "static OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}",
    "includes": [
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/tlist.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_aggregate.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggRegisterCallback",
          "args": [
            "fcinfo",
            "ordered_set_shutdown",
            "PointerGetDatum(osastate)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "osastate"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_datum",
          "args": [
            "qstate->sortColType",
            "qstate->sortOperator",
            "qstate->sortCollation",
            "qstate->sortNullsFirst",
            "work_mem",
            "NULL",
            "qstate->rescan_needed"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_datum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1098-1171",
          "snippet": "Tuplesortstate *\ntuplesort_begin_datum(Oid datumType, Oid sortOperator, Oid sortCollation,\n\t\t\t\t\t  bool nullsFirstFlag, int workMem,\n\t\t\t\t\t  SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin datum sort: workMem = %d, randomAccess = %c\",\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* always a one-column sort */\n\n\tTRACE_POSTGRESQL_SORT_START(DATUM_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_datum;\n\tstate->copytup = copytup_datum;\n\tstate->writetup = writetup_datum;\n\tstate->readtup = readtup_datum;\n\tstate->abbrevNext = 10;\n\n\tstate->datumType = datumType;\n\n\t/* lookup necessary attributes of the datum type */\n\tget_typlenbyval(datumType, &typlen, &typbyval);\n\tstate->datumTypeLen = typlen;\n\tstate->tuples = !typbyval;\n\n\t/* Prepare SortSupport data */\n\tstate->sortKeys = (SortSupport) palloc0(sizeof(SortSupportData));\n\n\tstate->sortKeys->ssup_cxt = CurrentMemoryContext;\n\tstate->sortKeys->ssup_collation = sortCollation;\n\tstate->sortKeys->ssup_nulls_first = nullsFirstFlag;\n\n\t/*\n\t * Abbreviation is possible here only for by-reference types.  In theory,\n\t * a pass-by-value datatype could have an abbreviated form that is cheaper\n\t * to compare.  In a tuple sort, we could support that, because we can\n\t * always extract the original datum from the tuple is needed.  Here, we\n\t * can't, because a datum sort only stores a single copy of the datum; the\n\t * \"tuple\" field of each sortTuple is NULL.\n\t */\n\tstate->sortKeys->abbreviate = !typbyval;\n\n\tPrepareSortSupportFromOrderingOp(sortOperator, state->sortKeys);\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (!state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DATUM_SORT\t\t2"
          ],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DATUM_SORT\t\t2\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_datum(Oid datumType, Oid sortOperator, Oid sortCollation,\n\t\t\t\t\t  bool nullsFirstFlag, int workMem,\n\t\t\t\t\t  SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin datum sort: workMem = %d, randomAccess = %c\",\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* always a one-column sort */\n\n\tTRACE_POSTGRESQL_SORT_START(DATUM_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_datum;\n\tstate->copytup = copytup_datum;\n\tstate->writetup = writetup_datum;\n\tstate->readtup = readtup_datum;\n\tstate->abbrevNext = 10;\n\n\tstate->datumType = datumType;\n\n\t/* lookup necessary attributes of the datum type */\n\tget_typlenbyval(datumType, &typlen, &typbyval);\n\tstate->datumTypeLen = typlen;\n\tstate->tuples = !typbyval;\n\n\t/* Prepare SortSupport data */\n\tstate->sortKeys = (SortSupport) palloc0(sizeof(SortSupportData));\n\n\tstate->sortKeys->ssup_cxt = CurrentMemoryContext;\n\tstate->sortKeys->ssup_collation = sortCollation;\n\tstate->sortKeys->ssup_nulls_first = nullsFirstFlag;\n\n\t/*\n\t * Abbreviation is possible here only for by-reference types.  In theory,\n\t * a pass-by-value datatype could have an abbreviated form that is cheaper\n\t * to compare.  In a tuple sort, we could support that, because we can\n\t * always extract the original datum from the tuple is needed.  Here, we\n\t * can't, because a datum sort only stores a single copy of the datum; the\n\t * \"tuple\" field of each sortTuple is NULL.\n\t */\n\tstate->sortKeys->abbreviate = !typbyval;\n\n\tPrepareSortSupportFromOrderingOp(sortOperator, state->sortKeys);\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (!state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_heap",
          "args": [
            "qstate->tupdesc",
            "qstate->numSortCols",
            "qstate->sortColIdx",
            "qstate->sortOperators",
            "qstate->sortCollations",
            "qstate->sortNullsFirsts",
            "work_mem",
            "NULL",
            "qstate->rescan_needed"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "805-877",
          "snippet": "Tuplesortstate *\ntuplesort_begin_heap(TupleDesc tupDesc,\n\t\t\t\t\t int nkeys, AttrNumber *attNums,\n\t\t\t\t\t Oid *sortOperators, Oid *sortCollations,\n\t\t\t\t\t bool *nullsFirstFlags,\n\t\t\t\t\t int workMem, SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssertArg(nkeys > 0);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t nkeys, workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = nkeys;\n\n\tTRACE_POSTGRESQL_SORT_START(HEAP_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tnkeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_heap;\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\tstate->abbrevNext = 10;\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(nkeys * sizeof(SortSupportData));\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\n\t\tAssertArg(attNums[i] != 0);\n\t\tAssertArg(sortOperators[i] != 0);\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = sortCollations[i];\n\t\tsortKey->ssup_nulls_first = nullsFirstFlags[i];\n\t\tsortKey->ssup_attno = attNums[i];\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tPrepareSortSupportFromOrderingOp(sortOperators[i], sortKey);\n\t}\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (nkeys == 1 && !state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define HEAP_SORT\t\t0"
          ],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define HEAP_SORT\t\t0\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_heap(TupleDesc tupDesc,\n\t\t\t\t\t int nkeys, AttrNumber *attNums,\n\t\t\t\t\t Oid *sortOperators, Oid *sortCollations,\n\t\t\t\t\t bool *nullsFirstFlags,\n\t\t\t\t\t int workMem, SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssertArg(nkeys > 0);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t nkeys, workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = nkeys;\n\n\tTRACE_POSTGRESQL_SORT_START(HEAP_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tnkeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_heap;\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\tstate->abbrevNext = 10;\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(nkeys * sizeof(SortSupportData));\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\n\t\tAssertArg(attNums[i] != 0);\n\t\tAssertArg(sortOperators[i] != 0);\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = sortCollations[i];\n\t\tsortKey->ssup_nulls_first = nullsFirstFlags[i];\n\t\tsortKey->ssup_attno = attNums[i];\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tPrepareSortSupportFromOrderingOp(sortOperators[i], sortKey);\n\t}\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (nkeys == 1 && !state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(OSAPerGroupState)"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "gcontext"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "qstate->sortColType",
            "&qstate->typLen",
            "&qstate->typByVal",
            "&qstate->typAlign"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprCollation",
          "args": [
            "(Node *) tle->expr"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "(Node *) tle->expr"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(sortcl->sortop)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "sortcl->sortop"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sortgroupclause_tle",
          "args": [
            "sortcl",
            "aggref->args"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "sortlist"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"ordered-set aggregate support function does not support multiple aggregated columns\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeSingleTupleTableSlot",
          "args": [
            "qstate->tupdesc"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "qstate->tupdesc"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "newdesc",
            "(AttrNumber) ++natts",
            "\"flag\"",
            "INT4OID",
            "-1",
            "0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescCopyEntry",
          "args": [
            "newdesc",
            "i",
            "qstate->tupdesc",
            "i"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "natts + 1",
            "false"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecTypeFromTL",
          "args": [
            "aggref->args",
            "false"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "i == numSortCols"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "aggref->args"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprCollation",
          "args": [
            "(Node *) tle->expr"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(sortcl->sortop)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "sortcl->sortop"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sortgroupclause_tle",
          "args": [
            "sortcl",
            "aggref->args"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "sortlist"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "sortlist"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggStateIsShared",
          "args": [
            "fcinfo"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(OSAPerQueryState)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "qcontext"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AGGKIND_IS_ORDERED_SET",
          "args": [
            "aggref->aggkind"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggGetAggref",
          "args": [
            "fcinfo"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&gcontext"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tuplesort.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_aggregate.h\"\n#include <math.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic OSAPerGroupState *\nordered_set_startup(FunctionCallInfo fcinfo, bool use_tuples)\n{\n\tOSAPerGroupState *osastate;\n\tOSAPerQueryState *qstate;\n\tMemoryContext gcontext;\n\tMemoryContext oldcontext;\n\n\t/*\n\t * Check we're called as aggregate (and not a window function), and get\n\t * the Agg node's group-lifespan context (which might change from group to\n\t * group, so we shouldn't cache it in the per-query state).\n\t */\n\tif (AggCheckCallContext(fcinfo, &gcontext) != AGG_CONTEXT_AGGREGATE)\n\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\n\t/*\n\t * We keep a link to the per-query state in fn_extra; if it's not there,\n\t * create it, and do the per-query setup we need.\n\t */\n\tqstate = (OSAPerQueryState *) fcinfo->flinfo->fn_extra;\n\tif (qstate == NULL)\n\t{\n\t\tAggref\t   *aggref;\n\t\tMemoryContext qcontext;\n\t\tList\t   *sortlist;\n\t\tint\t\t\tnumSortCols;\n\n\t\t/* Get the Aggref so we can examine aggregate's arguments */\n\t\taggref = AggGetAggref(fcinfo);\n\t\tif (!aggref)\n\t\t\telog(ERROR, \"ordered-set aggregate called in non-aggregate context\");\n\t\tif (!AGGKIND_IS_ORDERED_SET(aggref->aggkind))\n\t\t\telog(ERROR, \"ordered-set aggregate support function called for non-ordered-set aggregate\");\n\n\t\t/*\n\t\t * Prepare per-query structures in the fn_mcxt, which we assume is the\n\t\t * executor's per-query context; in any case it's the right place to\n\t\t * keep anything found via fn_extra.\n\t\t */\n\t\tqcontext = fcinfo->flinfo->fn_mcxt;\n\t\toldcontext = MemoryContextSwitchTo(qcontext);\n\n\t\tqstate = (OSAPerQueryState *) palloc0(sizeof(OSAPerQueryState));\n\t\tqstate->aggref = aggref;\n\t\tqstate->qcontext = qcontext;\n\n\t\t/* We need to support rescans if the trans state is shared */\n\t\tqstate->rescan_needed = AggStateIsShared(fcinfo);\n\n\t\t/* Extract the sort information */\n\t\tsortlist = aggref->aggorder;\n\t\tnumSortCols = list_length(sortlist);\n\n\t\tif (use_tuples)\n\t\t{\n\t\t\tbool\t\tishypothetical = (aggref->aggkind == AGGKIND_HYPOTHETICAL);\n\t\t\tListCell   *lc;\n\t\t\tint\t\t\ti;\n\n\t\t\tif (ishypothetical)\n\t\t\t\tnumSortCols++;\t/* make space for flag column */\n\t\t\tqstate->numSortCols = numSortCols;\n\t\t\tqstate->sortColIdx = (AttrNumber *) palloc(numSortCols * sizeof(AttrNumber));\n\t\t\tqstate->sortOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->eqOperators = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortCollations = (Oid *) palloc(numSortCols * sizeof(Oid));\n\t\t\tqstate->sortNullsFirsts = (bool *) palloc(numSortCols * sizeof(bool));\n\n\t\t\ti = 0;\n\t\t\tforeach(lc, sortlist)\n\t\t\t{\n\t\t\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);\n\t\t\t\tTargetEntry *tle = get_sortgroupclause_tle(sortcl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   aggref->args);\n\n\t\t\t\t/* the parser should have made sure of this */\n\t\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t\tqstate->sortColIdx[i] = tle->resno;\n\t\t\t\tqstate->sortOperators[i] = sortcl->sortop;\n\t\t\t\tqstate->eqOperators[i] = sortcl->eqop;\n\t\t\t\tqstate->sortCollations[i] = exprCollation((Node *) tle->expr);\n\t\t\t\tqstate->sortNullsFirsts[i] = sortcl->nulls_first;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\t/* Add an integer flag column as the last sort column */\n\t\t\t\tqstate->sortColIdx[i] = list_length(aggref->args) + 1;\n\t\t\t\tqstate->sortOperators[i] = Int4LessOperator;\n\t\t\t\tqstate->eqOperators[i] = Int4EqualOperator;\n\t\t\t\tqstate->sortCollations[i] = InvalidOid;\n\t\t\t\tqstate->sortNullsFirsts[i] = false;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(i == numSortCols);\n\n\t\t\t/*\n\t\t\t * Get a tupledesc corresponding to the aggregated inputs\n\t\t\t * (including sort expressions) of the agg.\n\t\t\t */\n\t\t\tqstate->tupdesc = ExecTypeFromTL(aggref->args, false);\n\n\t\t\t/* If we need a flag column, hack the tupledesc to include that */\n\t\t\tif (ishypothetical)\n\t\t\t{\n\t\t\t\tTupleDesc\tnewdesc;\n\t\t\t\tint\t\t\tnatts = qstate->tupdesc->natts;\n\n\t\t\t\tnewdesc = CreateTemplateTupleDesc(natts + 1, false);\n\t\t\t\tfor (i = 1; i <= natts; i++)\n\t\t\t\t\tTupleDescCopyEntry(newdesc, i, qstate->tupdesc, i);\n\n\t\t\t\tTupleDescInitEntry(newdesc,\n\t\t\t\t\t\t\t\t   (AttrNumber) ++natts,\n\t\t\t\t\t\t\t\t   \"flag\",\n\t\t\t\t\t\t\t\t   INT4OID,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\n\t\t\t\tFreeTupleDesc(qstate->tupdesc);\n\t\t\t\tqstate->tupdesc = newdesc;\n\t\t\t}\n\n\t\t\t/* Create slot we'll use to store/retrieve rows */\n\t\t\tqstate->tupslot = MakeSingleTupleTableSlot(qstate->tupdesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Sort single datums */\n\t\t\tSortGroupClause *sortcl;\n\t\t\tTargetEntry *tle;\n\n\t\t\tif (numSortCols != 1 || aggref->aggkind == AGGKIND_HYPOTHETICAL)\n\t\t\t\telog(ERROR, \"ordered-set aggregate support function does not support multiple aggregated columns\");\n\n\t\t\tsortcl = (SortGroupClause *) linitial(sortlist);\n\t\t\ttle = get_sortgroupclause_tle(sortcl, aggref->args);\n\n\t\t\t/* the parser should have made sure of this */\n\t\t\tAssert(OidIsValid(sortcl->sortop));\n\n\t\t\t/* Save sort ordering info */\n\t\t\tqstate->sortColType = exprType((Node *) tle->expr);\n\t\t\tqstate->sortOperator = sortcl->sortop;\n\t\t\tqstate->eqOperator = sortcl->eqop;\n\t\t\tqstate->sortCollation = exprCollation((Node *) tle->expr);\n\t\t\tqstate->sortNullsFirst = sortcl->nulls_first;\n\n\t\t\t/* Save datatype info */\n\t\t\tget_typlenbyvalalign(qstate->sortColType,\n\t\t\t\t\t\t\t\t &qstate->typLen,\n\t\t\t\t\t\t\t\t &qstate->typByVal,\n\t\t\t\t\t\t\t\t &qstate->typAlign);\n\t\t}\n\n\t\tfcinfo->flinfo->fn_extra = (void *) qstate;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* Now build the stuff we need in group-lifespan context */\n\toldcontext = MemoryContextSwitchTo(gcontext);\n\n\tosastate = (OSAPerGroupState *) palloc(sizeof(OSAPerGroupState));\n\tosastate->qstate = qstate;\n\tosastate->gcontext = gcontext;\n\n\t/*\n\t * Initialize tuplesort object.\n\t */\n\tif (use_tuples)\n\t\tosastate->sortstate = tuplesort_begin_heap(qstate->tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->numSortCols,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortColIdx,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortOperators,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortCollations,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->sortNullsFirsts,\n\t\t\t\t\t\t\t\t\t\t\t\t   work_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t   qstate->rescan_needed);\n\telse\n\t\tosastate->sortstate = tuplesort_begin_datum(qstate->sortColType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortCollation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->sortNullsFirst,\n\t\t\t\t\t\t\t\t\t\t\t\t\twork_mem,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tqstate->rescan_needed);\n\n\tosastate->number_of_rows = 0;\n\tosastate->sort_done = false;\n\n\t/* Now register a shutdown callback to clean things up at end of group */\n\tAggRegisterCallback(fcinfo,\n\t\t\t\t\t\tordered_set_shutdown,\n\t\t\t\t\t\tPointerGetDatum(osastate));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn osastate;\n}"
  }
]